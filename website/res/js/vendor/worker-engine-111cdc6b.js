import{N as n,P as e,T as t}from"./embedpdf-678b7803.js";const r="WebWorkerEngine",o="Engine";function a(n,e,t){return{id:n,type:"ExecuteRequest",data:{name:e,args:t}}}class i extends t{constructor(n,e){super(),this.worker=n,this.messageId=e}abort(n){super.abort(n),this.worker.postMessage({id:this.messageId,type:"AbortRequest"})}progress(n){super.progress(n)}}const s=class t{constructor(e,a=new n){this.worker=e,this.logger=a,this.tasks=new Map,this.handle=n=>{this.logger.debug(r,o,"webworker engine start handling message: ",n.data);try{const e=n.data,t=this.tasks.get(e.id);if(!t)return;switch(e.type){case"ReadyResponse":this.readyTask.resolve(!0);break;case"ExecuteProgress":t.progress(e.data);break;case"ExecuteResponse":switch(e.data.type){case"result":t.resolve(e.data.value);break;case"error":t.reject(e.data.value.reason)}this.tasks.delete(e.id)}}catch(n){this.logger.error(r,o,"webworker met error when handling message: ",n)}},this.worker.addEventListener("message",this.handle),this.readyTask=new i(this.worker,t.readyTaskId),this.tasks.set(t.readyTaskId,this.readyTask)}generateRequestId(n){return`${n}.${Date.now()}.${Math.random()}`}initialize(){this.logger.debug(r,o,"initialize");const n=this.generateRequestId("General"),e=new i(this.worker,n),t=a(n,"initialize",[]);return this.proxy(e,t),e}destroy(){this.logger.debug(r,o,"destroy");const n=this.generateRequestId("General"),e=new i(this.worker,n),t=()=>{this.worker.removeEventListener("message",this.handle),this.worker.terminate()};e.wait(t,t);const s=a(n,"destroy",[]);return this.proxy(e,s),e}openDocumentUrl(n,e){this.logger.debug(r,o,"openDocumentUrl",n.url,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"openDocumentUrl",[n,e]);return this.proxy(s,d),s}openDocumentFromBuffer(n,e){this.logger.debug(r,o,"openDocumentFromBuffer",n,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"openDocumentFromBuffer",[n,e]);return this.proxy(s,d),s}openDocumentFromLoader(n,e){this.logger.debug(r,o,"openDocumentFromLoader",n,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"openDocumentFromLoader",[n,e]);return this.proxy(s,d),s}getMetadata(n){this.logger.debug(r,o,"getMetadata",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"getMetadata",[n]);return this.proxy(t,s),t}getDocPermissions(n){this.logger.debug(r,o,"getDocPermissions",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"getDocPermissions",[n]);return this.proxy(t,s),t}getDocUserPermissions(n){this.logger.debug(r,o,"getDocUserPermissions",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"getDocUserPermissions",[n]);return this.proxy(t,s),t}getBookmarks(n){this.logger.debug(r,o,"getBookmarks",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"getBookmarks",[n]);return this.proxy(t,s),t}getSignatures(n){this.logger.debug(r,o,"getSignatures",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"getSignatures",[n]);return this.proxy(t,s),t}renderPage(n,e,t,s,d,u,l="image/webp"){this.logger.debug(r,o,"renderPage",n,e,t,s,d,u);const p=this.generateRequestId(n.id),c=new i(this.worker,p),m=a(p,"renderPage",[n,e,t,s,d,u,l]);return this.proxy(c,m),c}renderPageRect(n,e,t,s,d,u,l,p="image/webp"){this.logger.debug(r,o,"renderPageRect",n,e,t,s,d,u,l);const c=this.generateRequestId(n.id),m=new i(this.worker,c),P=a(c,"renderPageRect",[n,e,t,s,d,u,l,p]);return this.proxy(m,P),m}renderAnnotation(n,e,t,s,d,u,l,p){this.logger.debug(r,o,"renderAnnotation",n,e,t,s,d,u,l,p);const c=this.generateRequestId(n.id),m=new i(this.worker,c),P=a(c,"renderAnnotation",[n,e,t,s,d,u,l,p]);return this.proxy(m,P),m}getAllAnnotations(n){this.logger.debug(r,o,"getAllAnnotations",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"getAllAnnotations",[n]);return this.proxy(t,s),t}getPageAnnotations(n,e){this.logger.debug(r,o,"getPageAnnotations",n,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"getPageAnnotations",[n,e]);return this.proxy(s,d),s}createPageAnnotation(n,e,t,s){this.logger.debug(r,o,"createPageAnnotations",n,e,t,s);const d=this.generateRequestId(n.id),u=new i(this.worker,d),l=a(d,"createPageAnnotation",[n,e,t,s]);return this.proxy(u,l),u}updatePageAnnotation(n,e,t){this.logger.debug(r,o,"updatePageAnnotation",n,e,t);const s=this.generateRequestId(n.id),d=new i(this.worker,s),u=a(s,"updatePageAnnotation",[n,e,t]);return this.proxy(d,u),d}removePageAnnotation(n,e,t){this.logger.debug(r,o,"removePageAnnotations",n,e,t);const s=this.generateRequestId(n.id),d=new i(this.worker,s),u=a(s,"removePageAnnotation",[n,e,t]);return this.proxy(d,u),d}getPageTextRects(n,e,t,s){this.logger.debug(r,o,"getPageTextRects",n,e,t,s);const d=this.generateRequestId(n.id),u=new i(this.worker,d),l=a(d,"getPageTextRects",[n,e,t,s]);return this.proxy(u,l),u}renderThumbnail(n,e,t,s,d){this.logger.debug(r,o,"renderThumbnail",n,e,t,s,d);const u=this.generateRequestId(n.id),l=new i(this.worker,u),p=a(u,"renderThumbnail",[n,e,t,s,d]);return this.proxy(l,p),l}searchAllPages(n,e,t=[]){this.logger.debug(r,o,"searchAllPages",n,e,t);const s=this.generateRequestId(n.id),d=new i(this.worker,s),u=a(s,"searchAllPages",[n,e,t]);return this.proxy(d,u),d}saveAsCopy(n){this.logger.debug(r,o,"saveAsCopy",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"saveAsCopy",[n]);return this.proxy(t,s),t}getAttachments(n){this.logger.debug(r,o,"getAttachments",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"getAttachments",[n]);return this.proxy(t,s),t}readAttachmentContent(n,e){this.logger.debug(r,o,"readAttachmentContent",n,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"readAttachmentContent",[n,e]);return this.proxy(s,d),s}setFormFieldValue(n,e,t,s){this.logger.debug(r,o,"setFormFieldValue",n,t,s);const d=this.generateRequestId(n.id),u=new i(this.worker,d),l=a(d,"setFormFieldValue",[n,e,t,s]);return this.proxy(u,l),u}flattenPage(n,e,t){this.logger.debug(r,o,"flattenPage",n,e,t);const s=this.generateRequestId(n.id),d=new i(this.worker,s),u=a(s,"flattenPage",[n,e,t]);return this.proxy(d,u),d}extractPages(n,e){this.logger.debug(r,o,"extractPages",n);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"extractPages",[n,e]);return this.proxy(s,d),s}extractText(n,e){this.logger.debug(r,o,"extractText",n);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"extractText",[n,e]);return this.proxy(s,d),s}getTextSlices(n,e){this.logger.debug(r,o,"getTextSlices",n,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"getTextSlices",[n,e]);return this.proxy(s,d),s}getPageGlyphs(n,e){this.logger.debug(r,o,"getPageGlyphs",n,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"getPageGlyphs",[n,e]);return this.proxy(s,d),s}getPageGeometry(n,e){this.logger.debug(r,o,"getPageGeometry",n,e);const t=this.generateRequestId(n.id),s=new i(this.worker,t),d=a(t,"getPageGeometry",[n,e]);return this.proxy(s,d),s}merge(n){this.logger.debug(r,o,"merge",n);const e=n.map((n=>n.id)).join("."),t=this.generateRequestId(e),s=new i(this.worker,t),d=a(t,"merge",[n]);return this.proxy(s,d),s}mergePages(n){this.logger.debug(r,o,"mergePages",n);const e=this.generateRequestId(n.map((n=>n.docId)).join(".")),t=new i(this.worker,e),s=a(e,"mergePages",[n]);return this.proxy(t,s),t}closeDocument(n){this.logger.debug(r,o,"closeDocument",n);const e=this.generateRequestId(n.id),t=new i(this.worker,e),s=a(e,"closeDocument",[n]);return this.proxy(t,s),t}proxy(n,t,a=[]){this.logger.debug(r,o,"send request to worker",n,t,a),this.logger.perf(r,o,`${t.data.name}`,"Begin",t.id),this.readyTask.wait((()=>{this.worker.postMessage(t,a),n.wait((()=>{this.logger.perf(r,o,`${t.data.name}`,"End",t.id)}),(()=>{this.logger.perf(r,o,`${t.data.name}`,"End",t.id)})),this.tasks.set(t.id,n)}),(()=>{this.logger.perf(r,o,`${t.data.name}`,"End",t.id),n.reject({code:e.Initialization,message:"worker initialization failed"})}))}};s.readyTaskId="0";let d=s;function u(n,e){const t=new Worker(URL.createObjectURL(new Blob(['var createPdfium = (() => {\n  var _scriptName = import.meta.url;\n  return async function(moduleArg = {}) {\n    var moduleRtn;\n    var Module = moduleArg;\n    var readyPromiseResolve, readyPromiseReject;\n    var readyPromise = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    [\n      "_EPDF_RenderAnnotBitmap",\n      "_EPDFAnnot_ClearColor",\n      "_EPDFAnnot_GenerateAppearance",\n      "_EPDFAnnot_GenerateAppearanceWithBlend",\n      "_EPDFAnnot_GetBlendMode",\n      "_EPDFAnnot_GetBorderDashPattern",\n      "_EPDFAnnot_GetBorderDashPatternCount",\n      "_EPDFAnnot_GetBorderEffect",\n      "_EPDFAnnot_GetBorderStyle",\n      "_EPDFAnnot_GetColor",\n      "_EPDFAnnot_GetDefaultAppearance",\n      "_EPDFAnnot_GetIcon",\n      "_EPDFAnnot_GetIntent",\n      "_EPDFAnnot_GetLineEndings",\n      "_EPDFAnnot_GetOpacity",\n      "_EPDFAnnot_GetRectangleDifferences",\n      "_EPDFAnnot_GetRichContent",\n      "_EPDFAnnot_GetTextAlignment",\n      "_EPDFAnnot_GetVerticalAlignment",\n      "_EPDFAnnot_SetBorderDashPattern",\n      "_EPDFAnnot_SetBorderStyle",\n      "_EPDFAnnot_SetColor",\n      "_EPDFAnnot_SetDefaultAppearance",\n      "_EPDFAnnot_SetIcon",\n      "_EPDFAnnot_SetIntent",\n      "_EPDFAnnot_SetLine",\n      "_EPDFAnnot_SetLineEndings",\n      "_EPDFAnnot_SetLinkedAnnot",\n      "_EPDFAnnot_SetOpacity",\n      "_EPDFAnnot_SetTextAlignment",\n      "_EPDFAnnot_SetVerticalAlignment",\n      "_EPDFAnnot_SetVertices",\n      "_EPDFPage_CreateAnnot",\n      "_EPDFPage_GetAnnotByName",\n      "_EPDFPage_GetAnnotCountRaw",\n      "_EPDFPage_GetAnnotRaw",\n      "_EPDFPage_RemoveAnnotByName",\n      "_FORM_CanRedo",\n      "_FORM_CanUndo",\n      "_FORM_DoDocumentAAction",\n      "_FORM_DoDocumentJSAction",\n      "_FORM_DoDocumentOpenAction",\n      "_FORM_DoPageAAction",\n      "_FORM_ForceToKillFocus",\n      "_FORM_GetFocusedAnnot",\n      "_FORM_GetFocusedText",\n      "_FORM_GetSelectedText",\n      "_FORM_IsIndexSelected",\n      "_FORM_OnAfterLoadPage",\n      "_FORM_OnBeforeClosePage",\n      "_FORM_OnChar",\n      "_FORM_OnFocus",\n      "_FORM_OnKeyDown",\n      "_FORM_OnKeyUp",\n      "_FORM_OnLButtonDoubleClick",\n      "_FORM_OnLButtonDown",\n      "_FORM_OnLButtonUp",\n      "_FORM_OnMouseMove",\n      "_FORM_OnMouseWheel",\n      "_FORM_OnRButtonDown",\n      "_FORM_OnRButtonUp",\n      "_FORM_Redo",\n      "_FORM_ReplaceAndKeepSelection",\n      "_FORM_ReplaceSelection",\n      "_FORM_SelectAllText",\n      "_FORM_SetFocusedAnnot",\n      "_FORM_SetIndexSelected",\n      "_FORM_Undo",\n      "_FPDF_AddInstalledFont",\n      "_FPDF_CloseDocument",\n      "_FPDF_ClosePage",\n      "_FPDF_CloseXObject",\n      "_FPDF_CopyViewerPreferences",\n      "_FPDF_CountNamedDests",\n      "_FPDF_CreateClipPath",\n      "_FPDF_CreateNewDocument",\n      "_FPDF_DestroyClipPath",\n      "_FPDF_DestroyLibrary",\n      "_FPDF_DeviceToPage",\n      "_FPDF_DocumentHasValidCrossReferenceTable",\n      "_FPDF_FFLDraw",\n      "_FPDF_FreeDefaultSystemFontInfo",\n      "_FPDF_GetDefaultSystemFontInfo",\n      "_FPDF_GetDefaultTTFMap",\n      "_FPDF_GetDefaultTTFMapCount",\n      "_FPDF_GetDefaultTTFMapEntry",\n      "_FPDF_GetDocPermissions",\n      "_FPDF_GetDocUserPermissions",\n      "_FPDF_GetFileIdentifier",\n      "_FPDF_GetFileVersion",\n      "_FPDF_GetFormType",\n      "_FPDF_GetLastError",\n      "_FPDF_GetMetaText",\n      "_FPDF_GetNamedDest",\n      "_FPDF_GetNamedDestByName",\n      "_FPDF_GetPageAAction",\n      "_FPDF_GetPageBoundingBox",\n      "_FPDF_GetPageCount",\n      "_FPDF_GetPageHeight",\n      "_FPDF_GetPageHeightF",\n      "_FPDF_GetPageLabel",\n      "_FPDF_GetPageSizeByIndex",\n      "_FPDF_GetPageSizeByIndexF",\n      "_FPDF_GetPageWidth",\n      "_FPDF_GetPageWidthF",\n      "_FPDF_GetSecurityHandlerRevision",\n      "_FPDF_GetSignatureCount",\n      "_FPDF_GetSignatureObject",\n      "_FPDF_GetTrailerEnds",\n      "_FPDF_GetXFAPacketContent",\n      "_FPDF_GetXFAPacketCount",\n      "_FPDF_GetXFAPacketName",\n      "_FPDF_ImportNPagesToOne",\n      "_FPDF_ImportPages",\n      "_FPDF_ImportPagesByIndex",\n      "_FPDF_InitLibrary",\n      "_FPDF_InitLibraryWithConfig",\n      "_FPDF_LoadCustomDocument",\n      "_FPDF_LoadDocument",\n      "_FPDF_LoadMemDocument",\n      "_FPDF_LoadMemDocument64",\n      "_FPDF_LoadPage",\n      "_FPDF_LoadXFA",\n      "_FPDF_MovePages",\n      "_FPDF_NewFormObjectFromXObject",\n      "_FPDF_NewXObjectFromPage",\n      "_FPDF_PageToDevice",\n      "_FPDF_RemoveFormFieldHighlight",\n      "_FPDF_RenderPage_Close",\n      "_FPDF_RenderPage_Continue",\n      "_FPDF_RenderPageBitmap",\n      "_FPDF_RenderPageBitmap_Start",\n      "_FPDF_RenderPageBitmapWithColorScheme_Start",\n      "_FPDF_RenderPageBitmapWithMatrix",\n      "_FPDF_SaveAsCopy",\n      "_FPDF_SaveWithVersion",\n      "_FPDF_SetFormFieldHighlightAlpha",\n      "_FPDF_SetFormFieldHighlightColor",\n      "_FPDF_SetSandBoxPolicy",\n      "_FPDF_SetSystemFontInfo",\n      "_FPDF_StructElement_Attr_CountChildren",\n      "_FPDF_StructElement_Attr_GetBlobValue",\n      "_FPDF_StructElement_Attr_GetBooleanValue",\n      "_FPDF_StructElement_Attr_GetChildAtIndex",\n      "_FPDF_StructElement_Attr_GetCount",\n      "_FPDF_StructElement_Attr_GetName",\n      "_FPDF_StructElement_Attr_GetNumberValue",\n      "_FPDF_StructElement_Attr_GetStringValue",\n      "_FPDF_StructElement_Attr_GetType",\n      "_FPDF_StructElement_Attr_GetValue",\n      "_FPDF_StructElement_CountChildren",\n      "_FPDF_StructElement_GetActualText",\n      "_FPDF_StructElement_GetAltText",\n      "_FPDF_StructElement_GetAttributeAtIndex",\n      "_FPDF_StructElement_GetAttributeCount",\n      "_FPDF_StructElement_GetChildAtIndex",\n      "_FPDF_StructElement_GetChildMarkedContentID",\n      "_FPDF_StructElement_GetID",\n      "_FPDF_StructElement_GetLang",\n      "_FPDF_StructElement_GetMarkedContentID",\n      "_FPDF_StructElement_GetMarkedContentIdAtIndex",\n      "_FPDF_StructElement_GetMarkedContentIdCount",\n      "_FPDF_StructElement_GetObjType",\n      "_FPDF_StructElement_GetParent",\n      "_FPDF_StructElement_GetStringAttribute",\n      "_FPDF_StructElement_GetTitle",\n      "_FPDF_StructElement_GetType",\n      "_FPDF_StructTree_Close",\n      "_FPDF_StructTree_CountChildren",\n      "_FPDF_StructTree_GetChildAtIndex",\n      "_FPDF_StructTree_GetForPage",\n      "_FPDF_VIEWERREF_GetDuplex",\n      "_FPDF_VIEWERREF_GetName",\n      "_FPDF_VIEWERREF_GetNumCopies",\n      "_FPDF_VIEWERREF_GetPrintPageRange",\n      "_FPDF_VIEWERREF_GetPrintPageRangeCount",\n      "_FPDF_VIEWERREF_GetPrintPageRangeElement",\n      "_FPDF_VIEWERREF_GetPrintScaling",\n      "_FPDFAction_GetDest",\n      "_FPDFAction_GetFilePath",\n      "_FPDFAction_GetType",\n      "_FPDFAction_GetURIPath",\n      "_FPDFAnnot_AddFileAttachment",\n      "_FPDFAnnot_AddInkStroke",\n      "_FPDFAnnot_AppendAttachmentPoints",\n      "_FPDFAnnot_AppendObject",\n      "_FPDFAnnot_CountAttachmentPoints",\n      "_FPDFAnnot_GetAP",\n      "_FPDFAnnot_GetAttachmentPoints",\n      "_FPDFAnnot_GetBorder",\n      "_FPDFAnnot_GetColor",\n      "_FPDFAnnot_GetFileAttachment",\n      "_FPDFAnnot_GetFlags",\n      "_FPDFAnnot_GetFocusableSubtypes",\n      "_FPDFAnnot_GetFocusableSubtypesCount",\n      "_FPDFAnnot_GetFontColor",\n      "_FPDFAnnot_GetFontSize",\n      "_FPDFAnnot_GetFormAdditionalActionJavaScript",\n      "_FPDFAnnot_GetFormControlCount",\n      "_FPDFAnnot_GetFormControlIndex",\n      "_FPDFAnnot_GetFormFieldAlternateName",\n      "_FPDFAnnot_GetFormFieldAtPoint",\n      "_FPDFAnnot_GetFormFieldExportValue",\n      "_FPDFAnnot_GetFormFieldFlags",\n      "_FPDFAnnot_GetFormFieldName",\n      "_FPDFAnnot_GetFormFieldType",\n      "_FPDFAnnot_GetFormFieldValue",\n      "_FPDFAnnot_GetInkListCount",\n      "_FPDFAnnot_GetInkListPath",\n      "_FPDFAnnot_GetLine",\n      "_FPDFAnnot_GetLink",\n      "_FPDFAnnot_GetLinkedAnnot",\n      "_FPDFAnnot_GetNumberValue",\n      "_FPDFAnnot_GetObject",\n      "_FPDFAnnot_GetObjectCount",\n      "_FPDFAnnot_GetOptionCount",\n      "_FPDFAnnot_GetOptionLabel",\n      "_FPDFAnnot_GetRect",\n      "_FPDFAnnot_GetStringValue",\n      "_FPDFAnnot_GetSubtype",\n      "_FPDFAnnot_GetValueType",\n      "_FPDFAnnot_GetVertices",\n      "_FPDFAnnot_HasAttachmentPoints",\n      "_FPDFAnnot_HasKey",\n      "_FPDFAnnot_IsChecked",\n      "_FPDFAnnot_IsObjectSupportedSubtype",\n      "_FPDFAnnot_IsOptionSelected",\n      "_FPDFAnnot_IsSupportedSubtype",\n      "_FPDFAnnot_RemoveInkList",\n      "_FPDFAnnot_RemoveObject",\n      "_FPDFAnnot_SetAP",\n      "_FPDFAnnot_SetAttachmentPoints",\n      "_FPDFAnnot_SetBorder",\n      "_FPDFAnnot_SetColor",\n      "_FPDFAnnot_SetFlags",\n      "_FPDFAnnot_SetFocusableSubtypes",\n      "_FPDFAnnot_SetFontColor",\n      "_FPDFAnnot_SetFormFieldFlags",\n      "_FPDFAnnot_SetRect",\n      "_FPDFAnnot_SetStringValue",\n      "_FPDFAnnot_SetURI",\n      "_FPDFAnnot_UpdateObject",\n      "_FPDFAttachment_GetFile",\n      "_FPDFAttachment_GetName",\n      "_FPDFAttachment_GetStringValue",\n      "_FPDFAttachment_GetSubtype",\n      "_FPDFAttachment_GetValueType",\n      "_FPDFAttachment_HasKey",\n      "_FPDFAttachment_SetFile",\n      "_FPDFAttachment_SetStringValue",\n      "_FPDFAvail_Create",\n      "_FPDFAvail_Destroy",\n      "_FPDFAvail_GetDocument",\n      "_FPDFAvail_GetFirstPageNum",\n      "_FPDFAvail_IsDocAvail",\n      "_FPDFAvail_IsFormAvail",\n      "_FPDFAvail_IsLinearized",\n      "_FPDFAvail_IsPageAvail",\n      "_FPDFBitmap_Create",\n      "_FPDFBitmap_CreateEx",\n      "_FPDFBitmap_Destroy",\n      "_FPDFBitmap_FillRect",\n      "_FPDFBitmap_GetBuffer",\n      "_FPDFBitmap_GetFormat",\n      "_FPDFBitmap_GetHeight",\n      "_FPDFBitmap_GetStride",\n      "_FPDFBitmap_GetWidth",\n      "_FPDFBookmark_Find",\n      "_FPDFBookmark_GetAction",\n      "_FPDFBookmark_GetCount",\n      "_FPDFBookmark_GetDest",\n      "_FPDFBookmark_GetFirstChild",\n      "_FPDFBookmark_GetNextSibling",\n      "_FPDFBookmark_GetTitle",\n      "_FPDFCatalog_IsTagged",\n      "_FPDFCatalog_SetLanguage",\n      "_FPDFClipPath_CountPaths",\n      "_FPDFClipPath_CountPathSegments",\n      "_FPDFClipPath_GetPathSegment",\n      "_FPDFDest_GetDestPageIndex",\n      "_FPDFDest_GetLocationInPage",\n      "_FPDFDest_GetView",\n      "_FPDFDoc_AddAttachment",\n      "_FPDFDoc_CloseJavaScriptAction",\n      "_FPDFDoc_DeleteAttachment",\n      "_FPDFDOC_ExitFormFillEnvironment",\n      "_FPDFDoc_GetAttachment",\n      "_FPDFDoc_GetAttachmentCount",\n      "_FPDFDoc_GetJavaScriptAction",\n      "_FPDFDoc_GetJavaScriptActionCount",\n      "_FPDFDoc_GetPageMode",\n      "_FPDFDOC_InitFormFillEnvironment",\n      "_FPDFFont_Close",\n      "_FPDFFont_GetAscent",\n      "_FPDFFont_GetBaseFontName",\n      "_FPDFFont_GetDescent",\n      "_FPDFFont_GetFamilyName",\n      "_FPDFFont_GetFlags",\n      "_FPDFFont_GetFontData",\n      "_FPDFFont_GetGlyphPath",\n      "_FPDFFont_GetGlyphWidth",\n      "_FPDFFont_GetIsEmbedded",\n      "_FPDFFont_GetItalicAngle",\n      "_FPDFFont_GetWeight",\n      "_FPDFFormObj_CountObjects",\n      "_FPDFFormObj_GetObject",\n      "_FPDFFormObj_RemoveObject",\n      "_FPDFGlyphPath_CountGlyphSegments",\n      "_FPDFGlyphPath_GetGlyphPathSegment",\n      "_FPDFImageObj_GetBitmap",\n      "_FPDFImageObj_GetIccProfileDataDecoded",\n      "_FPDFImageObj_GetImageDataDecoded",\n      "_FPDFImageObj_GetImageDataRaw",\n      "_FPDFImageObj_GetImageFilter",\n      "_FPDFImageObj_GetImageFilterCount",\n      "_FPDFImageObj_GetImageMetadata",\n      "_FPDFImageObj_GetImagePixelSize",\n      "_FPDFImageObj_GetRenderedBitmap",\n      "_FPDFImageObj_LoadJpegFile",\n      "_FPDFImageObj_LoadJpegFileInline",\n      "_FPDFImageObj_SetBitmap",\n      "_FPDFImageObj_SetMatrix",\n      "_FPDFJavaScriptAction_GetName",\n      "_FPDFJavaScriptAction_GetScript",\n      "_FPDFLink_CloseWebLinks",\n      "_FPDFLink_CountQuadPoints",\n      "_FPDFLink_CountRects",\n      "_FPDFLink_CountWebLinks",\n      "_FPDFLink_Enumerate",\n      "_FPDFLink_GetAction",\n      "_FPDFLink_GetAnnot",\n      "_FPDFLink_GetAnnotRect",\n      "_FPDFLink_GetDest",\n      "_FPDFLink_GetLinkAtPoint",\n      "_FPDFLink_GetLinkZOrderAtPoint",\n      "_FPDFLink_GetQuadPoints",\n      "_FPDFLink_GetRect",\n      "_FPDFLink_GetTextRange",\n      "_FPDFLink_GetURL",\n      "_FPDFLink_LoadWebLinks",\n      "_FPDFPage_CloseAnnot",\n      "_FPDFPage_CountObjects",\n      "_FPDFPage_CreateAnnot",\n      "_FPDFPage_Delete",\n      "_FPDFPage_Flatten",\n      "_FPDFPage_FormFieldZOrderAtPoint",\n      "_FPDFPage_GenerateContent",\n      "_FPDFPage_GetAnnot",\n      "_FPDFPage_GetAnnotCount",\n      "_FPDFPage_GetAnnotIndex",\n      "_FPDFPage_GetArtBox",\n      "_FPDFPage_GetBleedBox",\n      "_FPDFPage_GetCropBox",\n      "_FPDFPage_GetDecodedThumbnailData",\n      "_FPDFPage_GetMediaBox",\n      "_FPDFPage_GetObject",\n      "_FPDFPage_GetRawThumbnailData",\n      "_FPDFPage_GetRotation",\n      "_FPDFPage_GetThumbnailAsBitmap",\n      "_FPDFPage_GetTrimBox",\n      "_FPDFPage_HasFormFieldAtPoint",\n      "_FPDFPage_HasTransparency",\n      "_FPDFPage_InsertClipPath",\n      "_FPDFPage_InsertObject",\n      "_FPDFPage_InsertObjectAtIndex",\n      "_FPDFPage_New",\n      "_FPDFPage_RemoveAnnot",\n      "_FPDFPage_RemoveObject",\n      "_FPDFPage_SetArtBox",\n      "_FPDFPage_SetBleedBox",\n      "_FPDFPage_SetCropBox",\n      "_FPDFPage_SetMediaBox",\n      "_FPDFPage_SetRotation",\n      "_FPDFPage_SetTrimBox",\n      "_FPDFPage_TransformAnnots",\n      "_FPDFPage_TransFormWithClip",\n      "_FPDFPageObj_AddMark",\n      "_FPDFPageObj_CountMarks",\n      "_FPDFPageObj_CreateNewPath",\n      "_FPDFPageObj_CreateNewRect",\n      "_FPDFPageObj_CreateTextObj",\n      "_FPDFPageObj_Destroy",\n      "_FPDFPageObj_GetBounds",\n      "_FPDFPageObj_GetClipPath",\n      "_FPDFPageObj_GetDashArray",\n      "_FPDFPageObj_GetDashCount",\n      "_FPDFPageObj_GetDashPhase",\n      "_FPDFPageObj_GetFillColor",\n      "_FPDFPageObj_GetIsActive",\n      "_FPDFPageObj_GetLineCap",\n      "_FPDFPageObj_GetLineJoin",\n      "_FPDFPageObj_GetMark",\n      "_FPDFPageObj_GetMarkedContentID",\n      "_FPDFPageObj_GetMatrix",\n      "_FPDFPageObj_GetRotatedBounds",\n      "_FPDFPageObj_GetStrokeColor",\n      "_FPDFPageObj_GetStrokeWidth",\n      "_FPDFPageObj_GetType",\n      "_FPDFPageObj_HasTransparency",\n      "_FPDFPageObj_NewImageObj",\n      "_FPDFPageObj_NewTextObj",\n      "_FPDFPageObj_RemoveMark",\n      "_FPDFPageObj_SetBlendMode",\n      "_FPDFPageObj_SetDashArray",\n      "_FPDFPageObj_SetDashPhase",\n      "_FPDFPageObj_SetFillColor",\n      "_FPDFPageObj_SetIsActive",\n      "_FPDFPageObj_SetLineCap",\n      "_FPDFPageObj_SetLineJoin",\n      "_FPDFPageObj_SetMatrix",\n      "_FPDFPageObj_SetStrokeColor",\n      "_FPDFPageObj_SetStrokeWidth",\n      "_FPDFPageObj_Transform",\n      "_FPDFPageObj_TransformClipPath",\n      "_FPDFPageObj_TransformF",\n      "_FPDFPageObjMark_CountParams",\n      "_FPDFPageObjMark_GetName",\n      "_FPDFPageObjMark_GetParamBlobValue",\n      "_FPDFPageObjMark_GetParamIntValue",\n      "_FPDFPageObjMark_GetParamKey",\n      "_FPDFPageObjMark_GetParamStringValue",\n      "_FPDFPageObjMark_GetParamValueType",\n      "_FPDFPageObjMark_RemoveParam",\n      "_FPDFPageObjMark_SetBlobParam",\n      "_FPDFPageObjMark_SetIntParam",\n      "_FPDFPageObjMark_SetStringParam",\n      "_FPDFPath_BezierTo",\n      "_FPDFPath_Close",\n      "_FPDFPath_CountSegments",\n      "_FPDFPath_GetDrawMode",\n      "_FPDFPath_GetPathSegment",\n      "_FPDFPath_LineTo",\n      "_FPDFPath_MoveTo",\n      "_FPDFPath_SetDrawMode",\n      "_FPDFPathSegment_GetClose",\n      "_FPDFPathSegment_GetPoint",\n      "_FPDFPathSegment_GetType",\n      "_FPDFSignatureObj_GetByteRange",\n      "_FPDFSignatureObj_GetContents",\n      "_FPDFSignatureObj_GetDocMDPPermission",\n      "_FPDFSignatureObj_GetReason",\n      "_FPDFSignatureObj_GetSubFilter",\n      "_FPDFSignatureObj_GetTime",\n      "_FPDFText_ClosePage",\n      "_FPDFText_CountChars",\n      "_FPDFText_CountRects",\n      "_FPDFText_FindClose",\n      "_FPDFText_FindNext",\n      "_FPDFText_FindPrev",\n      "_FPDFText_FindStart",\n      "_FPDFText_GetBoundedText",\n      "_FPDFText_GetCharAngle",\n      "_FPDFText_GetCharBox",\n      "_FPDFText_GetCharIndexAtPos",\n      "_FPDFText_GetCharIndexFromTextIndex",\n      "_FPDFText_GetCharOrigin",\n      "_FPDFText_GetFillColor",\n      "_FPDFText_GetFontInfo",\n      "_FPDFText_GetFontSize",\n      "_FPDFText_GetFontWeight",\n      "_FPDFText_GetLooseCharBox",\n      "_FPDFText_GetMatrix",\n      "_FPDFText_GetRect",\n      "_FPDFText_GetSchCount",\n      "_FPDFText_GetSchResultIndex",\n      "_FPDFText_GetStrokeColor",\n      "_FPDFText_GetText",\n      "_FPDFText_GetTextIndexFromCharIndex",\n      "_FPDFText_GetTextObject",\n      "_FPDFText_GetUnicode",\n      "_FPDFText_HasUnicodeMapError",\n      "_FPDFText_IsGenerated",\n      "_FPDFText_IsHyphen",\n      "_FPDFText_LoadCidType2Font",\n      "_FPDFText_LoadFont",\n      "_FPDFText_LoadPage",\n      "_FPDFText_LoadStandardFont",\n      "_FPDFText_SetCharcodes",\n      "_FPDFText_SetText",\n      "_FPDFTextObj_GetFont",\n      "_FPDFTextObj_GetFontSize",\n      "_FPDFTextObj_GetRenderedBitmap",\n      "_FPDFTextObj_GetText",\n      "_FPDFTextObj_GetTextRenderMode",\n      "_FPDFTextObj_SetTextRenderMode",\n      "_PDFiumExt_CloseFileWriter",\n      "_PDFiumExt_CloseFormFillInfo",\n      "_PDFiumExt_ExitFormFillEnvironment",\n      "_PDFiumExt_GetFileWriterData",\n      "_PDFiumExt_GetFileWriterSize",\n      "_PDFiumExt_Init",\n      "_PDFiumExt_InitFormFillEnvironment",\n      "_PDFiumExt_OpenFileWriter",\n      "_PDFiumExt_OpenFormFillInfo",\n      "_PDFiumExt_SaveAsCopy",\n      "_malloc",\n      "_free",\n      "_memory",\n      "___indirect_function_table",\n      "onRuntimeInitialized"\n    ].forEach((prop) => {\n      if (!Object.getOwnPropertyDescriptor(readyPromise, prop)) {\n        Object.defineProperty(readyPromise, prop, {\n          get: () => abort(\n            "You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"\n          ),\n          set: () => abort(\n            "You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"\n          )\n        });\n      }\n    });\n    var ENVIRONMENT_IS_WEB = typeof window == "object";\n    var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";\n    typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";\n    var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && true && !ENVIRONMENT_IS_WORKER;\n    var moduleOverrides = Object.assign({}, Module);\n    var thisProgram = "./this.program";\n    var scriptDirectory = "";\n    function locateFile(path) {\n      if (Module["locateFile"]) {\n        return Module["locateFile"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var readAsync, readBinary;\n    if (ENVIRONMENT_IS_SHELL) {\n      if (typeof window == "object" || typeof importScripts == "function")\n        throw new Error(\n          "not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"\n        );\n      readBinary = (f) => {\n        if (typeof readbuffer == "function") {\n          return new Uint8Array(readbuffer(f));\n        }\n        let data = read(f, "binary");\n        assert(typeof data == "object");\n        return data;\n      };\n      readAsync = (f) => {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => resolve(readBinary(f)));\n        });\n      };\n      globalThis.clearTimeout ?? (globalThis.clearTimeout = (id) => {\n      });\n      globalThis.setTimeout ?? (globalThis.setTimeout = (f) => typeof f == "function" ? f() : abort());\n      if (typeof print != "undefined") {\n        globalThis.console ?? (globalThis.console = /** @type{!Console} */\n        {});\n        console.log = /** @type{!function(this:Console, ...*): undefined} */\n        print;\n        console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */\n        globalThis.printErr ?? print;\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != "undefined" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptName) {\n        scriptDirectory = _scriptName;\n      }\n      if (scriptDirectory.startsWith("blob:")) {\n        scriptDirectory = "";\n      } else {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1\n        );\n      }\n      if (!(typeof window == "object" || typeof importScripts == "function"))\n        throw new Error(\n          "not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)"\n        );\n      {\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open("GET", url, false);\n            xhr.responseType = "arraybuffer";\n            xhr.send(null);\n            return new Uint8Array(\n              /** @type{!ArrayBuffer} */\n              xhr.response\n            );\n          };\n        }\n        readAsync = (url) => {\n          assert(!isFileURI(url), "readAsync does not work with file:// URLs");\n          return fetch(url, { credentials: "same-origin" }).then((response) => {\n            if (response.ok) {\n              return response.arrayBuffer();\n            }\n            return Promise.reject(new Error(response.status + " : " + response.url));\n          });\n        };\n      }\n    } else {\n      throw new Error("environment detection error");\n    }\n    var out = Module["print"] || console.log.bind(console);\n    var err = Module["printErr"] || console.error.bind(console);\n    Object.assign(Module, moduleOverrides);\n    moduleOverrides = null;\n    checkIncomingModuleAPI();\n    if (Module["arguments"]) Module["arguments"];\n    legacyModuleProp("arguments", "arguments_");\n    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];\n    legacyModuleProp("thisProgram", "thisProgram");\n    assert(\n      typeof Module["memoryInitializerPrefixURL"] == "undefined",\n      "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(\n      typeof Module["pthreadMainPrefixURL"] == "undefined",\n      "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(\n      typeof Module["cdInitializerPrefixURL"] == "undefined",\n      "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(\n      typeof Module["filePackagePrefixURL"] == "undefined",\n      "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"\n    );\n    assert(typeof Module["read"] == "undefined", "Module.read option was removed");\n    assert(\n      typeof Module["readAsync"] == "undefined",\n      "Module.readAsync option was removed (modify readAsync in JS)"\n    );\n    assert(\n      typeof Module["readBinary"] == "undefined",\n      "Module.readBinary option was removed (modify readBinary in JS)"\n    );\n    assert(\n      typeof Module["setWindowTitle"] == "undefined",\n      "Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)"\n    );\n    assert(\n      typeof Module["TOTAL_MEMORY"] == "undefined",\n      "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"\n    );\n    legacyModuleProp("asm", "wasmExports");\n    legacyModuleProp("readAsync", "readAsync");\n    legacyModuleProp("readBinary", "readBinary");\n    legacyModuleProp("setWindowTitle", "setWindowTitle");\n    var wasmBinary = Module["wasmBinary"];\n    legacyModuleProp("wasmBinary", "wasmBinary");\n    if (typeof WebAssembly != "object") {\n      err("no native wasm support detected");\n    }\n    var wasmMemory;\n    var ABORT = false;\n    function assert(condition, text) {\n      if (!condition) {\n        abort("Assertion failed" + (text ? ": " + text : ""));\n      }\n    }\n    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module["HEAP8"] = HEAP8 = new Int8Array(b);\n      Module["HEAP16"] = HEAP16 = new Int16Array(b);\n      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);\n      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);\n      Module["HEAP32"] = HEAP32 = new Int32Array(b);\n      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);\n      Module["HEAPF32"] = HEAPF32 = new Float32Array(b);\n      Module["HEAPF64"] = HEAPF64 = new Float64Array(b);\n    }\n    assert(\n      !Module["STACK_SIZE"],\n      "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time"\n    );\n    assert(\n      typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0,\n      "JS engine does not provide full typed array support"\n    );\n    assert(\n      !Module["wasmMemory"],\n      "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"\n    );\n    assert(\n      !Module["INITIAL_MEMORY"],\n      "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically"\n    );\n    function writeStackCookie() {\n      var max = _emscripten_stack_get_end();\n      assert((max & 3) == 0);\n      if (max == 0) {\n        max += 4;\n      }\n      HEAPU32[max >> 2] = 34821223;\n      HEAPU32[max + 4 >> 2] = 2310721022;\n      HEAPU32[0 >> 2] = 1668509029;\n    }\n    function checkStackCookie() {\n      if (ABORT) return;\n      var max = _emscripten_stack_get_end();\n      if (max == 0) {\n        max += 4;\n      }\n      var cookie1 = HEAPU32[max >> 2];\n      var cookie2 = HEAPU32[max + 4 >> 2];\n      if (cookie1 != 34821223 || cookie2 != 2310721022) {\n        abort(\n          `Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`\n        );\n      }\n      if (HEAPU32[0 >> 2] != 1668509029) {\n        abort("Runtime error: The application has corrupted its heap memory area (address zero)!");\n      }\n    }\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    function preRun() {\n      var preRuns = Module["preRun"];\n      if (preRuns) {\n        if (typeof preRuns == "function") preRuns = [preRuns];\n        preRuns.forEach(addOnPreRun);\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n      checkStackCookie();\n      if (!Module["noFSInit"] && !FS.initialized) FS.init();\n      FS.ignorePermissions = false;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      checkStackCookie();\n      var postRuns = Module["postRun"];\n      if (postRuns) {\n        if (typeof postRuns == "function") postRuns = [postRuns];\n        postRuns.forEach(addOnPostRun);\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    assert(\n      Math.imul,\n      "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    assert(\n      Math.fround,\n      "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    assert(\n      Math.clz32,\n      "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    assert(\n      Math.trunc,\n      "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"\n    );\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    var runDependencyTracking = {};\n    function getUniqueRunDependency(id) {\n      var orig = id;\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n    }\n    function addRunDependency(id) {\n      var _a;\n      runDependencies++;\n      (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n        if (runDependencyWatcher === null && typeof setInterval != "undefined") {\n          runDependencyWatcher = setInterval(() => {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n            var shown = false;\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err("still waiting on run dependencies:");\n              }\n              err(`dependency: ${dep}`);\n            }\n            if (shown) {\n              err("(end of list)");\n            }\n          }, 1e4);\n        }\n      } else {\n        err("warning: run dependency added without ID");\n      }\n    }\n    function removeRunDependency(id) {\n      var _a;\n      runDependencies--;\n      (_a = Module["monitorRunDependencies"]) == null ? void 0 : _a.call(Module, runDependencies);\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err("warning: run dependency removed without ID");\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    function abort(what) {\n      var _a;\n      (_a = Module["onAbort"]) == null ? void 0 : _a.call(Module, what);\n      what = "Aborted(" + what + ")";\n      err(what);\n      ABORT = true;\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = "data:application/octet-stream;base64,";\n    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n    var isFileURI = (filename) => filename.startsWith("file://");\n    function createExportWrapper(name, nargs) {\n      return (...args) => {\n        assert(\n          runtimeInitialized,\n          `native function \\`${name}\\` called before runtime initialization`\n        );\n        var f = wasmExports[name];\n        assert(f, `exported native function \\`${name}\\` not found`);\n        assert(\n          args.length <= nargs,\n          `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`\n        );\n        return f(...args);\n      };\n    }\n    function findWasmBinary() {\n      if (Module["locateFile"]) {\n        var f = "pdfium.wasm";\n        if (!isDataURI(f)) {\n          return locateFile(f);\n        }\n        return f;\n      }\n      if (ENVIRONMENT_IS_SHELL) return "pdfium.wasm";\n      return "pdfium.wasm";\n    }\n    var wasmBinaryFile;\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw "both async and sync fetching of the wasm failed";\n    }\n    function getBinaryPromise(binaryFile) {\n      if (!wasmBinary) {\n        return readAsync(binaryFile).then(\n          (response) => new Uint8Array(\n            /** @type{!ArrayBuffer} */\n            response\n          ),\n          // Fall back to getBinarySync if readAsync fails\n          () => getBinarySync(binaryFile)\n        );\n      }\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile).then((binary) => {\n        return WebAssembly.instantiate(binary, imports);\n      }).then(receiver, (reason) => {\n        err(`failed to asynchronously prepare wasm: ${reason}`);\n        if (isFileURI(wasmBinaryFile)) {\n          err(\n            `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`\n          );\n        }\n        abort(reason);\n      });\n    }\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && // Avoid instantiateStreaming() on Node.js environment for now, as while\n      // Node.js v18.1.0 implements it, it does not have a full fetch()\n      // implementation yet.\n      //\n      // Reference:\n      //   https://github.com/emscripten-core/emscripten/pull/16917\n      true && typeof fetch == "function") {\n        return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {\n          var result = WebAssembly.instantiateStreaming(response, imports);\n          return result.then(callback, function(reason) {\n            err(`wasm streaming compile failed: ${reason}`);\n            err("falling back to ArrayBuffer instantiation");\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n          });\n        });\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n    function getWasmImports() {\n      return {\n        env: wasmImports,\n        wasi_snapshot_preview1: wasmImports\n      };\n    }\n    function createWasm() {\n      var info = getWasmImports();\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n        Module["wasmExports"] = wasmExports;\n        wasmMemory = wasmExports["memory"];\n        assert(wasmMemory, "memory not found in wasm exports");\n        updateMemoryViews();\n        wasmTable = wasmExports["__indirect_function_table"];\n        assert(wasmTable, "table not found in wasm exports");\n        addOnInit(wasmExports["__wasm_call_ctors"]);\n        removeRunDependency("wasm-instantiate");\n        return wasmExports;\n      }\n      addRunDependency("wasm-instantiate");\n      var trueModule = Module;\n      function receiveInstantiationResult(result) {\n        assert(\n          Module === trueModule,\n          "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"\n        );\n        trueModule = null;\n        receiveInstance(result["instance"]);\n      }\n      if (Module["instantiateWasm"]) {\n        try {\n          return Module["instantiateWasm"](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          readyPromiseReject(e);\n        }\n      }\n      wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());\n      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(\n        readyPromiseReject\n      );\n      return {};\n    }\n    var tempDouble;\n    var tempI64;\n    (() => {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 25459;\n      if (h8[0] !== 115 || h8[1] !== 99)\n        throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";\n    })();\n    if (Module["ENVIRONMENT"]) {\n      throw new Error(\n        "Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)"\n      );\n    }\n    function legacyModuleProp(prop, newName, incoming = true) {\n      if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n        Object.defineProperty(Module, prop, {\n          configurable: true,\n          get() {\n            let extra = incoming ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : "";\n            abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\n          }\n        });\n      }\n    }\n    function ignoredModuleProp(prop) {\n      if (Object.getOwnPropertyDescriptor(Module, prop)) {\n        abort(\n          `\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`\n        );\n      }\n    }\n    function isExportedByForceFilesystem(name) {\n      return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || // The old FS has some functionality that WasmFS lacks.\n      name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";\n    }\n    function hookGlobalSymbolAccess(sym, func) {\n      if (typeof globalThis != "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n        Object.defineProperty(globalThis, sym, {\n          configurable: true,\n          get() {\n            func();\n            return void 0;\n          }\n        });\n      }\n    }\n    function missingGlobal(sym, msg) {\n      hookGlobalSymbolAccess(sym, () => {\n        warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\n      });\n    }\n    missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");\n    missingGlobal("asm", "Please use wasmExports instead");\n    function missingLibrarySymbol(sym) {\n      hookGlobalSymbolAccess(sym, () => {\n        var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n        var librarySymbol = sym;\n        if (!librarySymbol.startsWith("_")) {\n          librarySymbol = "$" + sym;\n        }\n        msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=\'${librarySymbol}\')`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";\n        }\n        warnOnce(msg);\n      });\n      unexportedRuntimeSymbol(sym);\n    }\n    function unexportedRuntimeSymbol(sym) {\n      if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n        Object.defineProperty(Module, sym, {\n          configurable: true,\n          get() {\n            var msg = `\'${sym}\' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n            if (isExportedByForceFilesystem(sym)) {\n              msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";\n            }\n            abort(msg);\n          }\n        });\n      }\n    }\n    var callRuntimeCallbacks = (callbacks) => {\n      callbacks.forEach((f) => f(Module));\n    };\n    function getValue(ptr, type = "i8") {\n      if (type.endsWith("*")) type = "*";\n      switch (type) {\n        case "i1":\n          return HEAP8[ptr];\n        case "i8":\n          return HEAP8[ptr];\n        case "i16":\n          return HEAP16[ptr >> 1];\n        case "i32":\n          return HEAP32[ptr >> 2];\n        case "i64":\n          abort("to do getValue(i64) use WASM_BIGINT");\n        case "float":\n          return HEAPF32[ptr >> 2];\n        case "double":\n          return HEAPF64[ptr >> 3];\n        case "*":\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(`invalid type for getValue: ${type}`);\n      }\n    }\n    Module["noExitRuntime"] || true;\n    var ptrToString = (ptr) => {\n      assert(typeof ptr === "number");\n      ptr >>>= 0;\n      return "0x" + ptr.toString(16).padStart(8, "0");\n    };\n    function setValue(ptr, value, type = "i8") {\n      if (type.endsWith("*")) type = "*";\n      switch (type) {\n        case "i1":\n          HEAP8[ptr] = value;\n          break;\n        case "i8":\n          HEAP8[ptr] = value;\n          break;\n        case "i16":\n          HEAP16[ptr >> 1] = value;\n          break;\n        case "i32":\n          HEAP32[ptr >> 2] = value;\n          break;\n        case "i64":\n          abort("to do setValue(i64) use WASM_BIGINT");\n        case "float":\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case "double":\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case "*":\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(`invalid type for setValue: ${type}`);\n      }\n    }\n    var stackRestore = (val) => __emscripten_stack_restore(val);\n    var stackSave = () => _emscripten_stack_get_current();\n    var warnOnce = (text) => {\n      warnOnce.shown || (warnOnce.shown = {});\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;\n    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = "";\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          if ((u0 & 248) != 240)\n            warnOnce(\n              "Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!"\n            );\n          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        }\n      }\n      return str;\n    };\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == "number", `UTF8ToString expects a number (got ${typeof ptr})`);\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";\n    };\n    var ___assert_fail = (condition, filename, line, func) => {\n      abort(\n        `Assertion failed: ${UTF8ToString(condition)}, at: ` + [\n          filename ? UTF8ToString(filename) : "unknown filename",\n          line,\n          func ? UTF8ToString(func) : "unknown function"\n        ]\n      );\n    };\n    function syscallGetVarargI() {\n      assert(SYSCALLS.varargs != void 0);\n      var ret = HEAP32[+SYSCALLS.varargs >> 2];\n      SYSCALLS.varargs += 4;\n      return ret;\n    }\n    var syscallGetVarargP = syscallGetVarargI;\n    var PATH = {\n      isAbs: (path) => path.charAt(0) === "/",\n      splitPath: (filename) => {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: (parts, allowAboveRoot) => {\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === ".") {\n            parts.splice(i, 1);\n          } else if (last === "..") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift("..");\n          }\n        }\n        return parts;\n      },\n      normalize: (path) => {\n        var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";\n        path = PATH.normalizeArray(\n          path.split("/").filter((p) => !!p),\n          !isAbsolute\n        ).join("/");\n        if (!path && !isAbsolute) {\n          path = ".";\n        }\n        if (path && trailingSlash) {\n          path += "/";\n        }\n        return (isAbsolute ? "/" : "") + path;\n      },\n      dirname: (path) => {\n        var result = PATH.splitPath(path), root = result[0], dir = result[1];\n        if (!root && !dir) {\n          return ".";\n        }\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: (path) => {\n        if (path === "/") return "/";\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, "");\n        var lastSlash = path.lastIndexOf("/");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      join: (...paths) => PATH.normalize(paths.join("/")),\n      join2: (l, r) => PATH.normalize(l + "/" + r)\n    };\n    var initRandomFill = () => {\n      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {\n        return (view) => crypto.getRandomValues(view);\n      }\n      abort(\n        "no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"\n      );\n    };\n    var randomFill = (view) => {\n      return (randomFill = initRandomFill())(view);\n    };\n    var PATH_FS = {\n      resolve: (...args) => {\n        var resolvedPath = "", resolvedAbsolute = false;\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? args[i] : FS.cwd();\n          if (typeof path != "string") {\n            throw new TypeError("Arguments to path.resolve must be strings");\n          } else if (!path) {\n            return "";\n          }\n          resolvedPath = path + "/" + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        resolvedPath = PATH.normalizeArray(\n          resolvedPath.split("/").filter((p) => !!p),\n          !resolvedAbsolute\n        ).join("/");\n        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";\n      },\n      relative: (from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== "") break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== "") break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split("/"));\n        var toParts = trim(to.split("/"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push("..");\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join("/");\n      }\n    };\n    var FS_stdin_getChar_buffer = [];\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 127) {\n          len++;\n        } else if (c <= 2047) {\n          len += 2;\n        } else if (c >= 55296 && c <= 57343) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === "string", `stringToUTF8Array expects a string (got ${typeof str})`);\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | u >> 6;\n          heap[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | u >> 12;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 1114111)\n            warnOnce(\n              "Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."\n            );\n          heap[outIdx++] = 240 | u >> 18;\n          heap[outIdx++] = 128 | u >> 12 & 63;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (typeof window != "undefined" && typeof window.prompt == "function") {\n          result = window.prompt("Input: ");\n          if (result !== null) {\n            result += "\\n";\n          }\n        } else if (typeof readline == "function") {\n          result = readline();\n          if (result) {\n            result += "\\n";\n          }\n        } else ;\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n    var TTY = {\n      ttys: [],\n      init() {\n      },\n      shutdown() {\n      },\n      register(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === void 0 && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === void 0) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char(tty) {\n          return FS_stdin_getChar();\n        },\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n        ioctl_tcgets(tty) {\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [\n              3,\n              28,\n              127,\n              21,\n              4,\n              0,\n              1,\n              0,\n              17,\n              19,\n              26,\n              0,\n              18,\n              15,\n              23,\n              22,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0,\n              0\n            ]\n          };\n        },\n        ioctl_tcsets(tty, optional_actions, data) {\n          return 0;\n        },\n        ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        }\n      },\n      default_tty1_ops: {\n        put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    var zeroMemory = (address, size) => {\n      HEAPU8.fill(0, address, address + size);\n    };\n    var alignMemory = (size, alignment) => {\n      assert(alignment, "alignment argument is required");\n      return Math.ceil(size / alignment) * alignment;\n    };\n    var mmapAlloc = (size) => {\n      size = alignMemory(size, 65536);\n      var ptr = _emscripten_builtin_memalign(65536, size);\n      if (ptr) zeroMemory(ptr, size);\n      return ptr;\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount(mount) {\n        return MEMFS.createNode(null, "/", 16384 | 511, 0);\n      },\n      createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table || (MEMFS.ops_table = {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek\n            }\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync\n            }\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink\n            },\n            stream: {}\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: FS.chrdev_stream_ops\n          }\n        });\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(\n          newCapacity,\n          prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0\n        );\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr(node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr(node, attr) {\n          if (attr.mode !== void 0) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== void 0) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== void 0) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {\n            }\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n        },\n        unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir(node) {\n          var entries = [".", ".."];\n          for (var key of Object.keys(node.contents)) {\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write(stream, buffer, offset, length, position, canOwn) {\n          assert(!(buffer instanceof ArrayBuffer));\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              assert(position === 0, "canOwn must imply no weird position inside the file");\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            if (contents) {\n              if (position > 0 || position + length < contents.length) {\n                if (contents.subarray) {\n                  contents = contents.subarray(position, position + length);\n                } else {\n                  contents = Array.prototype.slice.call(contents, position, position + length);\n                }\n              }\n              HEAP8.set(contents, ptr);\n            }\n          }\n          return { ptr, allocated };\n        },\n        msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    var asyncLoad = (url, onload, onerror, noRunDep) => {\n      var dep = getUniqueRunDependency(`al ${url}`);\n      readAsync(url).then(\n        (arrayBuffer) => {\n          assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);\n          onload(new Uint8Array(arrayBuffer));\n          if (dep) removeRunDependency(dep);\n        },\n        (err2) => {\n          if (onerror) {\n            onerror();\n          } else {\n            throw `Loading data file "${url}" failed.`;\n          }\n        }\n      );\n      if (dep) addRunDependency(dep);\n    };\n    var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    };\n    var preloadPlugins = Module["preloadPlugins"] || [];\n    var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\n      if (typeof Browser != "undefined") Browser.init();\n      var handled = false;\n      preloadPlugins.forEach((plugin) => {\n        if (handled) return;\n        if (plugin["canHandle"](fullname)) {\n          plugin["handle"](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n    var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(`cp ${fullname}`);\n      function processData(byteArray) {\n        function finish(byteArray2) {\n          preFinish == null ? void 0 : preFinish();\n          if (!dontCreateFile) {\n            FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);\n          }\n          onload == null ? void 0 : onload();\n          removeRunDependency(dep);\n        }\n        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\n          onerror == null ? void 0 : onerror();\n          removeRunDependency(dep);\n        })) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == "string") {\n        asyncLoad(url, processData, onerror);\n      } else {\n        processData(url);\n      }\n    };\n    var FS_modeStringToFlags = (str) => {\n      var flagModes = {\n        r: 0,\n        "r+": 2,\n        w: 512 | 64 | 1,\n        "w+": 512 | 64 | 2,\n        a: 1024 | 64 | 1,\n        "a+": 1024 | 64 | 2\n      };\n      var flags = flagModes[str];\n      if (typeof flags == "undefined") {\n        throw new Error(`Unknown file open mode: ${str}`);\n      }\n      return flags;\n    };\n    var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n    var strError = (errno) => {\n      return UTF8ToString(_strerror(errno));\n    };\n    var ERRNO_CODES = {\n      EPERM: 63,\n      ENOENT: 44,\n      ESRCH: 71,\n      EINTR: 27,\n      EIO: 29,\n      ENXIO: 60,\n      E2BIG: 1,\n      ENOEXEC: 45,\n      EBADF: 8,\n      ECHILD: 12,\n      EAGAIN: 6,\n      EWOULDBLOCK: 6,\n      ENOMEM: 48,\n      EACCES: 2,\n      EFAULT: 21,\n      ENOTBLK: 105,\n      EBUSY: 10,\n      EEXIST: 20,\n      EXDEV: 75,\n      ENODEV: 43,\n      ENOTDIR: 54,\n      EISDIR: 31,\n      EINVAL: 28,\n      ENFILE: 41,\n      EMFILE: 33,\n      ENOTTY: 59,\n      ETXTBSY: 74,\n      EFBIG: 22,\n      ENOSPC: 51,\n      ESPIPE: 70,\n      EROFS: 69,\n      EMLINK: 34,\n      EPIPE: 64,\n      EDOM: 18,\n      ERANGE: 68,\n      ENOMSG: 49,\n      EIDRM: 24,\n      ECHRNG: 106,\n      EL2NSYNC: 156,\n      EL3HLT: 107,\n      EL3RST: 108,\n      ELNRNG: 109,\n      EUNATCH: 110,\n      ENOCSI: 111,\n      EL2HLT: 112,\n      EDEADLK: 16,\n      ENOLCK: 46,\n      EBADE: 113,\n      EBADR: 114,\n      EXFULL: 115,\n      ENOANO: 104,\n      EBADRQC: 103,\n      EBADSLT: 102,\n      EDEADLOCK: 16,\n      EBFONT: 101,\n      ENOSTR: 100,\n      ENODATA: 116,\n      ETIME: 117,\n      ENOSR: 118,\n      ENONET: 119,\n      ENOPKG: 120,\n      EREMOTE: 121,\n      ENOLINK: 47,\n      EADV: 122,\n      ESRMNT: 123,\n      ECOMM: 124,\n      EPROTO: 65,\n      EMULTIHOP: 36,\n      EDOTDOT: 125,\n      EBADMSG: 9,\n      ENOTUNIQ: 126,\n      EBADFD: 127,\n      EREMCHG: 128,\n      ELIBACC: 129,\n      ELIBBAD: 130,\n      ELIBSCN: 131,\n      ELIBMAX: 132,\n      ELIBEXEC: 133,\n      ENOSYS: 52,\n      ENOTEMPTY: 55,\n      ENAMETOOLONG: 37,\n      ELOOP: 32,\n      EOPNOTSUPP: 138,\n      EPFNOSUPPORT: 139,\n      ECONNRESET: 15,\n      ENOBUFS: 42,\n      EAFNOSUPPORT: 5,\n      EPROTOTYPE: 67,\n      ENOTSOCK: 57,\n      ENOPROTOOPT: 50,\n      ESHUTDOWN: 140,\n      ECONNREFUSED: 14,\n      EADDRINUSE: 3,\n      ECONNABORTED: 13,\n      ENETUNREACH: 40,\n      ENETDOWN: 38,\n      ETIMEDOUT: 73,\n      EHOSTDOWN: 142,\n      EHOSTUNREACH: 23,\n      EINPROGRESS: 26,\n      EALREADY: 7,\n      EDESTADDRREQ: 17,\n      EMSGSIZE: 35,\n      EPROTONOSUPPORT: 66,\n      ESOCKTNOSUPPORT: 137,\n      EADDRNOTAVAIL: 4,\n      ENETRESET: 39,\n      EISCONN: 30,\n      ENOTCONN: 53,\n      ETOOMANYREFS: 141,\n      EUSERS: 136,\n      EDQUOT: 19,\n      ESTALE: 72,\n      ENOTSUP: 138,\n      ENOMEDIUM: 148,\n      EILSEQ: 25,\n      EOVERFLOW: 61,\n      ECANCELED: 11,\n      ENOTRECOVERABLE: 56,\n      EOWNERDEAD: 62,\n      ESTRPIPE: 135\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: "/",\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: class extends Error {\n        // We set the `name` property to be able to identify `FS.ErrnoError`\n        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n        // - when using PROXYFS, an error can come from an underlying FS\n        // as different FS objects have their own FS.ErrnoError each,\n        // the test `err instanceof FS.ErrnoError` won\'t detect an error coming from another filesystem, causing bugs.\n        // we\'ll use the reliable test `err.name == "ErrnoError"` instead\n        constructor(errno) {\n          super(runtimeInitialized ? strError(errno) : "");\n          this.name = "ErrnoError";\n          this.errno = errno;\n          for (var key in ERRNO_CODES) {\n            if (ERRNO_CODES[key] === errno) {\n              this.code = key;\n              break;\n            }\n          }\n        }\n      },\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      readFiles: {},\n      FSStream: class {\n        constructor() {\n          this.shared = {};\n        }\n        get object() {\n          return this.node;\n        }\n        set object(val) {\n          this.node = val;\n        }\n        get isRead() {\n          return (this.flags & 2097155) !== 1;\n        }\n        get isWrite() {\n          return (this.flags & 2097155) !== 0;\n        }\n        get isAppend() {\n          return this.flags & 1024;\n        }\n        get flags() {\n          return this.shared.flags;\n        }\n        set flags(val) {\n          this.shared.flags = val;\n        }\n        get position() {\n          return this.shared.position;\n        }\n        set position(val) {\n          this.shared.position = val;\n        }\n      },\n      FSNode: class {\n        constructor(parent, name, mode, rdev) {\n          if (!parent) {\n            parent = this;\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.mounted = null;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.node_ops = {};\n          this.stream_ops = {};\n          this.rdev = rdev;\n          this.readMode = 292 | 73;\n          this.writeMode = 146;\n        }\n        get read() {\n          return (this.mode & this.readMode) === this.readMode;\n        }\n        set read(val) {\n          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\n        }\n        get write() {\n          return (this.mode & this.writeMode) === this.writeMode;\n        }\n        set write(val) {\n          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\n        }\n        get isFolder() {\n          return FS.isDir(this.mode);\n        }\n        get isDevice() {\n          return FS.isChrdev(this.mode);\n        }\n      },\n      lookupPath(path, opts = {}) {\n        path = PATH_FS.resolve(path);\n        if (!path) return { path: "", node: null };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        opts = Object.assign(defaults, opts);\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n        var parts = path.split("/").filter((p) => !!p);\n        var current = FS.root;\n        var current_path = "/";\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            break;\n          }\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\n              current = lookup.node;\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n        return { path: current_path, node: current };\n      },\n      getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;\n          }\n          path = path ? `${node.name}/${path}` : node.name;\n          node = node.parent;\n        }\n      },\n      hashName(parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        return FS.lookup(parent, name);\n      },\n      createNode(parent, name, mode, rdev) {\n        assert(typeof parent == "object");\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagsToPermissionString(flag) {\n        var perms = ["r", "w", "rw"][flag & 3];\n        if (flag & 512) {\n          perms += "w";\n        }\n        return perms;\n      },\n      nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        if (perms.includes("r") && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes("w") && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes("x") && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, "x");\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, "wx");\n      },\n      mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, "wx");\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== "r" || // opening for write\n          flags & 512) {\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n      getStream: (fd) => FS.streams[fd],\n      createStream(stream, fd = -1) {\n        assert(fd >= -1);\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      dupStream(origStream, fd = -1) {\n        var _a, _b;\n        var stream = FS.createStream(origStream, fd);\n        (_b = (_a = stream.stream_ops) == null ? void 0 : _a.dup) == null ? void 0 : _b.call(_a, stream);\n        return stream;\n      },\n      chrdev_stream_ops: {\n        open(stream) {\n          var _a, _b;\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n          (_b = (_a = stream.stream_ops).open) == null ? void 0 : _b.call(_a, stream);\n        },\n        llseek() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: (dev) => dev >> 8,\n      minor: (dev) => dev & 255,\n      makedev: (ma, mi) => ma << 8 | mi,\n      registerDevice(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n      getDevice: (dev) => FS.devices[dev],\n      getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push(...m.mounts);\n        }\n        return mounts;\n      },\n      syncfs(populate, callback) {\n        if (typeof populate == "function") {\n          callback = populate;\n          populate = false;\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n          err(\n            `warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`\n          );\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n        function doCallback(errCode) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount(type, opts, mountpoint) {\n        if (typeof type == "string") {\n          throw type;\n        }\n        var root = mountpoint === "/";\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n          mountpoint = lookup.path;\n          node = lookup.node;\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n        return mountRoot;\n      },\n      unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n          while (current) {\n            var next = current.name_next;\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === "." || name === "..") {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create(path, mode) {\n        mode = mode !== void 0 ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir(path, mode) {\n        mode = mode !== void 0 ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree(path, mode) {\n        var dirs = path.split("/");\n        var d = "";\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += "/" + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev(path, mode, dev) {\n        if (typeof dev == "undefined") {\n          dev = mode;\n          mode = 438;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== ".") {\n          throw new FS.ErrnoError(28);\n        }\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== ".") {\n          throw new FS.ErrnoError(55);\n        }\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n        }\n        if (old_node === new_node) {\n          return;\n        }\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, "w");\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        FS.hashRemoveNode(old_node);\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == "string") {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & -4096,\n          timestamp: Date.now()\n        });\n      },\n      lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n      chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == "string") {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n          // we ignore the uid / gid for now\n        });\n      },\n      lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == "string") {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, "w");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open(path, flags, mode) {\n        if (path === "") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;\n        if (flags & 64) {\n          mode = typeof mode == "undefined" ? 438 : mode;\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == "object") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {\n          }\n        }\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (FS.isChrdev(node.mode)) {\n          flags &= -513;\n        }\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        if (flags & 512 && !created) {\n          FS.truncate(node, 0);\n        }\n        flags &= -131713;\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node),\n          // we want the absolute path to the node\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        });\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module["logReadFiles"] && !(flags & 1)) {\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null;\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read(stream, buffer, offset, length, position) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != "undefined";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write(stream, buffer, offset, length, position, canOwn) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != "undefined";\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(\n          stream,\n          buffer,\n          offset,\n          length,\n          position,\n          canOwn\n        );\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap(stream, length, position, prot, flags) {\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!length) {\n          throw new FS.ErrnoError(28);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n      msync(stream, buffer, offset, length, mmapFlags) {\n        assert(offset >= 0);\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile(path, opts = {}) {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || "binary";\n        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {\n          throw new Error(`Invalid encoding type "${opts.encoding}"`);\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === "utf8") {\n          ret = UTF8ArrayToString(buf);\n        } else if (opts.encoding === "binary") {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile(path, data, opts = {}) {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == "string") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);\n        } else {\n          throw new Error("Unsupported data type");\n        }\n        FS.close(stream);\n      },\n      cwd: () => FS.currentPath,\n      chdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, "x");\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories() {\n        FS.mkdir("/tmp");\n        FS.mkdir("/home");\n        FS.mkdir("/home/web_user");\n      },\n      createDefaultDevices() {\n        FS.mkdir("/dev");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length\n        });\n        FS.mkdev("/dev/null", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev("/dev/tty", FS.makedev(5, 0));\n        FS.mkdev("/dev/tty1", FS.makedev(6, 0));\n        var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomLeft = randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice("/dev", "random", randomByte);\n        FS.createDevice("/dev", "urandom", randomByte);\n        FS.mkdir("/dev/shm");\n        FS.mkdir("/dev/shm/tmp");\n      },\n      createSpecialDirectories() {\n        FS.mkdir("/proc");\n        var proc_self = FS.mkdir("/proc/self");\n        FS.mkdir("/proc/self/fd");\n        FS.mount(\n          {\n            mount() {\n              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);\n              node.node_ops = {\n                lookup(parent, name) {\n                  var fd = +name;\n                  var stream = FS.getStreamChecked(fd);\n                  var ret = {\n                    parent: null,\n                    mount: { mountpoint: "fake" },\n                    node_ops: { readlink: () => stream.path }\n                  };\n                  ret.parent = ret;\n                  return ret;\n                }\n              };\n              return node;\n            }\n          },\n          {},\n          "/proc/self/fd"\n        );\n      },\n      createStandardStreams(input, output, error) {\n        if (input) {\n          FS.createDevice("/dev", "stdin", input);\n        } else {\n          FS.symlink("/dev/tty", "/dev/stdin");\n        }\n        if (output) {\n          FS.createDevice("/dev", "stdout", null, output);\n        } else {\n          FS.symlink("/dev/tty", "/dev/stdout");\n        }\n        if (error) {\n          FS.createDevice("/dev", "stderr", null, error);\n        } else {\n          FS.symlink("/dev/tty1", "/dev/stderr");\n        }\n        var stdin = FS.open("/dev/stdin", 0);\n        var stdout = FS.open("/dev/stdout", 1);\n        var stderr = FS.open("/dev/stderr", 1);\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\n      },\n      staticInit() {\n        [44].forEach((code) => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = "<generic error, no stack>";\n        });\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, "/");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          MEMFS\n        };\n      },\n      init(input, output, error) {\n        assert(\n          !FS.initialized,\n          "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)"\n        );\n        FS.initialized = true;\n        input ?? (input = Module["stdin"]);\n        output ?? (output = Module["stdout"]);\n        error ?? (error = Module["stderr"]);\n        FS.createStandardStreams(input, output, error);\n      },\n      quit() {\n        FS.initialized = false;\n        _fflush(0);\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n      analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === "/";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        return ret;\n      },\n      createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == "string" ? parent : FS.getPath(parent);\n        var parts = path.split("/").reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n          }\n          parent = current;\n        }\n        return current;\n      },\n      createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == "string" ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == "string") {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n      createDevice(parent, name, input, output) {\n        var _a;\n        var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(!!input, !!output);\n        (_a = FS.createDevice).major ?? (_a.major = 64);\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            var _a2;\n            if ((_a2 = output == null ? void 0 : output.buffer) == null ? void 0 : _a2.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === void 0 && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === void 0) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest != "undefined") {\n          throw new Error(\n            "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."\n          );\n        } else {\n          try {\n            obj.contents = readBinary(obj.url);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n      createLazyFile(parent, name, url, canRead, canWrite) {\n        class LazyUint8Array {\n          constructor() {\n            this.lengthKnown = false;\n            this.chunks = [];\n          }\n          get(idx) {\n            if (idx > this.length - 1 || idx < 0) {\n              return void 0;\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = idx / this.chunkSize | 0;\n            return this.getter(chunkNum)[chunkOffset];\n          }\n          setDataGetter(getter) {\n            this.getter = getter;\n          }\n          cacheLength() {\n            var xhr = new XMLHttpRequest();\n            xhr.open("HEAD", url, false);\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))\n              throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);\n            var datalength = Number(xhr.getResponseHeader("Content-length"));\n            var header;\n            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";\n            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";\n            var chunkSize = 1024 * 1024;\n            if (!hasByteServing) chunkSize = datalength;\n            var doXHR = (from, to) => {\n              if (from > to)\n                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");\n              if (to > datalength - 1)\n                throw new Error("only " + datalength + " bytes available! programmer error!");\n              var xhr2 = new XMLHttpRequest();\n              xhr2.open("GET", url, false);\n              if (datalength !== chunkSize)\n                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);\n              xhr2.responseType = "arraybuffer";\n              if (xhr2.overrideMimeType) {\n                xhr2.overrideMimeType("text/plain; charset=x-user-defined");\n              }\n              xhr2.send(null);\n              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))\n                throw new Error("Couldn\'t load " + url + ". Status: " + xhr2.status);\n              if (xhr2.response !== void 0) {\n                return new Uint8Array(\n                  /** @type{Array<number>} */\n                  xhr2.response || []\n                );\n              }\n              return intArrayFromString(xhr2.responseText || "");\n            };\n            var lazyArray2 = this;\n            lazyArray2.setDataGetter((chunkNum) => {\n              var start = chunkNum * chunkSize;\n              var end = (chunkNum + 1) * chunkSize - 1;\n              end = Math.min(end, datalength - 1);\n              if (typeof lazyArray2.chunks[chunkNum] == "undefined") {\n                lazyArray2.chunks[chunkNum] = doXHR(start, end);\n              }\n              if (typeof lazyArray2.chunks[chunkNum] == "undefined")\n                throw new Error("doXHR failed!");\n              return lazyArray2.chunks[chunkNum];\n            });\n            if (usesGzip || !datalength) {\n              chunkSize = datalength = 1;\n              datalength = this.getter(0).length;\n              chunkSize = datalength;\n              out("LazyFiles on gzip forces download of the whole file when length is accessed");\n            }\n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true;\n          }\n          get length() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n          get chunkSize() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n        if (typeof XMLHttpRequest != "undefined") {\n          if (!ENVIRONMENT_IS_WORKER)\n            throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";\n          var lazyArray = new LazyUint8Array();\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url };\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function() {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = (...args) => {\n            FS.forceLoadFile(node);\n            return fn(...args);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position);\n        };\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      absolutePath() {\n        abort("FS.absolutePath has been removed; use PATH_FS.resolve instead");\n      },\n      createFolder() {\n        abort("FS.createFolder has been removed; use FS.mkdir instead");\n      },\n      createLink() {\n        abort("FS.createLink has been removed; use FS.symlink instead");\n      },\n      joinPath() {\n        abort("FS.joinPath has been removed; use PATH.join instead");\n      },\n      mmapAlloc() {\n        abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc");\n      },\n      standardizePath() {\n        abort("FS.standardizePath has been removed; use PATH.normalize instead");\n      }\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat(func, path, buf) {\n        var stat = func(path);\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = stat.mode;\n        HEAPU32[buf + 8 >> 2] = stat.nlink;\n        HEAP32[buf + 12 >> 2] = stat.uid;\n        HEAP32[buf + 16 >> 2] = stat.gid;\n        HEAP32[buf + 20 >> 2] = stat.rdev;\n        tempI64 = [\n          stat.size >>> 0,\n          (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];\n        HEAP32[buf + 32 >> 2] = 4096;\n        HEAP32[buf + 36 >> 2] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        tempI64 = [\n          Math.floor(atime / 1e3) >>> 0,\n          (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;\n        tempI64 = [\n          Math.floor(mtime / 1e3) >>> 0,\n          (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];\n        HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;\n        tempI64 = [\n          Math.floor(ctime / 1e3) >>> 0,\n          (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];\n        HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;\n        tempI64 = [\n          stat.ino >>> 0,\n          (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n      varargs: void 0,\n      getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      }\n    };\n    function ___syscall_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (cmd) {\n          case 0: {\n            var arg = syscallGetVarargI();\n            if (arg < 0) {\n              return -28;\n            }\n            while (FS.streams[arg]) {\n              arg++;\n            }\n            var newStream;\n            newStream = FS.dupStream(stream, arg);\n            return newStream.fd;\n          }\n          case 1:\n          case 2:\n            return 0;\n          // FD_CLOEXEC makes no sense for a single process.\n          case 3:\n            return stream.flags;\n          case 4: {\n            var arg = syscallGetVarargI();\n            stream.flags |= arg;\n            return 0;\n          }\n          case 12: {\n            var arg = syscallGetVarargP();\n            var offset = 0;\n            HEAP16[arg + offset >> 1] = 2;\n            return 0;\n          }\n          case 13:\n          case 14:\n            return 0;\n        }\n        return -28;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_fstat64(fd, buf) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        return SYSCALLS.doStat(FS.stat, stream.path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    var convertI32PairToI53Checked = (lo, hi) => {\n      assert(lo == lo >>> 0 || lo == (lo | 0));\n      assert(hi === (hi | 0));\n      return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n    };\n    function ___syscall_ftruncate64(fd, length_low, length_high) {\n      var length = convertI32PairToI53Checked(length_low, length_high);\n      try {\n        if (isNaN(length)) return 61;\n        FS.ftruncate(fd, length);\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(\n        typeof maxBytesToWrite == "number",\n        "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"\n      );\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n    function ___syscall_getdents64(fd, dirp, count) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        stream.getdents || (stream.getdents = FS.readdir(stream.path));\n        var struct_size = 280;\n        var pos = 0;\n        var off = FS.llseek(stream, 0, 1);\n        var idx = Math.floor(off / struct_size);\n        while (idx < stream.getdents.length && pos + struct_size <= count) {\n          var id;\n          var type;\n          var name = stream.getdents[idx];\n          if (name === ".") {\n            id = stream.node.id;\n            type = 4;\n          } else if (name === "..") {\n            var lookup = FS.lookupPath(stream.path, { parent: true });\n            id = lookup.node.id;\n            type = 4;\n          } else {\n            var child = FS.lookupNode(stream.node, name);\n            id = child.id;\n            type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8;\n          }\n          assert(id);\n          tempI64 = [\n            id >>> 0,\n            (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n          ], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1];\n          tempI64 = [\n            (idx + 1) * struct_size >>> 0,\n            (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n          ], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1];\n          HEAP16[dirp + pos + 16 >> 1] = 280;\n          HEAP8[dirp + pos + 18] = type;\n          stringToUTF8(name, dirp + pos + 19, 256);\n          pos += struct_size;\n          idx += 1;\n        }\n        FS.llseek(stream, idx * struct_size, 0);\n        return pos;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (op) {\n          case 21509: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21505: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcgets) {\n              var termios = stream.tty.ops.ioctl_tcgets(stream);\n              var argp = syscallGetVarargP();\n              HEAP32[argp >> 2] = termios.c_iflag || 0;\n              HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;\n              HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;\n              HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;\n              for (var i = 0; i < 32; i++) {\n                HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\n              }\n              return 0;\n            }\n            return 0;\n          }\n          case 21510:\n          case 21511:\n          case 21512: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21506:\n          case 21507:\n          case 21508: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tcsets) {\n              var argp = syscallGetVarargP();\n              var c_iflag = HEAP32[argp >> 2];\n              var c_oflag = HEAP32[argp + 4 >> 2];\n              var c_cflag = HEAP32[argp + 8 >> 2];\n              var c_lflag = HEAP32[argp + 12 >> 2];\n              var c_cc = [];\n              for (var i = 0; i < 32; i++) {\n                c_cc.push(HEAP8[argp + i + 17]);\n              }\n              return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n                c_iflag,\n                c_oflag,\n                c_cflag,\n                c_lflag,\n                c_cc\n              });\n            }\n            return 0;\n          }\n          case 21519: {\n            if (!stream.tty) return -59;\n            var argp = syscallGetVarargP();\n            HEAP32[argp >> 2] = 0;\n            return 0;\n          }\n          case 21520: {\n            if (!stream.tty) return -59;\n            return -28;\n          }\n          case 21531: {\n            var argp = syscallGetVarargP();\n            return FS.ioctl(stream, op, argp);\n          }\n          case 21523: {\n            if (!stream.tty) return -59;\n            if (stream.tty.ops.ioctl_tiocgwinsz) {\n              var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n              var argp = syscallGetVarargP();\n              HEAP16[argp >> 1] = winsize[0];\n              HEAP16[argp + 2 >> 1] = winsize[1];\n            }\n            return 0;\n          }\n          case 21524: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          case 21515: {\n            if (!stream.tty) return -59;\n            return 0;\n          }\n          default:\n            return -28;\n        }\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_lstat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.lstat, path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_newfstatat(dirfd, path, buf, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        var nofollow = flags & 256;\n        var allowEmpty = flags & 4096;\n        flags = flags & ~6400;\n        assert(!flags, `unknown flags in __syscall_newfstatat: ${flags}`);\n        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);\n        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_openat(dirfd, path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        var mode = varargs ? syscallGetVarargI() : 0;\n        return FS.open(path, flags, mode).fd;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_rmdir(path) {\n      try {\n        path = SYSCALLS.getStr(path);\n        FS.rmdir(path);\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_stat64(path, buf) {\n      try {\n        path = SYSCALLS.getStr(path);\n        return SYSCALLS.doStat(FS.stat, path, buf);\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_unlinkat(dirfd, path, flags) {\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        if (flags === 0) {\n          FS.unlink(path);\n        } else if (flags === 512) {\n          FS.rmdir(path);\n        } else {\n          abort("Invalid flags passed to unlinkat");\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return -e.errno;\n      }\n    }\n    var __abort_js = () => {\n      abort("native code called abort()");\n    };\n    var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n    var __emscripten_throw_longjmp = () => {\n      throw Infinity;\n    };\n    function __gmtime_js(time_low, time_high, tmPtr) {\n      var time = convertI32PairToI53Checked(time_low, time_high);\n      var date = new Date(time * 1e3);\n      HEAP32[tmPtr >> 2] = date.getUTCSeconds();\n      HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();\n      HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();\n      HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();\n      HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();\n      HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;\n      HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();\n      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\n      var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;\n      HEAP32[tmPtr + 28 >> 2] = yday;\n    }\n    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n    var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n    var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n    var ydayFromDate = (date) => {\n      var leap = isLeapYear(date.getFullYear());\n      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;\n      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;\n      return yday;\n    };\n    function __localtime_js(time_low, time_high, tmPtr) {\n      var time = convertI32PairToI53Checked(time_low, time_high);\n      var date = new Date(time * 1e3);\n      HEAP32[tmPtr >> 2] = date.getSeconds();\n      HEAP32[tmPtr + 4 >> 2] = date.getMinutes();\n      HEAP32[tmPtr + 8 >> 2] = date.getHours();\n      HEAP32[tmPtr + 12 >> 2] = date.getDate();\n      HEAP32[tmPtr + 16 >> 2] = date.getMonth();\n      HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;\n      HEAP32[tmPtr + 24 >> 2] = date.getDay();\n      var yday = ydayFromDate(date) | 0;\n      HEAP32[tmPtr + 28 >> 2] = yday;\n      HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;\n      HEAP32[tmPtr + 32 >> 2] = dst;\n    }\n    var __tzset_js = (timezone, daylight, std_name, dst_name) => {\n      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n      var extractZone = (timezoneOffset) => {\n        var sign = timezoneOffset >= 0 ? "-" : "+";\n        var absOffset = Math.abs(timezoneOffset);\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");\n        var minutes = String(absOffset % 60).padStart(2, "0");\n        return `UTC${sign}${hours}${minutes}`;\n      };\n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      assert(winterName);\n      assert(summerName);\n      assert(\n        lengthBytesUTF8(winterName) <= 16,\n        `timezone name truncated to fit in TZNAME_MAX (${winterName})`\n      );\n      assert(\n        lengthBytesUTF8(summerName) <= 16,\n        `timezone name truncated to fit in TZNAME_MAX (${summerName})`\n      );\n      if (summerOffset < winterOffset) {\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n    var _emscripten_date_now = () => Date.now();\n    var getHeapMax = () => (\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n      // for any code that deals with heap sizes, which would require special\n      // casing all heap size related code to treat 0 specially.\n      2147483648\n    );\n    var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536 | 0;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } catch (e) {\n        err(\n          `growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`\n        );\n      }\n    };\n    var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      requestedSize >>>= 0;\n      assert(requestedSize > oldSize);\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        err(\n          `Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`\n        );\n        return false;\n      }\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(\n          maxHeapSize,\n          alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536)\n        );\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);\n      return false;\n    };\n    var ENV = {};\n    var getExecutableName = () => {\n      return thisProgram || "./this.program";\n    };\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";\n        var env = {\n          USER: "web_user",\n          LOGNAME: "web_user",\n          PATH: "/",\n          PWD: "/",\n          HOME: "/home/web_user",\n          LANG: lang,\n          _: getExecutableName()\n        };\n        for (var x in ENV) {\n          if (ENV[x] === void 0) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));\n        HEAP8[buffer++] = str.charCodeAt(i);\n      }\n      HEAP8[buffer] = 0;\n    };\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[__environ + i * 4 >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach((string) => bufSize += string.length + 1);\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break;\n      }\n      return ret;\n    };\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doReadv(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      var offset = convertI32PairToI53Checked(offset_low, offset_high);\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.llseek(stream, offset, whence);\n        tempI64 = [\n          stream.position >>> 0,\n          (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n        ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    function _fd_sync(fd) {\n      var _a;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        if ((_a = stream.stream_ops) == null ? void 0 : _a.fsync) {\n          return stream.stream_ops.fsync(stream);\n        }\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) {\n          break;\n        }\n      }\n      return ret;\n    };\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doWritev(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;\n        return e.errno;\n      }\n    }\n    var wasmTableMirror = [];\n    var wasmTable;\n    var getWasmTableEntry = (funcPtr) => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      assert(\n        wasmTable.get(funcPtr) == func,\n        "JavaScript-side Wasm function table mirror is out of date!"\n      );\n      return func;\n    };\n    var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;\n    var UTF16ToString = (ptr, maxBytesToRead) => {\n      assert(ptr % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder)\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      var str = "";\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[ptr + i * 2 >> 1];\n        if (codeUnit == 0) break;\n        str += String.fromCharCode(codeUnit);\n      }\n      return str;\n    };\n    var uleb128Encode = (n, target) => {\n      assert(n < 16384);\n      if (n < 128) {\n        target.push(n);\n      } else {\n        target.push(n % 128 | 128, n >> 7);\n      }\n    };\n    var sigToWasmTypes = (sig) => {\n      assert(\n        !sig.includes("j"),\n        "i64 not permitted in function signatures when WASM_BIGINT is disabled"\n      );\n      var typeNames = {\n        i: "i32",\n        j: "i64",\n        f: "f32",\n        d: "f64",\n        e: "externref",\n        p: "i32"\n      };\n      var type = {\n        parameters: [],\n        results: sig[0] == "v" ? [] : [typeNames[sig[0]]]\n      };\n      for (var i = 1; i < sig.length; ++i) {\n        assert(sig[i] in typeNames, "invalid signature char: " + sig[i]);\n        type.parameters.push(typeNames[sig[i]]);\n      }\n      return type;\n    };\n    var generateFuncType = (sig, target) => {\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        i: 127,\n        // i32\n        p: 127,\n        // i32\n        j: 126,\n        // i64\n        f: 125,\n        // f32\n        d: 124,\n        // f64\n        e: 111\n        // externref\n      };\n      target.push(\n        96\n        /* form: func */\n      );\n      uleb128Encode(sigParam.length, target);\n      for (var i = 0; i < sigParam.length; ++i) {\n        assert(sigParam[i] in typeCodes, "invalid signature char: " + sigParam[i]);\n        target.push(typeCodes[sigParam[i]]);\n      }\n      if (sigRet == "v") {\n        target.push(0);\n      } else {\n        target.push(1, typeCodes[sigRet]);\n      }\n    };\n    var convertJsFunctionToWasm = (func, sig) => {\n      assert(\n        !sig.includes("j"),\n        "i64 not permitted in function signatures when WASM_BIGINT is disabled"\n      );\n      if (typeof WebAssembly.Function == "function") {\n        return new WebAssembly.Function(sigToWasmTypes(sig), func);\n      }\n      var typeSectionBody = [\n        1\n        // count: 1\n      ];\n      generateFuncType(sig, typeSectionBody);\n      var bytes = [\n        0,\n        97,\n        115,\n        109,\n        // magic ("\\0asm")\n        1,\n        0,\n        0,\n        0,\n        // version: 1\n        1\n        // Type section code\n      ];\n      uleb128Encode(typeSectionBody.length, bytes);\n      bytes.push(...typeSectionBody);\n      bytes.push(\n        2,\n        7,\n        // import section\n        // (import "e" "f" (func 0 (type 0)))\n        1,\n        1,\n        101,\n        1,\n        102,\n        0,\n        0,\n        7,\n        5,\n        // export section\n        // (export "f" (func 0 (type 0)))\n        1,\n        1,\n        102,\n        0,\n        0\n      );\n      var module = new WebAssembly.Module(new Uint8Array(bytes));\n      var instance = new WebAssembly.Instance(module, { e: { f: func } });\n      var wrappedFunc = instance.exports["f"];\n      return wrappedFunc;\n    };\n    var updateTableMap = (offset, count) => {\n      if (functionsInTableMap) {\n        for (var i = offset; i < offset + count; i++) {\n          var item = getWasmTableEntry(i);\n          if (item) {\n            functionsInTableMap.set(item, i);\n          }\n        }\n      }\n    };\n    var functionsInTableMap;\n    var getFunctionAddress = (func) => {\n      if (!functionsInTableMap) {\n        functionsInTableMap = /* @__PURE__ */ new WeakMap();\n        updateTableMap(0, wasmTable.length);\n      }\n      return functionsInTableMap.get(func) || 0;\n    };\n    var freeTableIndexes = [];\n    var getEmptyTableSlot = () => {\n      if (freeTableIndexes.length) {\n        return freeTableIndexes.pop();\n      }\n      try {\n        wasmTable.grow(1);\n      } catch (err2) {\n        if (!(err2 instanceof RangeError)) {\n          throw err2;\n        }\n        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";\n      }\n      return wasmTable.length - 1;\n    };\n    var setWasmTableEntry = (idx, func) => {\n      wasmTable.set(idx, func);\n      wasmTableMirror[idx] = wasmTable.get(idx);\n    };\n    var addFunction = (func, sig) => {\n      assert(typeof func != "undefined");\n      var rtn = getFunctionAddress(func);\n      if (rtn) {\n        return rtn;\n      }\n      var ret = getEmptyTableSlot();\n      try {\n        setWasmTableEntry(ret, func);\n      } catch (err2) {\n        if (!(err2 instanceof TypeError)) {\n          throw err2;\n        }\n        assert(typeof sig != "undefined", "Missing signature argument to addFunction: " + func);\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        setWasmTableEntry(ret, wrapped);\n      }\n      functionsInTableMap.set(func, ret);\n      return ret;\n    };\n    var getCFunc = (ident) => {\n      var func = Module["_" + ident];\n      assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");\n      return func;\n    };\n    var writeArrayToMemory = (array, buffer) => {\n      assert(\n        array.length >= 0,\n        "writeArrayToMemory array must have a length (should be an array or typed array)"\n      );\n      HEAP8.set(array, buffer);\n    };\n    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\n    var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n    var ccall = (ident, returnType, argTypes, args, opts) => {\n      var toC = {\n        string: (str) => {\n          var ret2 = 0;\n          if (str !== null && str !== void 0 && str !== 0) {\n            ret2 = stringToUTF8OnStack(str);\n          }\n          return ret2;\n        },\n        array: (arr) => {\n          var ret2 = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret2);\n          return ret2;\n        }\n      };\n      function convertReturnValue(ret2) {\n        if (returnType === "string") {\n          return UTF8ToString(ret2);\n        }\n        if (returnType === "boolean") return Boolean(ret2);\n        return ret2;\n      }\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== "array", \'Return type should not be "array".\');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func(...cArgs);\n      function onDone(ret2) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret2);\n      }\n      ret = onDone(ret);\n      return ret;\n    };\n    var cwrap = (ident, returnType, argTypes, opts) => {\n      return (...args) => ccall(ident, returnType, argTypes, args);\n    };\n    var removeFunction = (index) => {\n      functionsInTableMap.delete(getWasmTableEntry(index));\n      setWasmTableEntry(index, null);\n      freeTableIndexes.push(index);\n    };\n    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n      assert(outPtr % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!");\n      assert(\n        typeof maxBytesToWrite == "number",\n        "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"\n      );\n      maxBytesToWrite ?? (maxBytesToWrite = 2147483647);\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    };\n    FS.createPreloadedFile = FS_createPreloadedFile;\n    FS.staticInit();\n    function checkIncomingModuleAPI() {\n      ignoredModuleProp("fetchSettings");\n    }\n    var wasmImports = {\n      /** @export */\n      __assert_fail: ___assert_fail,\n      /** @export */\n      __syscall_fcntl64: ___syscall_fcntl64,\n      /** @export */\n      __syscall_fstat64: ___syscall_fstat64,\n      /** @export */\n      __syscall_ftruncate64: ___syscall_ftruncate64,\n      /** @export */\n      __syscall_getdents64: ___syscall_getdents64,\n      /** @export */\n      __syscall_ioctl: ___syscall_ioctl,\n      /** @export */\n      __syscall_lstat64: ___syscall_lstat64,\n      /** @export */\n      __syscall_newfstatat: ___syscall_newfstatat,\n      /** @export */\n      __syscall_openat: ___syscall_openat,\n      /** @export */\n      __syscall_rmdir: ___syscall_rmdir,\n      /** @export */\n      __syscall_stat64: ___syscall_stat64,\n      /** @export */\n      __syscall_unlinkat: ___syscall_unlinkat,\n      /** @export */\n      _abort_js: __abort_js,\n      /** @export */\n      _emscripten_memcpy_js: __emscripten_memcpy_js,\n      /** @export */\n      _emscripten_throw_longjmp: __emscripten_throw_longjmp,\n      /** @export */\n      _gmtime_js: __gmtime_js,\n      /** @export */\n      _localtime_js: __localtime_js,\n      /** @export */\n      _tzset_js: __tzset_js,\n      /** @export */\n      emscripten_date_now: _emscripten_date_now,\n      /** @export */\n      emscripten_resize_heap: _emscripten_resize_heap,\n      /** @export */\n      environ_get: _environ_get,\n      /** @export */\n      environ_sizes_get: _environ_sizes_get,\n      /** @export */\n      fd_close: _fd_close,\n      /** @export */\n      fd_read: _fd_read,\n      /** @export */\n      fd_seek: _fd_seek,\n      /** @export */\n      fd_sync: _fd_sync,\n      /** @export */\n      fd_write: _fd_write,\n      /** @export */\n      invoke_ii,\n      /** @export */\n      invoke_iii,\n      /** @export */\n      invoke_iiii,\n      /** @export */\n      invoke_iiiii,\n      /** @export */\n      invoke_v,\n      /** @export */\n      invoke_viii,\n      /** @export */\n      invoke_viiii\n    };\n    var wasmExports = createWasm();\n    Module["_PDFiumExt_Init"] = createExportWrapper("PDFiumExt_Init", 0);\n    Module["_FPDF_InitLibraryWithConfig"] = createExportWrapper(\n      "FPDF_InitLibraryWithConfig",\n      1\n    );\n    Module["_PDFiumExt_OpenFileWriter"] = createExportWrapper(\n      "PDFiumExt_OpenFileWriter",\n      0\n    );\n    Module["_PDFiumExt_GetFileWriterSize"] = createExportWrapper("PDFiumExt_GetFileWriterSize", 1);\n    Module["_PDFiumExt_GetFileWriterData"] = createExportWrapper("PDFiumExt_GetFileWriterData", 3);\n    Module["_PDFiumExt_CloseFileWriter"] = createExportWrapper(\n      "PDFiumExt_CloseFileWriter",\n      1\n    );\n    Module["_PDFiumExt_SaveAsCopy"] = createExportWrapper(\n      "PDFiumExt_SaveAsCopy",\n      2\n    );\n    Module["_FPDF_SaveAsCopy"] = createExportWrapper("FPDF_SaveAsCopy", 3);\n    Module["_PDFiumExt_OpenFormFillInfo"] = createExportWrapper(\n      "PDFiumExt_OpenFormFillInfo",\n      0\n    );\n    Module["_PDFiumExt_CloseFormFillInfo"] = createExportWrapper("PDFiumExt_CloseFormFillInfo", 1);\n    Module["_PDFiumExt_InitFormFillEnvironment"] = createExportWrapper("PDFiumExt_InitFormFillEnvironment", 2);\n    Module["_FPDFDOC_InitFormFillEnvironment"] = createExportWrapper("FPDFDOC_InitFormFillEnvironment", 2);\n    Module["_PDFiumExt_ExitFormFillEnvironment"] = createExportWrapper("PDFiumExt_ExitFormFillEnvironment", 1);\n    Module["_FPDFDOC_ExitFormFillEnvironment"] = createExportWrapper("FPDFDOC_ExitFormFillEnvironment", 1);\n    Module["_FPDFAnnot_IsSupportedSubtype"] = createExportWrapper("FPDFAnnot_IsSupportedSubtype", 1);\n    Module["_FPDFPage_CreateAnnot"] = createExportWrapper(\n      "FPDFPage_CreateAnnot",\n      2\n    );\n    Module["_FPDFPage_GetAnnotCount"] = createExportWrapper(\n      "FPDFPage_GetAnnotCount",\n      1\n    );\n    Module["_FPDFPage_GetAnnot"] = createExportWrapper(\n      "FPDFPage_GetAnnot",\n      2\n    );\n    Module["_FPDFPage_GetAnnotIndex"] = createExportWrapper(\n      "FPDFPage_GetAnnotIndex",\n      2\n    );\n    Module["_FPDFPage_CloseAnnot"] = createExportWrapper(\n      "FPDFPage_CloseAnnot",\n      1\n    );\n    Module["_FPDFPage_RemoveAnnot"] = createExportWrapper(\n      "FPDFPage_RemoveAnnot",\n      2\n    );\n    Module["_FPDFAnnot_GetSubtype"] = createExportWrapper(\n      "FPDFAnnot_GetSubtype",\n      1\n    );\n    Module["_FPDFAnnot_IsObjectSupportedSubtype"] = createExportWrapper("FPDFAnnot_IsObjectSupportedSubtype", 1);\n    Module["_FPDFAnnot_UpdateObject"] = createExportWrapper(\n      "FPDFAnnot_UpdateObject",\n      2\n    );\n    Module["_FPDFAnnot_AddInkStroke"] = createExportWrapper(\n      "FPDFAnnot_AddInkStroke",\n      3\n    );\n    Module["_FPDFAnnot_RemoveInkList"] = createExportWrapper(\n      "FPDFAnnot_RemoveInkList",\n      1\n    );\n    Module["_FPDFAnnot_AppendObject"] = createExportWrapper(\n      "FPDFAnnot_AppendObject",\n      2\n    );\n    Module["_FPDFAnnot_GetObjectCount"] = createExportWrapper(\n      "FPDFAnnot_GetObjectCount",\n      1\n    );\n    Module["_FPDFAnnot_GetObject"] = createExportWrapper(\n      "FPDFAnnot_GetObject",\n      2\n    );\n    Module["_FPDFAnnot_RemoveObject"] = createExportWrapper(\n      "FPDFAnnot_RemoveObject",\n      2\n    );\n    Module["_FPDFAnnot_SetColor"] = createExportWrapper(\n      "FPDFAnnot_SetColor",\n      6\n    );\n    Module["_FPDFAnnot_GetColor"] = createExportWrapper(\n      "FPDFAnnot_GetColor",\n      6\n    );\n    Module["_FPDFAnnot_HasAttachmentPoints"] = createExportWrapper("FPDFAnnot_HasAttachmentPoints", 1);\n    Module["_FPDFAnnot_SetAttachmentPoints"] = createExportWrapper("FPDFAnnot_SetAttachmentPoints", 3);\n    Module["_FPDFAnnot_AppendAttachmentPoints"] = createExportWrapper("FPDFAnnot_AppendAttachmentPoints", 2);\n    Module["_FPDFAnnot_CountAttachmentPoints"] = createExportWrapper("FPDFAnnot_CountAttachmentPoints", 1);\n    Module["_FPDFAnnot_GetAttachmentPoints"] = createExportWrapper("FPDFAnnot_GetAttachmentPoints", 3);\n    Module["_FPDFAnnot_SetRect"] = createExportWrapper(\n      "FPDFAnnot_SetRect",\n      2\n    );\n    Module["_FPDFAnnot_GetRect"] = createExportWrapper(\n      "FPDFAnnot_GetRect",\n      2\n    );\n    Module["_FPDFAnnot_GetVertices"] = createExportWrapper(\n      "FPDFAnnot_GetVertices",\n      3\n    );\n    Module["_FPDFAnnot_GetInkListCount"] = createExportWrapper(\n      "FPDFAnnot_GetInkListCount",\n      1\n    );\n    Module["_FPDFAnnot_GetInkListPath"] = createExportWrapper(\n      "FPDFAnnot_GetInkListPath",\n      4\n    );\n    Module["_FPDFAnnot_GetLine"] = createExportWrapper(\n      "FPDFAnnot_GetLine",\n      3\n    );\n    Module["_FPDFAnnot_SetBorder"] = createExportWrapper(\n      "FPDFAnnot_SetBorder",\n      4\n    );\n    Module["_FPDFAnnot_GetBorder"] = createExportWrapper(\n      "FPDFAnnot_GetBorder",\n      4\n    );\n    Module["_FPDFAnnot_HasKey"] = createExportWrapper(\n      "FPDFAnnot_HasKey",\n      2\n    );\n    Module["_FPDFAnnot_GetValueType"] = createExportWrapper(\n      "FPDFAnnot_GetValueType",\n      2\n    );\n    Module["_FPDFAnnot_SetStringValue"] = createExportWrapper(\n      "FPDFAnnot_SetStringValue",\n      3\n    );\n    Module["_FPDFAnnot_GetStringValue"] = createExportWrapper(\n      "FPDFAnnot_GetStringValue",\n      4\n    );\n    Module["_FPDFAnnot_GetNumberValue"] = createExportWrapper(\n      "FPDFAnnot_GetNumberValue",\n      3\n    );\n    Module["_FPDFAnnot_SetAP"] = createExportWrapper("FPDFAnnot_SetAP", 3);\n    Module["_FPDFAnnot_GetAP"] = createExportWrapper("FPDFAnnot_GetAP", 4);\n    Module["_FPDFAnnot_GetLinkedAnnot"] = createExportWrapper(\n      "FPDFAnnot_GetLinkedAnnot",\n      2\n    );\n    Module["_FPDFAnnot_GetFlags"] = createExportWrapper(\n      "FPDFAnnot_GetFlags",\n      1\n    );\n    Module["_FPDFAnnot_SetFlags"] = createExportWrapper(\n      "FPDFAnnot_SetFlags",\n      2\n    );\n    Module["_FPDFAnnot_GetFormFieldFlags"] = createExportWrapper("FPDFAnnot_GetFormFieldFlags", 2);\n    Module["_FPDFAnnot_SetFormFieldFlags"] = createExportWrapper("FPDFAnnot_SetFormFieldFlags", 3);\n    Module["_FPDFAnnot_GetFormFieldAtPoint"] = createExportWrapper("FPDFAnnot_GetFormFieldAtPoint", 3);\n    Module["_FPDFAnnot_GetFormFieldName"] = createExportWrapper(\n      "FPDFAnnot_GetFormFieldName",\n      4\n    );\n    Module["_FPDFAnnot_GetFormFieldType"] = createExportWrapper(\n      "FPDFAnnot_GetFormFieldType",\n      2\n    );\n    Module["_FPDFAnnot_GetFormAdditionalActionJavaScript"] = createExportWrapper("FPDFAnnot_GetFormAdditionalActionJavaScript", 5);\n    Module["_FPDFAnnot_GetFormFieldAlternateName"] = createExportWrapper("FPDFAnnot_GetFormFieldAlternateName", 4);\n    Module["_FPDFAnnot_GetFormFieldValue"] = createExportWrapper("FPDFAnnot_GetFormFieldValue", 4);\n    Module["_FPDFAnnot_GetOptionCount"] = createExportWrapper(\n      "FPDFAnnot_GetOptionCount",\n      2\n    );\n    Module["_FPDFAnnot_GetOptionLabel"] = createExportWrapper(\n      "FPDFAnnot_GetOptionLabel",\n      5\n    );\n    Module["_FPDFAnnot_IsOptionSelected"] = createExportWrapper(\n      "FPDFAnnot_IsOptionSelected",\n      3\n    );\n    Module["_FPDFAnnot_GetFontSize"] = createExportWrapper(\n      "FPDFAnnot_GetFontSize",\n      3\n    );\n    Module["_FPDFAnnot_SetFontColor"] = createExportWrapper(\n      "FPDFAnnot_SetFontColor",\n      5\n    );\n    Module["_FPDFAnnot_GetFontColor"] = createExportWrapper(\n      "FPDFAnnot_GetFontColor",\n      5\n    );\n    Module["_FPDFAnnot_IsChecked"] = createExportWrapper(\n      "FPDFAnnot_IsChecked",\n      2\n    );\n    Module["_FPDFAnnot_SetFocusableSubtypes"] = createExportWrapper("FPDFAnnot_SetFocusableSubtypes", 3);\n    Module["_FPDFAnnot_GetFocusableSubtypesCount"] = createExportWrapper("FPDFAnnot_GetFocusableSubtypesCount", 1);\n    Module["_FPDFAnnot_GetFocusableSubtypes"] = createExportWrapper("FPDFAnnot_GetFocusableSubtypes", 3);\n    Module["_FPDFAnnot_GetLink"] = createExportWrapper(\n      "FPDFAnnot_GetLink",\n      1\n    );\n    Module["_FPDFAnnot_GetFormControlCount"] = createExportWrapper("FPDFAnnot_GetFormControlCount", 2);\n    Module["_FPDFAnnot_GetFormControlIndex"] = createExportWrapper("FPDFAnnot_GetFormControlIndex", 2);\n    Module["_FPDFAnnot_GetFormFieldExportValue"] = createExportWrapper("FPDFAnnot_GetFormFieldExportValue", 4);\n    Module["_FPDFAnnot_SetURI"] = createExportWrapper(\n      "FPDFAnnot_SetURI",\n      2\n    );\n    Module["_FPDFAnnot_GetFileAttachment"] = createExportWrapper("FPDFAnnot_GetFileAttachment", 1);\n    Module["_FPDFAnnot_AddFileAttachment"] = createExportWrapper("FPDFAnnot_AddFileAttachment", 2);\n    Module["_EPDFAnnot_SetColor"] = createExportWrapper(\n      "EPDFAnnot_SetColor",\n      5\n    );\n    Module["_EPDFAnnot_GetColor"] = createExportWrapper(\n      "EPDFAnnot_GetColor",\n      5\n    );\n    Module["_EPDFAnnot_ClearColor"] = createExportWrapper(\n      "EPDFAnnot_ClearColor",\n      2\n    );\n    Module["_EPDFAnnot_SetOpacity"] = createExportWrapper(\n      "EPDFAnnot_SetOpacity",\n      2\n    );\n    Module["_EPDFAnnot_GetOpacity"] = createExportWrapper(\n      "EPDFAnnot_GetOpacity",\n      2\n    );\n    Module["_EPDFAnnot_GetBorderEffect"] = createExportWrapper(\n      "EPDFAnnot_GetBorderEffect",\n      2\n    );\n    Module["_EPDFAnnot_GetRectangleDifferences"] = createExportWrapper("EPDFAnnot_GetRectangleDifferences", 5);\n    Module["_EPDFAnnot_GetBorderDashPatternCount"] = createExportWrapper("EPDFAnnot_GetBorderDashPatternCount", 1);\n    Module["_EPDFAnnot_GetBorderDashPattern"] = createExportWrapper("EPDFAnnot_GetBorderDashPattern", 3);\n    Module["_EPDFAnnot_SetBorderDashPattern"] = createExportWrapper("EPDFAnnot_SetBorderDashPattern", 3);\n    Module["_EPDFAnnot_GetBorderStyle"] = createExportWrapper(\n      "EPDFAnnot_GetBorderStyle",\n      2\n    );\n    Module["_EPDFAnnot_SetBorderStyle"] = createExportWrapper(\n      "EPDFAnnot_SetBorderStyle",\n      3\n    );\n    Module["_EPDFAnnot_GenerateAppearance"] = createExportWrapper("EPDFAnnot_GenerateAppearance", 1);\n    Module["_EPDFAnnot_GenerateAppearanceWithBlend"] = createExportWrapper("EPDFAnnot_GenerateAppearanceWithBlend", 2);\n    Module["_EPDFAnnot_GetBlendMode"] = createExportWrapper(\n      "EPDFAnnot_GetBlendMode",\n      1\n    );\n    Module["_EPDFAnnot_SetIntent"] = createExportWrapper(\n      "EPDFAnnot_SetIntent",\n      2\n    );\n    Module["_EPDFAnnot_GetIntent"] = createExportWrapper(\n      "EPDFAnnot_GetIntent",\n      3\n    );\n    Module["_EPDFAnnot_GetRichContent"] = createExportWrapper(\n      "EPDFAnnot_GetRichContent",\n      3\n    );\n    Module["_EPDFAnnot_SetLineEndings"] = createExportWrapper(\n      "EPDFAnnot_SetLineEndings",\n      3\n    );\n    Module["_EPDFAnnot_GetLineEndings"] = createExportWrapper(\n      "EPDFAnnot_GetLineEndings",\n      3\n    );\n    Module["_EPDFAnnot_SetVertices"] = createExportWrapper(\n      "EPDFAnnot_SetVertices",\n      3\n    );\n    Module["_EPDFAnnot_SetLine"] = createExportWrapper(\n      "EPDFAnnot_SetLine",\n      3\n    );\n    Module["_EPDFAnnot_SetDefaultAppearance"] = createExportWrapper("EPDFAnnot_SetDefaultAppearance", 6);\n    Module["_EPDFAnnot_GetDefaultAppearance"] = createExportWrapper("EPDFAnnot_GetDefaultAppearance", 6);\n    Module["_EPDFAnnot_SetTextAlignment"] = createExportWrapper(\n      "EPDFAnnot_SetTextAlignment",\n      2\n    );\n    Module["_EPDFAnnot_GetTextAlignment"] = createExportWrapper(\n      "EPDFAnnot_GetTextAlignment",\n      1\n    );\n    Module["_EPDFAnnot_SetVerticalAlignment"] = createExportWrapper("EPDFAnnot_SetVerticalAlignment", 2);\n    Module["_EPDFAnnot_GetVerticalAlignment"] = createExportWrapper("EPDFAnnot_GetVerticalAlignment", 1);\n    Module["_EPDFPage_GetAnnotByName"] = createExportWrapper(\n      "EPDFPage_GetAnnotByName",\n      2\n    );\n    Module["_EPDFPage_RemoveAnnotByName"] = createExportWrapper(\n      "EPDFPage_RemoveAnnotByName",\n      2\n    );\n    Module["_EPDFAnnot_SetLinkedAnnot"] = createExportWrapper(\n      "EPDFAnnot_SetLinkedAnnot",\n      3\n    );\n    Module["_EPDFPage_GetAnnotCountRaw"] = createExportWrapper(\n      "EPDFPage_GetAnnotCountRaw",\n      2\n    );\n    Module["_EPDFPage_GetAnnotRaw"] = createExportWrapper(\n      "EPDFPage_GetAnnotRaw",\n      3\n    );\n    Module["_EPDFAnnot_SetIcon"] = createExportWrapper(\n      "EPDFAnnot_SetIcon",\n      2\n    );\n    Module["_EPDFAnnot_GetIcon"] = createExportWrapper(\n      "EPDFAnnot_GetIcon",\n      1\n    );\n    Module["_EPDFPage_CreateAnnot"] = createExportWrapper(\n      "EPDFPage_CreateAnnot",\n      2\n    );\n    Module["_FPDFDoc_GetAttachmentCount"] = createExportWrapper(\n      "FPDFDoc_GetAttachmentCount",\n      1\n    );\n    Module["_FPDFDoc_AddAttachment"] = createExportWrapper(\n      "FPDFDoc_AddAttachment",\n      2\n    );\n    Module["_FPDFDoc_GetAttachment"] = createExportWrapper(\n      "FPDFDoc_GetAttachment",\n      2\n    );\n    Module["_FPDFDoc_DeleteAttachment"] = createExportWrapper(\n      "FPDFDoc_DeleteAttachment",\n      2\n    );\n    Module["_FPDFAttachment_GetName"] = createExportWrapper(\n      "FPDFAttachment_GetName",\n      3\n    );\n    Module["_FPDFAttachment_HasKey"] = createExportWrapper(\n      "FPDFAttachment_HasKey",\n      2\n    );\n    Module["_FPDFAttachment_GetValueType"] = createExportWrapper("FPDFAttachment_GetValueType", 2);\n    Module["_FPDFAttachment_SetStringValue"] = createExportWrapper("FPDFAttachment_SetStringValue", 3);\n    Module["_FPDFAttachment_GetStringValue"] = createExportWrapper("FPDFAttachment_GetStringValue", 4);\n    Module["_FPDFAttachment_SetFile"] = createExportWrapper(\n      "FPDFAttachment_SetFile",\n      4\n    );\n    Module["_FPDFAttachment_GetFile"] = createExportWrapper(\n      "FPDFAttachment_GetFile",\n      4\n    );\n    Module["_FPDFAttachment_GetSubtype"] = createExportWrapper(\n      "FPDFAttachment_GetSubtype",\n      3\n    );\n    Module["_FPDFCatalog_IsTagged"] = createExportWrapper(\n      "FPDFCatalog_IsTagged",\n      1\n    );\n    Module["_FPDFCatalog_SetLanguage"] = createExportWrapper(\n      "FPDFCatalog_SetLanguage",\n      2\n    );\n    Module["_FPDFAvail_Create"] = createExportWrapper(\n      "FPDFAvail_Create",\n      2\n    );\n    Module["_FPDFAvail_Destroy"] = createExportWrapper(\n      "FPDFAvail_Destroy",\n      1\n    );\n    Module["_FPDFAvail_IsDocAvail"] = createExportWrapper(\n      "FPDFAvail_IsDocAvail",\n      2\n    );\n    Module["_FPDFAvail_GetDocument"] = createExportWrapper(\n      "FPDFAvail_GetDocument",\n      2\n    );\n    Module["_FPDFAvail_GetFirstPageNum"] = createExportWrapper(\n      "FPDFAvail_GetFirstPageNum",\n      1\n    );\n    Module["_FPDFAvail_IsPageAvail"] = createExportWrapper(\n      "FPDFAvail_IsPageAvail",\n      3\n    );\n    Module["_FPDFAvail_IsFormAvail"] = createExportWrapper(\n      "FPDFAvail_IsFormAvail",\n      2\n    );\n    Module["_FPDFAvail_IsLinearized"] = createExportWrapper(\n      "FPDFAvail_IsLinearized",\n      1\n    );\n    Module["_FPDFBookmark_GetFirstChild"] = createExportWrapper(\n      "FPDFBookmark_GetFirstChild",\n      2\n    );\n    Module["_FPDFBookmark_GetNextSibling"] = createExportWrapper("FPDFBookmark_GetNextSibling", 2);\n    Module["_FPDFBookmark_GetTitle"] = createExportWrapper(\n      "FPDFBookmark_GetTitle",\n      3\n    );\n    Module["_FPDFBookmark_GetCount"] = createExportWrapper(\n      "FPDFBookmark_GetCount",\n      1\n    );\n    Module["_FPDFBookmark_Find"] = createExportWrapper(\n      "FPDFBookmark_Find",\n      2\n    );\n    Module["_FPDFBookmark_GetDest"] = createExportWrapper(\n      "FPDFBookmark_GetDest",\n      2\n    );\n    Module["_FPDFBookmark_GetAction"] = createExportWrapper(\n      "FPDFBookmark_GetAction",\n      1\n    );\n    Module["_FPDFAction_GetType"] = createExportWrapper(\n      "FPDFAction_GetType",\n      1\n    );\n    Module["_FPDFAction_GetDest"] = createExportWrapper(\n      "FPDFAction_GetDest",\n      2\n    );\n    Module["_FPDFAction_GetFilePath"] = createExportWrapper(\n      "FPDFAction_GetFilePath",\n      3\n    );\n    Module["_FPDFAction_GetURIPath"] = createExportWrapper(\n      "FPDFAction_GetURIPath",\n      4\n    );\n    Module["_FPDFDest_GetDestPageIndex"] = createExportWrapper(\n      "FPDFDest_GetDestPageIndex",\n      2\n    );\n    Module["_FPDFDest_GetView"] = createExportWrapper(\n      "FPDFDest_GetView",\n      3\n    );\n    Module["_FPDFDest_GetLocationInPage"] = createExportWrapper(\n      "FPDFDest_GetLocationInPage",\n      7\n    );\n    Module["_FPDFLink_GetLinkAtPoint"] = createExportWrapper(\n      "FPDFLink_GetLinkAtPoint",\n      3\n    );\n    Module["_FPDFLink_GetLinkZOrderAtPoint"] = createExportWrapper("FPDFLink_GetLinkZOrderAtPoint", 3);\n    Module["_FPDFLink_GetDest"] = createExportWrapper(\n      "FPDFLink_GetDest",\n      2\n    );\n    Module["_FPDFLink_GetAction"] = createExportWrapper(\n      "FPDFLink_GetAction",\n      1\n    );\n    Module["_FPDFLink_Enumerate"] = createExportWrapper(\n      "FPDFLink_Enumerate",\n      3\n    );\n    Module["_FPDFLink_GetAnnot"] = createExportWrapper(\n      "FPDFLink_GetAnnot",\n      2\n    );\n    Module["_FPDFLink_GetAnnotRect"] = createExportWrapper(\n      "FPDFLink_GetAnnotRect",\n      2\n    );\n    Module["_FPDFLink_CountQuadPoints"] = createExportWrapper(\n      "FPDFLink_CountQuadPoints",\n      1\n    );\n    Module["_FPDFLink_GetQuadPoints"] = createExportWrapper(\n      "FPDFLink_GetQuadPoints",\n      3\n    );\n    Module["_FPDF_GetPageAAction"] = createExportWrapper(\n      "FPDF_GetPageAAction",\n      2\n    );\n    Module["_FPDF_GetFileIdentifier"] = createExportWrapper(\n      "FPDF_GetFileIdentifier",\n      4\n    );\n    Module["_FPDF_GetMetaText"] = createExportWrapper(\n      "FPDF_GetMetaText",\n      4\n    );\n    Module["_FPDF_GetPageLabel"] = createExportWrapper(\n      "FPDF_GetPageLabel",\n      4\n    );\n    Module["_FPDFPageObj_NewImageObj"] = createExportWrapper(\n      "FPDFPageObj_NewImageObj",\n      1\n    );\n    Module["_FPDFImageObj_LoadJpegFile"] = createExportWrapper(\n      "FPDFImageObj_LoadJpegFile",\n      4\n    );\n    Module["_FPDFImageObj_LoadJpegFileInline"] = createExportWrapper("FPDFImageObj_LoadJpegFileInline", 4);\n    Module["_FPDFImageObj_SetMatrix"] = createExportWrapper(\n      "FPDFImageObj_SetMatrix",\n      7\n    );\n    Module["_FPDFImageObj_SetBitmap"] = createExportWrapper(\n      "FPDFImageObj_SetBitmap",\n      4\n    );\n    Module["_FPDFImageObj_GetBitmap"] = createExportWrapper(\n      "FPDFImageObj_GetBitmap",\n      1\n    );\n    Module["_FPDFImageObj_GetRenderedBitmap"] = createExportWrapper("FPDFImageObj_GetRenderedBitmap", 3);\n    Module["_FPDFImageObj_GetImageDataDecoded"] = createExportWrapper("FPDFImageObj_GetImageDataDecoded", 3);\n    Module["_FPDFImageObj_GetImageDataRaw"] = createExportWrapper("FPDFImageObj_GetImageDataRaw", 3);\n    Module["_FPDFImageObj_GetImageFilterCount"] = createExportWrapper("FPDFImageObj_GetImageFilterCount", 1);\n    Module["_FPDFImageObj_GetImageFilter"] = createExportWrapper("FPDFImageObj_GetImageFilter", 4);\n    Module["_FPDFImageObj_GetImageMetadata"] = createExportWrapper("FPDFImageObj_GetImageMetadata", 3);\n    Module["_FPDFImageObj_GetImagePixelSize"] = createExportWrapper("FPDFImageObj_GetImagePixelSize", 3);\n    Module["_FPDFImageObj_GetIccProfileDataDecoded"] = createExportWrapper("FPDFImageObj_GetIccProfileDataDecoded", 5);\n    Module["_FPDF_CreateNewDocument"] = createExportWrapper(\n      "FPDF_CreateNewDocument",\n      0\n    );\n    Module["_FPDFPage_Delete"] = createExportWrapper("FPDFPage_Delete", 2);\n    Module["_FPDF_MovePages"] = createExportWrapper("FPDF_MovePages", 4);\n    Module["_FPDFPage_New"] = createExportWrapper("FPDFPage_New", 4);\n    Module["_FPDFPage_GetRotation"] = createExportWrapper(\n      "FPDFPage_GetRotation",\n      1\n    );\n    Module["_FPDFPage_InsertObject"] = createExportWrapper(\n      "FPDFPage_InsertObject",\n      2\n    );\n    Module["_FPDFPage_InsertObjectAtIndex"] = createExportWrapper("FPDFPage_InsertObjectAtIndex", 3);\n    Module["_FPDFPage_RemoveObject"] = createExportWrapper(\n      "FPDFPage_RemoveObject",\n      2\n    );\n    Module["_FPDFPage_CountObjects"] = createExportWrapper(\n      "FPDFPage_CountObjects",\n      1\n    );\n    Module["_FPDFPage_GetObject"] = createExportWrapper(\n      "FPDFPage_GetObject",\n      2\n    );\n    Module["_FPDFPage_HasTransparency"] = createExportWrapper(\n      "FPDFPage_HasTransparency",\n      1\n    );\n    Module["_FPDFPageObj_Destroy"] = createExportWrapper(\n      "FPDFPageObj_Destroy",\n      1\n    );\n    Module["_FPDFPageObj_GetMarkedContentID"] = createExportWrapper("FPDFPageObj_GetMarkedContentID", 1);\n    Module["_FPDFPageObj_CountMarks"] = createExportWrapper(\n      "FPDFPageObj_CountMarks",\n      1\n    );\n    Module["_FPDFPageObj_GetMark"] = createExportWrapper(\n      "FPDFPageObj_GetMark",\n      2\n    );\n    Module["_FPDFPageObj_AddMark"] = createExportWrapper(\n      "FPDFPageObj_AddMark",\n      2\n    );\n    Module["_FPDFPageObj_RemoveMark"] = createExportWrapper(\n      "FPDFPageObj_RemoveMark",\n      2\n    );\n    Module["_FPDFPageObjMark_GetName"] = createExportWrapper(\n      "FPDFPageObjMark_GetName",\n      4\n    );\n    Module["_FPDFPageObjMark_CountParams"] = createExportWrapper("FPDFPageObjMark_CountParams", 1);\n    Module["_FPDFPageObjMark_GetParamKey"] = createExportWrapper("FPDFPageObjMark_GetParamKey", 5);\n    Module["_FPDFPageObjMark_GetParamValueType"] = createExportWrapper("FPDFPageObjMark_GetParamValueType", 2);\n    Module["_FPDFPageObjMark_GetParamIntValue"] = createExportWrapper("FPDFPageObjMark_GetParamIntValue", 3);\n    Module["_FPDFPageObjMark_GetParamStringValue"] = createExportWrapper("FPDFPageObjMark_GetParamStringValue", 5);\n    Module["_FPDFPageObjMark_GetParamBlobValue"] = createExportWrapper("FPDFPageObjMark_GetParamBlobValue", 5);\n    Module["_FPDFPageObj_HasTransparency"] = createExportWrapper("FPDFPageObj_HasTransparency", 1);\n    Module["_FPDFPageObjMark_SetIntParam"] = createExportWrapper("FPDFPageObjMark_SetIntParam", 5);\n    Module["_FPDFPageObjMark_SetStringParam"] = createExportWrapper("FPDFPageObjMark_SetStringParam", 5);\n    Module["_FPDFPageObjMark_SetBlobParam"] = createExportWrapper("FPDFPageObjMark_SetBlobParam", 6);\n    Module["_FPDFPageObjMark_RemoveParam"] = createExportWrapper("FPDFPageObjMark_RemoveParam", 3);\n    Module["_FPDFPageObj_GetType"] = createExportWrapper(\n      "FPDFPageObj_GetType",\n      1\n    );\n    Module["_FPDFPageObj_GetIsActive"] = createExportWrapper(\n      "FPDFPageObj_GetIsActive",\n      2\n    );\n    Module["_FPDFPageObj_SetIsActive"] = createExportWrapper(\n      "FPDFPageObj_SetIsActive",\n      2\n    );\n    Module["_FPDFPage_GenerateContent"] = createExportWrapper(\n      "FPDFPage_GenerateContent",\n      1\n    );\n    Module["_FPDFPageObj_Transform"] = createExportWrapper(\n      "FPDFPageObj_Transform",\n      7\n    );\n    Module["_FPDFPageObj_TransformF"] = createExportWrapper(\n      "FPDFPageObj_TransformF",\n      2\n    );\n    Module["_FPDFPageObj_GetMatrix"] = createExportWrapper(\n      "FPDFPageObj_GetMatrix",\n      2\n    );\n    Module["_FPDFPageObj_SetMatrix"] = createExportWrapper(\n      "FPDFPageObj_SetMatrix",\n      2\n    );\n    Module["_FPDFPageObj_SetBlendMode"] = createExportWrapper(\n      "FPDFPageObj_SetBlendMode",\n      2\n    );\n    Module["_FPDFPage_TransformAnnots"] = createExportWrapper(\n      "FPDFPage_TransformAnnots",\n      7\n    );\n    Module["_FPDFPage_SetRotation"] = createExportWrapper(\n      "FPDFPage_SetRotation",\n      2\n    );\n    Module["_FPDFPageObj_SetFillColor"] = createExportWrapper(\n      "FPDFPageObj_SetFillColor",\n      5\n    );\n    Module["_FPDFPageObj_GetFillColor"] = createExportWrapper(\n      "FPDFPageObj_GetFillColor",\n      5\n    );\n    Module["_FPDFPageObj_GetBounds"] = createExportWrapper(\n      "FPDFPageObj_GetBounds",\n      5\n    );\n    Module["_FPDFPageObj_GetRotatedBounds"] = createExportWrapper("FPDFPageObj_GetRotatedBounds", 2);\n    Module["_FPDFPageObj_SetStrokeColor"] = createExportWrapper(\n      "FPDFPageObj_SetStrokeColor",\n      5\n    );\n    Module["_FPDFPageObj_GetStrokeColor"] = createExportWrapper(\n      "FPDFPageObj_GetStrokeColor",\n      5\n    );\n    Module["_FPDFPageObj_SetStrokeWidth"] = createExportWrapper(\n      "FPDFPageObj_SetStrokeWidth",\n      2\n    );\n    Module["_FPDFPageObj_GetStrokeWidth"] = createExportWrapper(\n      "FPDFPageObj_GetStrokeWidth",\n      2\n    );\n    Module["_FPDFPageObj_GetLineJoin"] = createExportWrapper(\n      "FPDFPageObj_GetLineJoin",\n      1\n    );\n    Module["_FPDFPageObj_SetLineJoin"] = createExportWrapper(\n      "FPDFPageObj_SetLineJoin",\n      2\n    );\n    Module["_FPDFPageObj_GetLineCap"] = createExportWrapper(\n      "FPDFPageObj_GetLineCap",\n      1\n    );\n    Module["_FPDFPageObj_SetLineCap"] = createExportWrapper(\n      "FPDFPageObj_SetLineCap",\n      2\n    );\n    Module["_FPDFPageObj_GetDashPhase"] = createExportWrapper(\n      "FPDFPageObj_GetDashPhase",\n      2\n    );\n    Module["_FPDFPageObj_SetDashPhase"] = createExportWrapper(\n      "FPDFPageObj_SetDashPhase",\n      2\n    );\n    Module["_FPDFPageObj_GetDashCount"] = createExportWrapper(\n      "FPDFPageObj_GetDashCount",\n      1\n    );\n    Module["_FPDFPageObj_GetDashArray"] = createExportWrapper(\n      "FPDFPageObj_GetDashArray",\n      3\n    );\n    Module["_FPDFPageObj_SetDashArray"] = createExportWrapper(\n      "FPDFPageObj_SetDashArray",\n      4\n    );\n    Module["_FPDFFormObj_CountObjects"] = createExportWrapper(\n      "FPDFFormObj_CountObjects",\n      1\n    );\n    Module["_FPDFFormObj_GetObject"] = createExportWrapper(\n      "FPDFFormObj_GetObject",\n      2\n    );\n    Module["_FPDFFormObj_RemoveObject"] = createExportWrapper(\n      "FPDFFormObj_RemoveObject",\n      2\n    );\n    Module["_FPDFPageObj_CreateNewPath"] = createExportWrapper(\n      "FPDFPageObj_CreateNewPath",\n      2\n    );\n    Module["_FPDFPageObj_CreateNewRect"] = createExportWrapper(\n      "FPDFPageObj_CreateNewRect",\n      4\n    );\n    Module["_FPDFPath_CountSegments"] = createExportWrapper(\n      "FPDFPath_CountSegments",\n      1\n    );\n    Module["_FPDFPath_GetPathSegment"] = createExportWrapper(\n      "FPDFPath_GetPathSegment",\n      2\n    );\n    Module["_FPDFPath_MoveTo"] = createExportWrapper("FPDFPath_MoveTo", 3);\n    Module["_FPDFPath_LineTo"] = createExportWrapper("FPDFPath_LineTo", 3);\n    Module["_FPDFPath_BezierTo"] = createExportWrapper(\n      "FPDFPath_BezierTo",\n      7\n    );\n    Module["_FPDFPath_Close"] = createExportWrapper("FPDFPath_Close", 1);\n    Module["_FPDFPath_SetDrawMode"] = createExportWrapper(\n      "FPDFPath_SetDrawMode",\n      3\n    );\n    Module["_FPDFPath_GetDrawMode"] = createExportWrapper(\n      "FPDFPath_GetDrawMode",\n      3\n    );\n    Module["_FPDFPathSegment_GetPoint"] = createExportWrapper(\n      "FPDFPathSegment_GetPoint",\n      3\n    );\n    Module["_FPDFPathSegment_GetType"] = createExportWrapper(\n      "FPDFPathSegment_GetType",\n      1\n    );\n    Module["_FPDFPathSegment_GetClose"] = createExportWrapper(\n      "FPDFPathSegment_GetClose",\n      1\n    );\n    Module["_FPDFPageObj_NewTextObj"] = createExportWrapper(\n      "FPDFPageObj_NewTextObj",\n      3\n    );\n    Module["_FPDFText_SetText"] = createExportWrapper(\n      "FPDFText_SetText",\n      2\n    );\n    Module["_FPDFText_SetCharcodes"] = createExportWrapper(\n      "FPDFText_SetCharcodes",\n      3\n    );\n    Module["_FPDFText_LoadFont"] = createExportWrapper(\n      "FPDFText_LoadFont",\n      5\n    );\n    Module["_FPDFText_LoadStandardFont"] = createExportWrapper(\n      "FPDFText_LoadStandardFont",\n      2\n    );\n    Module["_FPDFText_LoadCidType2Font"] = createExportWrapper(\n      "FPDFText_LoadCidType2Font",\n      6\n    );\n    Module["_FPDFTextObj_GetFontSize"] = createExportWrapper(\n      "FPDFTextObj_GetFontSize",\n      2\n    );\n    Module["_FPDFTextObj_GetText"] = createExportWrapper(\n      "FPDFTextObj_GetText",\n      4\n    );\n    Module["_FPDFTextObj_GetRenderedBitmap"] = createExportWrapper("FPDFTextObj_GetRenderedBitmap", 4);\n    Module["_FPDFFont_Close"] = createExportWrapper("FPDFFont_Close", 1);\n    Module["_FPDFPageObj_CreateTextObj"] = createExportWrapper(\n      "FPDFPageObj_CreateTextObj",\n      3\n    );\n    Module["_FPDFTextObj_GetTextRenderMode"] = createExportWrapper("FPDFTextObj_GetTextRenderMode", 1);\n    Module["_FPDFTextObj_SetTextRenderMode"] = createExportWrapper("FPDFTextObj_SetTextRenderMode", 2);\n    Module["_FPDFTextObj_GetFont"] = createExportWrapper(\n      "FPDFTextObj_GetFont",\n      1\n    );\n    Module["_FPDFFont_GetBaseFontName"] = createExportWrapper(\n      "FPDFFont_GetBaseFontName",\n      3\n    );\n    Module["_FPDFFont_GetFamilyName"] = createExportWrapper(\n      "FPDFFont_GetFamilyName",\n      3\n    );\n    Module["_FPDFFont_GetFontData"] = createExportWrapper(\n      "FPDFFont_GetFontData",\n      4\n    );\n    Module["_FPDFFont_GetIsEmbedded"] = createExportWrapper(\n      "FPDFFont_GetIsEmbedded",\n      1\n    );\n    Module["_FPDFFont_GetFlags"] = createExportWrapper(\n      "FPDFFont_GetFlags",\n      1\n    );\n    Module["_FPDFFont_GetWeight"] = createExportWrapper(\n      "FPDFFont_GetWeight",\n      1\n    );\n    Module["_FPDFFont_GetItalicAngle"] = createExportWrapper(\n      "FPDFFont_GetItalicAngle",\n      2\n    );\n    Module["_FPDFFont_GetAscent"] = createExportWrapper(\n      "FPDFFont_GetAscent",\n      3\n    );\n    Module["_FPDFFont_GetDescent"] = createExportWrapper(\n      "FPDFFont_GetDescent",\n      3\n    );\n    Module["_FPDFFont_GetGlyphWidth"] = createExportWrapper(\n      "FPDFFont_GetGlyphWidth",\n      4\n    );\n    Module["_FPDFFont_GetGlyphPath"] = createExportWrapper(\n      "FPDFFont_GetGlyphPath",\n      3\n    );\n    Module["_FPDFGlyphPath_CountGlyphSegments"] = createExportWrapper("FPDFGlyphPath_CountGlyphSegments", 1);\n    Module["_FPDFGlyphPath_GetGlyphPathSegment"] = createExportWrapper("FPDFGlyphPath_GetGlyphPathSegment", 2);\n    Module["_FPDFDoc_GetPageMode"] = createExportWrapper(\n      "FPDFDoc_GetPageMode",\n      1\n    );\n    Module["_FPDFPage_Flatten"] = createExportWrapper(\n      "FPDFPage_Flatten",\n      2\n    );\n    Module["_FPDFPage_HasFormFieldAtPoint"] = createExportWrapper("FPDFPage_HasFormFieldAtPoint", 4);\n    Module["_FPDFPage_FormFieldZOrderAtPoint"] = createExportWrapper("FPDFPage_FormFieldZOrderAtPoint", 4);\n    Module["_malloc"] = createExportWrapper("malloc", 1);\n    Module["_free"] = createExportWrapper("free", 1);\n    Module["_FORM_OnMouseMove"] = createExportWrapper(\n      "FORM_OnMouseMove",\n      5\n    );\n    Module["_FORM_OnMouseWheel"] = createExportWrapper(\n      "FORM_OnMouseWheel",\n      6\n    );\n    Module["_FORM_OnFocus"] = createExportWrapper("FORM_OnFocus", 5);\n    Module["_FORM_OnLButtonDown"] = createExportWrapper(\n      "FORM_OnLButtonDown",\n      5\n    );\n    Module["_FORM_OnLButtonUp"] = createExportWrapper(\n      "FORM_OnLButtonUp",\n      5\n    );\n    Module["_FORM_OnLButtonDoubleClick"] = createExportWrapper(\n      "FORM_OnLButtonDoubleClick",\n      5\n    );\n    Module["_FORM_OnRButtonDown"] = createExportWrapper(\n      "FORM_OnRButtonDown",\n      5\n    );\n    Module["_FORM_OnRButtonUp"] = createExportWrapper(\n      "FORM_OnRButtonUp",\n      5\n    );\n    Module["_FORM_OnKeyDown"] = createExportWrapper("FORM_OnKeyDown", 4);\n    Module["_FORM_OnKeyUp"] = createExportWrapper("FORM_OnKeyUp", 4);\n    Module["_FORM_OnChar"] = createExportWrapper("FORM_OnChar", 4);\n    Module["_FORM_GetFocusedText"] = createExportWrapper(\n      "FORM_GetFocusedText",\n      4\n    );\n    Module["_FORM_GetSelectedText"] = createExportWrapper(\n      "FORM_GetSelectedText",\n      4\n    );\n    Module["_FORM_ReplaceAndKeepSelection"] = createExportWrapper("FORM_ReplaceAndKeepSelection", 3);\n    Module["_FORM_ReplaceSelection"] = createExportWrapper(\n      "FORM_ReplaceSelection",\n      3\n    );\n    Module["_FORM_SelectAllText"] = createExportWrapper(\n      "FORM_SelectAllText",\n      2\n    );\n    Module["_FORM_CanUndo"] = createExportWrapper("FORM_CanUndo", 2);\n    Module["_FORM_CanRedo"] = createExportWrapper("FORM_CanRedo", 2);\n    Module["_FORM_Undo"] = createExportWrapper("FORM_Undo", 2);\n    Module["_FORM_Redo"] = createExportWrapper("FORM_Redo", 2);\n    Module["_FORM_ForceToKillFocus"] = createExportWrapper(\n      "FORM_ForceToKillFocus",\n      1\n    );\n    Module["_FORM_GetFocusedAnnot"] = createExportWrapper(\n      "FORM_GetFocusedAnnot",\n      3\n    );\n    Module["_FORM_SetFocusedAnnot"] = createExportWrapper(\n      "FORM_SetFocusedAnnot",\n      2\n    );\n    Module["_FPDF_FFLDraw"] = createExportWrapper("FPDF_FFLDraw", 9);\n    Module["_FPDF_SetFormFieldHighlightColor"] = createExportWrapper("FPDF_SetFormFieldHighlightColor", 3);\n    Module["_FPDF_SetFormFieldHighlightAlpha"] = createExportWrapper("FPDF_SetFormFieldHighlightAlpha", 2);\n    Module["_FPDF_RemoveFormFieldHighlight"] = createExportWrapper("FPDF_RemoveFormFieldHighlight", 1);\n    Module["_FORM_OnAfterLoadPage"] = createExportWrapper(\n      "FORM_OnAfterLoadPage",\n      2\n    );\n    Module["_FORM_OnBeforeClosePage"] = createExportWrapper(\n      "FORM_OnBeforeClosePage",\n      2\n    );\n    Module["_FORM_DoDocumentJSAction"] = createExportWrapper(\n      "FORM_DoDocumentJSAction",\n      1\n    );\n    Module["_FORM_DoDocumentOpenAction"] = createExportWrapper(\n      "FORM_DoDocumentOpenAction",\n      1\n    );\n    Module["_FORM_DoDocumentAAction"] = createExportWrapper(\n      "FORM_DoDocumentAAction",\n      2\n    );\n    Module["_FORM_DoPageAAction"] = createExportWrapper(\n      "FORM_DoPageAAction",\n      3\n    );\n    Module["_FORM_SetIndexSelected"] = createExportWrapper(\n      "FORM_SetIndexSelected",\n      4\n    );\n    Module["_FORM_IsIndexSelected"] = createExportWrapper(\n      "FORM_IsIndexSelected",\n      3\n    );\n    Module["_FPDFDoc_GetJavaScriptActionCount"] = createExportWrapper("FPDFDoc_GetJavaScriptActionCount", 1);\n    Module["_FPDFDoc_GetJavaScriptAction"] = createExportWrapper("FPDFDoc_GetJavaScriptAction", 2);\n    Module["_FPDFDoc_CloseJavaScriptAction"] = createExportWrapper("FPDFDoc_CloseJavaScriptAction", 1);\n    Module["_FPDFJavaScriptAction_GetName"] = createExportWrapper("FPDFJavaScriptAction_GetName", 3);\n    Module["_FPDFJavaScriptAction_GetScript"] = createExportWrapper("FPDFJavaScriptAction_GetScript", 3);\n    Module["_FPDF_ImportPagesByIndex"] = createExportWrapper(\n      "FPDF_ImportPagesByIndex",\n      5\n    );\n    Module["_FPDF_ImportPages"] = createExportWrapper(\n      "FPDF_ImportPages",\n      4\n    );\n    Module["_FPDF_ImportNPagesToOne"] = createExportWrapper(\n      "FPDF_ImportNPagesToOne",\n      5\n    );\n    Module["_FPDF_NewXObjectFromPage"] = createExportWrapper(\n      "FPDF_NewXObjectFromPage",\n      3\n    );\n    Module["_FPDF_CloseXObject"] = createExportWrapper(\n      "FPDF_CloseXObject",\n      1\n    );\n    Module["_FPDF_NewFormObjectFromXObject"] = createExportWrapper("FPDF_NewFormObjectFromXObject", 1);\n    Module["_FPDF_CopyViewerPreferences"] = createExportWrapper(\n      "FPDF_CopyViewerPreferences",\n      2\n    );\n    Module["_FPDF_RenderPageBitmapWithColorScheme_Start"] = createExportWrapper("FPDF_RenderPageBitmapWithColorScheme_Start", 10);\n    Module["_FPDF_RenderPageBitmap_Start"] = createExportWrapper("FPDF_RenderPageBitmap_Start", 9);\n    Module["_FPDF_RenderPage_Continue"] = createExportWrapper(\n      "FPDF_RenderPage_Continue",\n      2\n    );\n    Module["_FPDF_RenderPage_Close"] = createExportWrapper(\n      "FPDF_RenderPage_Close",\n      1\n    );\n    Module["_FPDF_SaveWithVersion"] = createExportWrapper(\n      "FPDF_SaveWithVersion",\n      4\n    );\n    Module["_FPDFText_GetCharIndexFromTextIndex"] = createExportWrapper("FPDFText_GetCharIndexFromTextIndex", 2);\n    Module["_FPDFText_GetTextIndexFromCharIndex"] = createExportWrapper("FPDFText_GetTextIndexFromCharIndex", 2);\n    Module["_FPDF_GetSignatureCount"] = createExportWrapper(\n      "FPDF_GetSignatureCount",\n      1\n    );\n    Module["_FPDF_GetSignatureObject"] = createExportWrapper(\n      "FPDF_GetSignatureObject",\n      2\n    );\n    Module["_FPDFSignatureObj_GetContents"] = createExportWrapper("FPDFSignatureObj_GetContents", 3);\n    Module["_FPDFSignatureObj_GetByteRange"] = createExportWrapper("FPDFSignatureObj_GetByteRange", 3);\n    Module["_FPDFSignatureObj_GetSubFilter"] = createExportWrapper("FPDFSignatureObj_GetSubFilter", 3);\n    Module["_FPDFSignatureObj_GetReason"] = createExportWrapper(\n      "FPDFSignatureObj_GetReason",\n      3\n    );\n    Module["_FPDFSignatureObj_GetTime"] = createExportWrapper(\n      "FPDFSignatureObj_GetTime",\n      3\n    );\n    Module["_FPDFSignatureObj_GetDocMDPPermission"] = createExportWrapper("FPDFSignatureObj_GetDocMDPPermission", 1);\n    Module["_FPDF_StructTree_GetForPage"] = createExportWrapper(\n      "FPDF_StructTree_GetForPage",\n      1\n    );\n    Module["_FPDF_StructTree_Close"] = createExportWrapper(\n      "FPDF_StructTree_Close",\n      1\n    );\n    Module["_FPDF_StructTree_CountChildren"] = createExportWrapper("FPDF_StructTree_CountChildren", 1);\n    Module["_FPDF_StructTree_GetChildAtIndex"] = createExportWrapper("FPDF_StructTree_GetChildAtIndex", 2);\n    Module["_FPDF_StructElement_GetAltText"] = createExportWrapper("FPDF_StructElement_GetAltText", 3);\n    Module["_FPDF_StructElement_GetActualText"] = createExportWrapper("FPDF_StructElement_GetActualText", 3);\n    Module["_FPDF_StructElement_GetID"] = createExportWrapper(\n      "FPDF_StructElement_GetID",\n      3\n    );\n    Module["_FPDF_StructElement_GetLang"] = createExportWrapper(\n      "FPDF_StructElement_GetLang",\n      3\n    );\n    Module["_FPDF_StructElement_GetAttributeCount"] = createExportWrapper("FPDF_StructElement_GetAttributeCount", 1);\n    Module["_FPDF_StructElement_GetAttributeAtIndex"] = createExportWrapper("FPDF_StructElement_GetAttributeAtIndex", 2);\n    Module["_FPDF_StructElement_GetStringAttribute"] = createExportWrapper("FPDF_StructElement_GetStringAttribute", 4);\n    Module["_FPDF_StructElement_GetMarkedContentID"] = createExportWrapper("FPDF_StructElement_GetMarkedContentID", 1);\n    Module["_FPDF_StructElement_GetType"] = createExportWrapper(\n      "FPDF_StructElement_GetType",\n      3\n    );\n    Module["_FPDF_StructElement_GetObjType"] = createExportWrapper("FPDF_StructElement_GetObjType", 3);\n    Module["_FPDF_StructElement_GetTitle"] = createExportWrapper("FPDF_StructElement_GetTitle", 3);\n    Module["_FPDF_StructElement_CountChildren"] = createExportWrapper("FPDF_StructElement_CountChildren", 1);\n    Module["_FPDF_StructElement_GetChildAtIndex"] = createExportWrapper("FPDF_StructElement_GetChildAtIndex", 2);\n    Module["_FPDF_StructElement_GetChildMarkedContentID"] = createExportWrapper("FPDF_StructElement_GetChildMarkedContentID", 2);\n    Module["_FPDF_StructElement_GetParent"] = createExportWrapper("FPDF_StructElement_GetParent", 1);\n    Module["_FPDF_StructElement_Attr_GetCount"] = createExportWrapper("FPDF_StructElement_Attr_GetCount", 1);\n    Module["_FPDF_StructElement_Attr_GetName"] = createExportWrapper("FPDF_StructElement_Attr_GetName", 5);\n    Module["_FPDF_StructElement_Attr_GetValue"] = createExportWrapper("FPDF_StructElement_Attr_GetValue", 2);\n    Module["_FPDF_StructElement_Attr_GetType"] = createExportWrapper("FPDF_StructElement_Attr_GetType", 1);\n    Module["_FPDF_StructElement_Attr_GetBooleanValue"] = createExportWrapper("FPDF_StructElement_Attr_GetBooleanValue", 2);\n    Module["_FPDF_StructElement_Attr_GetNumberValue"] = createExportWrapper("FPDF_StructElement_Attr_GetNumberValue", 2);\n    Module["_FPDF_StructElement_Attr_GetStringValue"] = createExportWrapper("FPDF_StructElement_Attr_GetStringValue", 4);\n    Module["_FPDF_StructElement_Attr_GetBlobValue"] = createExportWrapper("FPDF_StructElement_Attr_GetBlobValue", 4);\n    Module["_FPDF_StructElement_Attr_CountChildren"] = createExportWrapper("FPDF_StructElement_Attr_CountChildren", 1);\n    Module["_FPDF_StructElement_Attr_GetChildAtIndex"] = createExportWrapper("FPDF_StructElement_Attr_GetChildAtIndex", 2);\n    Module["_FPDF_StructElement_GetMarkedContentIdCount"] = createExportWrapper("FPDF_StructElement_GetMarkedContentIdCount", 1);\n    Module["_FPDF_StructElement_GetMarkedContentIdAtIndex"] = createExportWrapper("FPDF_StructElement_GetMarkedContentIdAtIndex", 2);\n    Module["_FPDF_AddInstalledFont"] = createExportWrapper(\n      "FPDF_AddInstalledFont",\n      3\n    );\n    Module["_FPDF_SetSystemFontInfo"] = createExportWrapper(\n      "FPDF_SetSystemFontInfo",\n      1\n    );\n    Module["_FPDF_GetDefaultTTFMap"] = createExportWrapper(\n      "FPDF_GetDefaultTTFMap",\n      0\n    );\n    Module["_FPDF_GetDefaultTTFMapCount"] = createExportWrapper(\n      "FPDF_GetDefaultTTFMapCount",\n      0\n    );\n    Module["_FPDF_GetDefaultTTFMapEntry"] = createExportWrapper(\n      "FPDF_GetDefaultTTFMapEntry",\n      1\n    );\n    Module["_FPDF_GetDefaultSystemFontInfo"] = createExportWrapper("FPDF_GetDefaultSystemFontInfo", 0);\n    Module["_FPDF_FreeDefaultSystemFontInfo"] = createExportWrapper("FPDF_FreeDefaultSystemFontInfo", 1);\n    Module["_FPDFText_LoadPage"] = createExportWrapper(\n      "FPDFText_LoadPage",\n      1\n    );\n    Module["_FPDFText_ClosePage"] = createExportWrapper(\n      "FPDFText_ClosePage",\n      1\n    );\n    Module["_FPDFText_CountChars"] = createExportWrapper(\n      "FPDFText_CountChars",\n      1\n    );\n    Module["_FPDFText_GetUnicode"] = createExportWrapper(\n      "FPDFText_GetUnicode",\n      2\n    );\n    Module["_FPDFText_GetTextObject"] = createExportWrapper(\n      "FPDFText_GetTextObject",\n      2\n    );\n    Module["_FPDFText_IsGenerated"] = createExportWrapper(\n      "FPDFText_IsGenerated",\n      2\n    );\n    Module["_FPDFText_IsHyphen"] = createExportWrapper(\n      "FPDFText_IsHyphen",\n      2\n    );\n    Module["_FPDFText_HasUnicodeMapError"] = createExportWrapper("FPDFText_HasUnicodeMapError", 2);\n    Module["_FPDFText_GetFontSize"] = createExportWrapper(\n      "FPDFText_GetFontSize",\n      2\n    );\n    Module["_FPDFText_GetFontInfo"] = createExportWrapper(\n      "FPDFText_GetFontInfo",\n      5\n    );\n    Module["_FPDFText_GetFontWeight"] = createExportWrapper(\n      "FPDFText_GetFontWeight",\n      2\n    );\n    Module["_FPDFText_GetFillColor"] = createExportWrapper(\n      "FPDFText_GetFillColor",\n      6\n    );\n    Module["_FPDFText_GetStrokeColor"] = createExportWrapper(\n      "FPDFText_GetStrokeColor",\n      6\n    );\n    Module["_FPDFText_GetCharAngle"] = createExportWrapper(\n      "FPDFText_GetCharAngle",\n      2\n    );\n    Module["_FPDFText_GetCharBox"] = createExportWrapper(\n      "FPDFText_GetCharBox",\n      6\n    );\n    Module["_FPDFText_GetLooseCharBox"] = createExportWrapper(\n      "FPDFText_GetLooseCharBox",\n      3\n    );\n    Module["_FPDFText_GetMatrix"] = createExportWrapper(\n      "FPDFText_GetMatrix",\n      3\n    );\n    Module["_FPDFText_GetCharOrigin"] = createExportWrapper(\n      "FPDFText_GetCharOrigin",\n      4\n    );\n    Module["_FPDFText_GetCharIndexAtPos"] = createExportWrapper(\n      "FPDFText_GetCharIndexAtPos",\n      5\n    );\n    Module["_FPDFText_GetText"] = createExportWrapper(\n      "FPDFText_GetText",\n      4\n    );\n    Module["_FPDFText_CountRects"] = createExportWrapper(\n      "FPDFText_CountRects",\n      3\n    );\n    Module["_FPDFText_GetRect"] = createExportWrapper(\n      "FPDFText_GetRect",\n      6\n    );\n    Module["_FPDFText_GetBoundedText"] = createExportWrapper(\n      "FPDFText_GetBoundedText",\n      7\n    );\n    Module["_FPDFText_FindStart"] = createExportWrapper(\n      "FPDFText_FindStart",\n      4\n    );\n    Module["_FPDFText_FindNext"] = createExportWrapper(\n      "FPDFText_FindNext",\n      1\n    );\n    Module["_FPDFText_FindPrev"] = createExportWrapper(\n      "FPDFText_FindPrev",\n      1\n    );\n    Module["_FPDFText_GetSchResultIndex"] = createExportWrapper(\n      "FPDFText_GetSchResultIndex",\n      1\n    );\n    Module["_FPDFText_GetSchCount"] = createExportWrapper(\n      "FPDFText_GetSchCount",\n      1\n    );\n    Module["_FPDFText_FindClose"] = createExportWrapper(\n      "FPDFText_FindClose",\n      1\n    );\n    Module["_FPDFLink_LoadWebLinks"] = createExportWrapper(\n      "FPDFLink_LoadWebLinks",\n      1\n    );\n    Module["_FPDFLink_CountWebLinks"] = createExportWrapper(\n      "FPDFLink_CountWebLinks",\n      1\n    );\n    Module["_FPDFLink_GetURL"] = createExportWrapper("FPDFLink_GetURL", 4);\n    Module["_FPDFLink_CountRects"] = createExportWrapper(\n      "FPDFLink_CountRects",\n      2\n    );\n    Module["_FPDFLink_GetRect"] = createExportWrapper(\n      "FPDFLink_GetRect",\n      7\n    );\n    Module["_FPDFLink_GetTextRange"] = createExportWrapper(\n      "FPDFLink_GetTextRange",\n      4\n    );\n    Module["_FPDFLink_CloseWebLinks"] = createExportWrapper(\n      "FPDFLink_CloseWebLinks",\n      1\n    );\n    Module["_FPDFPage_GetDecodedThumbnailData"] = createExportWrapper("FPDFPage_GetDecodedThumbnailData", 3);\n    Module["_FPDFPage_GetRawThumbnailData"] = createExportWrapper("FPDFPage_GetRawThumbnailData", 3);\n    Module["_FPDFPage_GetThumbnailAsBitmap"] = createExportWrapper("FPDFPage_GetThumbnailAsBitmap", 1);\n    Module["_FPDFPage_SetMediaBox"] = createExportWrapper(\n      "FPDFPage_SetMediaBox",\n      5\n    );\n    Module["_FPDFPage_SetCropBox"] = createExportWrapper(\n      "FPDFPage_SetCropBox",\n      5\n    );\n    Module["_FPDFPage_SetBleedBox"] = createExportWrapper(\n      "FPDFPage_SetBleedBox",\n      5\n    );\n    Module["_FPDFPage_SetTrimBox"] = createExportWrapper(\n      "FPDFPage_SetTrimBox",\n      5\n    );\n    Module["_FPDFPage_SetArtBox"] = createExportWrapper(\n      "FPDFPage_SetArtBox",\n      5\n    );\n    Module["_FPDFPage_GetMediaBox"] = createExportWrapper(\n      "FPDFPage_GetMediaBox",\n      5\n    );\n    Module["_FPDFPage_GetCropBox"] = createExportWrapper(\n      "FPDFPage_GetCropBox",\n      5\n    );\n    Module["_FPDFPage_GetBleedBox"] = createExportWrapper(\n      "FPDFPage_GetBleedBox",\n      5\n    );\n    Module["_FPDFPage_GetTrimBox"] = createExportWrapper(\n      "FPDFPage_GetTrimBox",\n      5\n    );\n    Module["_FPDFPage_GetArtBox"] = createExportWrapper(\n      "FPDFPage_GetArtBox",\n      5\n    );\n    Module["_FPDFPage_TransFormWithClip"] = createExportWrapper(\n      "FPDFPage_TransFormWithClip",\n      3\n    );\n    Module["_FPDFPageObj_TransformClipPath"] = createExportWrapper("FPDFPageObj_TransformClipPath", 7);\n    Module["_FPDFPageObj_GetClipPath"] = createExportWrapper(\n      "FPDFPageObj_GetClipPath",\n      1\n    );\n    Module["_FPDFClipPath_CountPaths"] = createExportWrapper(\n      "FPDFClipPath_CountPaths",\n      1\n    );\n    Module["_FPDFClipPath_CountPathSegments"] = createExportWrapper("FPDFClipPath_CountPathSegments", 2);\n    Module["_FPDFClipPath_GetPathSegment"] = createExportWrapper("FPDFClipPath_GetPathSegment", 3);\n    Module["_FPDF_CreateClipPath"] = createExportWrapper(\n      "FPDF_CreateClipPath",\n      4\n    );\n    Module["_FPDF_DestroyClipPath"] = createExportWrapper(\n      "FPDF_DestroyClipPath",\n      1\n    );\n    Module["_FPDFPage_InsertClipPath"] = createExportWrapper(\n      "FPDFPage_InsertClipPath",\n      2\n    );\n    Module["_FPDF_InitLibrary"] = createExportWrapper(\n      "FPDF_InitLibrary",\n      0\n    );\n    Module["_FPDF_DestroyLibrary"] = createExportWrapper(\n      "FPDF_DestroyLibrary",\n      0\n    );\n    Module["_FPDF_SetSandBoxPolicy"] = createExportWrapper(\n      "FPDF_SetSandBoxPolicy",\n      2\n    );\n    Module["_FPDF_LoadDocument"] = createExportWrapper(\n      "FPDF_LoadDocument",\n      2\n    );\n    Module["_FPDF_GetFormType"] = createExportWrapper(\n      "FPDF_GetFormType",\n      1\n    );\n    Module["_FPDF_LoadXFA"] = createExportWrapper("FPDF_LoadXFA", 1);\n    Module["_FPDF_LoadMemDocument"] = createExportWrapper(\n      "FPDF_LoadMemDocument",\n      3\n    );\n    Module["_FPDF_LoadMemDocument64"] = createExportWrapper(\n      "FPDF_LoadMemDocument64",\n      3\n    );\n    Module["_FPDF_LoadCustomDocument"] = createExportWrapper(\n      "FPDF_LoadCustomDocument",\n      2\n    );\n    Module["_FPDF_GetFileVersion"] = createExportWrapper(\n      "FPDF_GetFileVersion",\n      2\n    );\n    Module["_FPDF_DocumentHasValidCrossReferenceTable"] = createExportWrapper("FPDF_DocumentHasValidCrossReferenceTable", 1);\n    Module["_FPDF_GetDocPermissions"] = createExportWrapper(\n      "FPDF_GetDocPermissions",\n      1\n    );\n    Module["_FPDF_GetDocUserPermissions"] = createExportWrapper(\n      "FPDF_GetDocUserPermissions",\n      1\n    );\n    Module["_FPDF_GetSecurityHandlerRevision"] = createExportWrapper("FPDF_GetSecurityHandlerRevision", 1);\n    Module["_FPDF_GetPageCount"] = createExportWrapper(\n      "FPDF_GetPageCount",\n      1\n    );\n    Module["_FPDF_LoadPage"] = createExportWrapper("FPDF_LoadPage", 2);\n    Module["_FPDF_GetPageWidthF"] = createExportWrapper(\n      "FPDF_GetPageWidthF",\n      1\n    );\n    Module["_FPDF_GetPageWidth"] = createExportWrapper(\n      "FPDF_GetPageWidth",\n      1\n    );\n    Module["_FPDF_GetPageHeightF"] = createExportWrapper(\n      "FPDF_GetPageHeightF",\n      1\n    );\n    Module["_FPDF_GetPageHeight"] = createExportWrapper(\n      "FPDF_GetPageHeight",\n      1\n    );\n    Module["_FPDF_GetPageBoundingBox"] = createExportWrapper(\n      "FPDF_GetPageBoundingBox",\n      2\n    );\n    Module["_FPDF_RenderPageBitmap"] = createExportWrapper(\n      "FPDF_RenderPageBitmap",\n      8\n    );\n    Module["_FPDF_RenderPageBitmapWithMatrix"] = createExportWrapper("FPDF_RenderPageBitmapWithMatrix", 5);\n    Module["_EPDF_RenderAnnotBitmap"] = createExportWrapper(\n      "EPDF_RenderAnnotBitmap",\n      6\n    );\n    Module["_FPDF_ClosePage"] = createExportWrapper("FPDF_ClosePage", 1);\n    Module["_FPDF_CloseDocument"] = createExportWrapper(\n      "FPDF_CloseDocument",\n      1\n    );\n    Module["_FPDF_GetLastError"] = createExportWrapper(\n      "FPDF_GetLastError",\n      0\n    );\n    Module["_FPDF_DeviceToPage"] = createExportWrapper(\n      "FPDF_DeviceToPage",\n      10\n    );\n    Module["_FPDF_PageToDevice"] = createExportWrapper(\n      "FPDF_PageToDevice",\n      10\n    );\n    Module["_FPDFBitmap_Create"] = createExportWrapper(\n      "FPDFBitmap_Create",\n      3\n    );\n    Module["_FPDFBitmap_CreateEx"] = createExportWrapper(\n      "FPDFBitmap_CreateEx",\n      5\n    );\n    Module["_FPDFBitmap_GetFormat"] = createExportWrapper(\n      "FPDFBitmap_GetFormat",\n      1\n    );\n    Module["_FPDFBitmap_FillRect"] = createExportWrapper(\n      "FPDFBitmap_FillRect",\n      6\n    );\n    Module["_FPDFBitmap_GetBuffer"] = createExportWrapper(\n      "FPDFBitmap_GetBuffer",\n      1\n    );\n    Module["_FPDFBitmap_GetWidth"] = createExportWrapper(\n      "FPDFBitmap_GetWidth",\n      1\n    );\n    Module["_FPDFBitmap_GetHeight"] = createExportWrapper(\n      "FPDFBitmap_GetHeight",\n      1\n    );\n    Module["_FPDFBitmap_GetStride"] = createExportWrapper(\n      "FPDFBitmap_GetStride",\n      1\n    );\n    Module["_FPDFBitmap_Destroy"] = createExportWrapper(\n      "FPDFBitmap_Destroy",\n      1\n    );\n    Module["_FPDF_GetPageSizeByIndexF"] = createExportWrapper(\n      "FPDF_GetPageSizeByIndexF",\n      3\n    );\n    Module["_FPDF_GetPageSizeByIndex"] = createExportWrapper(\n      "FPDF_GetPageSizeByIndex",\n      4\n    );\n    Module["_FPDF_VIEWERREF_GetPrintScaling"] = createExportWrapper("FPDF_VIEWERREF_GetPrintScaling", 1);\n    Module["_FPDF_VIEWERREF_GetNumCopies"] = createExportWrapper("FPDF_VIEWERREF_GetNumCopies", 1);\n    Module["_FPDF_VIEWERREF_GetPrintPageRange"] = createExportWrapper("FPDF_VIEWERREF_GetPrintPageRange", 1);\n    Module["_FPDF_VIEWERREF_GetPrintPageRangeCount"] = createExportWrapper("FPDF_VIEWERREF_GetPrintPageRangeCount", 1);\n    Module["_FPDF_VIEWERREF_GetPrintPageRangeElement"] = createExportWrapper("FPDF_VIEWERREF_GetPrintPageRangeElement", 2);\n    Module["_FPDF_VIEWERREF_GetDuplex"] = createExportWrapper(\n      "FPDF_VIEWERREF_GetDuplex",\n      1\n    );\n    Module["_FPDF_VIEWERREF_GetName"] = createExportWrapper(\n      "FPDF_VIEWERREF_GetName",\n      4\n    );\n    Module["_FPDF_CountNamedDests"] = createExportWrapper(\n      "FPDF_CountNamedDests",\n      1\n    );\n    Module["_FPDF_GetNamedDestByName"] = createExportWrapper(\n      "FPDF_GetNamedDestByName",\n      2\n    );\n    Module["_FPDF_GetNamedDest"] = createExportWrapper(\n      "FPDF_GetNamedDest",\n      4\n    );\n    Module["_FPDF_GetXFAPacketCount"] = createExportWrapper(\n      "FPDF_GetXFAPacketCount",\n      1\n    );\n    Module["_FPDF_GetXFAPacketName"] = createExportWrapper(\n      "FPDF_GetXFAPacketName",\n      4\n    );\n    Module["_FPDF_GetXFAPacketContent"] = createExportWrapper(\n      "FPDF_GetXFAPacketContent",\n      5\n    );\n    Module["_FPDF_GetTrailerEnds"] = createExportWrapper(\n      "FPDF_GetTrailerEnds",\n      3\n    );\n    var _fflush = createExportWrapper("fflush", 1);\n    var _emscripten_builtin_memalign = createExportWrapper("emscripten_builtin_memalign", 2);\n    var _strerror = createExportWrapper("strerror", 1);\n    var _setThrew = createExportWrapper("setThrew", 2);\n    var _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports["emscripten_stack_init"])();\n    var _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])();\n    var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["_emscripten_stack_restore"])(a0);\n    var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"])(a0);\n    var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();\n    Module["dynCall_ji"] = createExportWrapper("dynCall_ji", 2);\n    Module["dynCall_jij"] = createExportWrapper("dynCall_jij", 4);\n    Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij", 5);\n    Module["dynCall_iij"] = createExportWrapper("dynCall_iij", 4);\n    Module["dynCall_j"] = createExportWrapper("dynCall_j", 1);\n    Module["dynCall_jji"] = createExportWrapper("dynCall_jji", 4);\n    Module["dynCall_iji"] = createExportWrapper("dynCall_iji", 4);\n    Module["dynCall_viijii"] = createExportWrapper("dynCall_viijii", 7);\n    Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji", 5);\n    Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji", 5);\n    Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij", 7);\n    Module["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj", 9);\n    Module["dynCall_iiiiiijj"] = createExportWrapper(\n      "dynCall_iiiiiijj",\n      10\n    );\n    Module["dynCall_viji"] = createExportWrapper("dynCall_viji", 5);\n    function invoke_viii(index, a1, a2, a3) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_ii(index, a1) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_iii(index, a1, a2) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_iiii(index, a1, a2, a3) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_viiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_iiiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    function invoke_v(index) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)();\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n    Module["wasmExports"] = wasmExports;\n    Module["ccall"] = ccall;\n    Module["cwrap"] = cwrap;\n    Module["addFunction"] = addFunction;\n    Module["removeFunction"] = removeFunction;\n    Module["setValue"] = setValue;\n    Module["getValue"] = getValue;\n    Module["UTF8ToString"] = UTF8ToString;\n    Module["stringToUTF8"] = stringToUTF8;\n    Module["UTF16ToString"] = UTF16ToString;\n    Module["stringToUTF16"] = stringToUTF16;\n    var missingLibrarySymbols = [\n      "writeI53ToI64",\n      "writeI53ToI64Clamped",\n      "writeI53ToI64Signaling",\n      "writeI53ToU64Clamped",\n      "writeI53ToU64Signaling",\n      "readI53FromI64",\n      "readI53FromU64",\n      "convertI32PairToI53",\n      "convertU32PairToI53",\n      "getTempRet0",\n      "setTempRet0",\n      "exitJS",\n      "inetPton4",\n      "inetNtop4",\n      "inetPton6",\n      "inetNtop6",\n      "readSockaddr",\n      "writeSockaddr",\n      "emscriptenLog",\n      "readEmAsmArgs",\n      "jstoi_q",\n      "listenOnce",\n      "autoResumeAudioContext",\n      "dynCallLegacy",\n      "getDynCaller",\n      "dynCall",\n      "handleException",\n      "keepRuntimeAlive",\n      "runtimeKeepalivePush",\n      "runtimeKeepalivePop",\n      "callUserCallback",\n      "maybeExit",\n      "asmjsMangle",\n      "HandleAllocator",\n      "getNativeTypeSize",\n      "STACK_SIZE",\n      "STACK_ALIGN",\n      "POINTER_SIZE",\n      "ASSERTIONS",\n      "reallyNegative",\n      "unSign",\n      "strLen",\n      "reSign",\n      "formatString",\n      "intArrayToString",\n      "AsciiToString",\n      "lengthBytesUTF16",\n      "UTF32ToString",\n      "stringToUTF32",\n      "lengthBytesUTF32",\n      "stringToNewUTF8",\n      "registerKeyEventCallback",\n      "maybeCStringToJsString",\n      "findEventTarget",\n      "getBoundingClientRect",\n      "fillMouseEventData",\n      "registerMouseEventCallback",\n      "registerWheelEventCallback",\n      "registerUiEventCallback",\n      "registerFocusEventCallback",\n      "fillDeviceOrientationEventData",\n      "registerDeviceOrientationEventCallback",\n      "fillDeviceMotionEventData",\n      "registerDeviceMotionEventCallback",\n      "screenOrientation",\n      "fillOrientationChangeEventData",\n      "registerOrientationChangeEventCallback",\n      "fillFullscreenChangeEventData",\n      "registerFullscreenChangeEventCallback",\n      "JSEvents_requestFullscreen",\n      "JSEvents_resizeCanvasForFullscreen",\n      "registerRestoreOldStyle",\n      "hideEverythingExceptGivenElement",\n      "restoreHiddenElements",\n      "setLetterbox",\n      "softFullscreenResizeWebGLRenderTarget",\n      "doRequestFullscreen",\n      "fillPointerlockChangeEventData",\n      "registerPointerlockChangeEventCallback",\n      "registerPointerlockErrorEventCallback",\n      "requestPointerLock",\n      "fillVisibilityChangeEventData",\n      "registerVisibilityChangeEventCallback",\n      "registerTouchEventCallback",\n      "fillGamepadEventData",\n      "registerGamepadEventCallback",\n      "registerBeforeUnloadEventCallback",\n      "fillBatteryEventData",\n      "battery",\n      "registerBatteryEventCallback",\n      "setCanvasElementSize",\n      "getCanvasElementSize",\n      "jsStackTrace",\n      "getCallstack",\n      "convertPCtoSourceLocation",\n      "checkWasiClock",\n      "wasiRightsToMuslOFlags",\n      "wasiOFlagsToMuslOFlags",\n      "createDyncallWrapper",\n      "safeSetTimeout",\n      "setImmediateWrapped",\n      "clearImmediateWrapped",\n      "polyfillSetImmediate",\n      "registerPostMainLoop",\n      "registerPreMainLoop",\n      "getPromise",\n      "makePromise",\n      "idsToPromises",\n      "makePromiseCallback",\n      "ExceptionInfo",\n      "findMatchingCatch",\n      "Browser_asyncPrepareDataCounter",\n      "safeRequestAnimationFrame",\n      "arraySum",\n      "addDays",\n      "getSocketFromFD",\n      "getSocketAddress",\n      "FS_unlink",\n      "FS_mkdirTree",\n      "_setNetworkCallback",\n      "heapObjectForWebGLType",\n      "toTypedArrayIndex",\n      "webgl_enable_ANGLE_instanced_arrays",\n      "webgl_enable_OES_vertex_array_object",\n      "webgl_enable_WEBGL_draw_buffers",\n      "webgl_enable_WEBGL_multi_draw",\n      "webgl_enable_EXT_polygon_offset_clamp",\n      "webgl_enable_EXT_clip_control",\n      "webgl_enable_WEBGL_polygon_mode",\n      "emscriptenWebGLGet",\n      "computeUnpackAlignedImageSize",\n      "colorChannelsInGlTextureFormat",\n      "emscriptenWebGLGetTexPixelData",\n      "emscriptenWebGLGetUniform",\n      "webglGetUniformLocation",\n      "webglPrepareUniformLocationsBeforeFirstUse",\n      "webglGetLeftBracePos",\n      "emscriptenWebGLGetVertexAttrib",\n      "__glGetActiveAttribOrUniform",\n      "writeGLArray",\n      "registerWebGlEventCallback",\n      "runAndAbortIfError",\n      "ALLOC_NORMAL",\n      "ALLOC_STACK",\n      "allocate",\n      "writeStringToMemory",\n      "writeAsciiToMemory",\n      "setErrNo",\n      "demangle",\n      "stackTrace"\n    ];\n    missingLibrarySymbols.forEach(missingLibrarySymbol);\n    var unexportedSymbols = [\n      "run",\n      "addOnPreRun",\n      "addOnInit",\n      "addOnPreMain",\n      "addOnExit",\n      "addOnPostRun",\n      "addRunDependency",\n      "removeRunDependency",\n      "out",\n      "err",\n      "callMain",\n      "abort",\n      "wasmMemory",\n      "writeStackCookie",\n      "checkStackCookie",\n      "convertI32PairToI53Checked",\n      "stackSave",\n      "stackRestore",\n      "stackAlloc",\n      "ptrToString",\n      "zeroMemory",\n      "getHeapMax",\n      "growMemory",\n      "ENV",\n      "ERRNO_CODES",\n      "strError",\n      "DNS",\n      "Protocols",\n      "Sockets",\n      "initRandomFill",\n      "randomFill",\n      "timers",\n      "warnOnce",\n      "readEmAsmArgsArray",\n      "jstoi_s",\n      "getExecutableName",\n      "asyncLoad",\n      "alignMemory",\n      "mmapAlloc",\n      "wasmTable",\n      "noExitRuntime",\n      "getCFunc",\n      "uleb128Encode",\n      "sigToWasmTypes",\n      "generateFuncType",\n      "convertJsFunctionToWasm",\n      "freeTableIndexes",\n      "functionsInTableMap",\n      "getEmptyTableSlot",\n      "updateTableMap",\n      "getFunctionAddress",\n      "PATH",\n      "PATH_FS",\n      "UTF8Decoder",\n      "UTF8ArrayToString",\n      "stringToUTF8Array",\n      "lengthBytesUTF8",\n      "intArrayFromString",\n      "stringToAscii",\n      "UTF16Decoder",\n      "stringToUTF8OnStack",\n      "writeArrayToMemory",\n      "JSEvents",\n      "specialHTMLTargets",\n      "findCanvasEventTarget",\n      "currentFullscreenStrategy",\n      "restoreOldWindowedStyle",\n      "UNWIND_CACHE",\n      "ExitStatus",\n      "getEnvStrings",\n      "doReadv",\n      "doWritev",\n      "promiseMap",\n      "uncaughtExceptionCount",\n      "exceptionLast",\n      "exceptionCaught",\n      "Browser",\n      "getPreloadedImageData__data",\n      "wget",\n      "MONTH_DAYS_REGULAR",\n      "MONTH_DAYS_LEAP",\n      "MONTH_DAYS_REGULAR_CUMULATIVE",\n      "MONTH_DAYS_LEAP_CUMULATIVE",\n      "isLeapYear",\n      "ydayFromDate",\n      "SYSCALLS",\n      "preloadPlugins",\n      "FS_createPreloadedFile",\n      "FS_modeStringToFlags",\n      "FS_getMode",\n      "FS_stdin_getChar_buffer",\n      "FS_stdin_getChar",\n      "FS_createPath",\n      "FS_createDevice",\n      "FS_readFile",\n      "FS",\n      "FS_createDataFile",\n      "FS_createLazyFile",\n      "MEMFS",\n      "TTY",\n      "PIPEFS",\n      "SOCKFS",\n      "tempFixedLengthArray",\n      "miniTempWebGLFloatBuffers",\n      "miniTempWebGLIntBuffers",\n      "GL",\n      "AL",\n      "GLUT",\n      "EGL",\n      "GLEW",\n      "IDBStore",\n      "SDL",\n      "SDL_gfx",\n      "allocateUTF8",\n      "allocateUTF8OnStack",\n      "print",\n      "printErr"\n    ];\n    unexportedSymbols.forEach(unexportedRuntimeSymbol);\n    var calledRun;\n    var calledPrerun;\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function stackCheckInit() {\n      _emscripten_stack_init();\n      writeStackCookie();\n    }\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n      stackCheckInit();\n      if (!calledPrerun) {\n        calledPrerun = 1;\n        preRun();\n        if (runDependencies > 0) {\n          return;\n        }\n      }\n      function doRun() {\n        var _a;\n        if (calledRun) return;\n        calledRun = 1;\n        Module["calledRun"] = 1;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        (_a = Module["onRuntimeInitialized"]) == null ? void 0 : _a.call(Module);\n        assert(\n          !Module["_main"],\n          \'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]\'\n        );\n        postRun();\n      }\n      if (Module["setStatus"]) {\n        Module["setStatus"]("Running...");\n        setTimeout(() => {\n          setTimeout(() => Module["setStatus"](""), 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n      checkStackCookie();\n    }\n    if (Module["preInit"]) {\n      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];\n      while (Module["preInit"].length > 0) {\n        Module["preInit"].pop()();\n      }\n    }\n    run();\n    moduleRtn = readyPromise;\n    for (const prop of Object.keys(Module)) {\n      if (!(prop in moduleArg)) {\n        Object.defineProperty(moduleArg, prop, {\n          configurable: true,\n          get() {\n            abort(\n              `Access to module property (\'${prop}\') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`\n            );\n          }\n        });\n      }\n    }\n    return moduleRtn;\n  };\n})();\nconst functions = {\n  EPDF_RenderAnnotBitmap: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_ClearColor: [["number", "number"], "boolean"],\n  EPDFAnnot_GenerateAppearance: [["number"], "boolean"],\n  EPDFAnnot_GenerateAppearanceWithBlend: [["number", "number"], "boolean"],\n  EPDFAnnot_GetBlendMode: [["number"], "number"],\n  EPDFAnnot_GetBorderDashPattern: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_GetBorderDashPatternCount: [["number"], "number"],\n  EPDFAnnot_GetBorderEffect: [["number", "number"], "boolean"],\n  EPDFAnnot_GetBorderStyle: [["number", "number"], "number"],\n  EPDFAnnot_GetColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_GetDefaultAppearance: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_GetIcon: [["number"], "number"],\n  EPDFAnnot_GetIntent: [["number", "number", "number"], "number"],\n  EPDFAnnot_GetLineEndings: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_GetOpacity: [["number", "number"], "boolean"],\n  EPDFAnnot_GetRectangleDifferences: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_GetRichContent: [["number", "number", "number"], "number"],\n  EPDFAnnot_GetTextAlignment: [["number"], "number"],\n  EPDFAnnot_GetVerticalAlignment: [["number"], "number"],\n  EPDFAnnot_SetBorderDashPattern: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetBorderStyle: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_SetDefaultAppearance: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  EPDFAnnot_SetIcon: [["number", "number"], "boolean"],\n  EPDFAnnot_SetIntent: [["number", "string"], "boolean"],\n  EPDFAnnot_SetLine: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetLineEndings: [["number", "number", "number"], "boolean"],\n  EPDFAnnot_SetLinkedAnnot: [["number", "string", "number"], "boolean"],\n  EPDFAnnot_SetOpacity: [["number", "number"], "boolean"],\n  EPDFAnnot_SetTextAlignment: [["number", "number"], "boolean"],\n  EPDFAnnot_SetVerticalAlignment: [["number", "number"], "boolean"],\n  EPDFAnnot_SetVertices: [["number", "number", "number"], "boolean"],\n  EPDFPage_CreateAnnot: [["number", "number"], "number"],\n  EPDFPage_GetAnnotByName: [["number", "number"], "number"],\n  EPDFPage_GetAnnotCountRaw: [["number", "number"], "number"],\n  EPDFPage_GetAnnotRaw: [["number", "number", "number"], "number"],\n  EPDFPage_RemoveAnnotByName: [["number", "number"], "boolean"],\n  FORM_CanRedo: [["number", "number"], "boolean"],\n  FORM_CanUndo: [["number", "number"], "boolean"],\n  FORM_DoDocumentAAction: [["number", "number"], null],\n  FORM_DoDocumentJSAction: [["number"], null],\n  FORM_DoDocumentOpenAction: [["number"], null],\n  FORM_DoPageAAction: [["number", "number", "number"], null],\n  FORM_ForceToKillFocus: [["number"], "boolean"],\n  FORM_GetFocusedAnnot: [["number", "number", "number"], "boolean"],\n  FORM_GetFocusedText: [["number", "number", "number", "number"], "number"],\n  FORM_GetSelectedText: [["number", "number", "number", "number"], "number"],\n  FORM_IsIndexSelected: [["number", "number", "number"], "boolean"],\n  FORM_OnAfterLoadPage: [["number", "number"], null],\n  FORM_OnBeforeClosePage: [["number", "number"], null],\n  FORM_OnChar: [["number", "number", "number", "number"], "boolean"],\n  FORM_OnFocus: [["number", "number", "number", "number", "number"], "boolean"],\n  FORM_OnKeyDown: [["number", "number", "number", "number"], "boolean"],\n  FORM_OnKeyUp: [["number", "number", "number", "number"], "boolean"],\n  FORM_OnLButtonDoubleClick: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnLButtonDown: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnLButtonUp: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnMouseMove: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnMouseWheel: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnRButtonDown: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_OnRButtonUp: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FORM_Redo: [["number", "number"], "boolean"],\n  FORM_ReplaceAndKeepSelection: [["number", "number", "number"], null],\n  FORM_ReplaceSelection: [["number", "number", "number"], null],\n  FORM_SelectAllText: [["number", "number"], "boolean"],\n  FORM_SetFocusedAnnot: [["number", "number"], "boolean"],\n  FORM_SetIndexSelected: [["number", "number", "number", "boolean"], "boolean"],\n  FORM_Undo: [["number", "number"], "boolean"],\n  FPDF_AddInstalledFont: [["number", "number", "number"], null],\n  FPDF_CloseDocument: [["number"], null],\n  FPDF_ClosePage: [["number"], null],\n  FPDF_CloseXObject: [["number"], null],\n  FPDF_CopyViewerPreferences: [["number", "number"], "boolean"],\n  FPDF_CountNamedDests: [["number"], "number"],\n  FPDF_CreateClipPath: [["number", "number", "number", "number"], "number"],\n  FPDF_CreateNewDocument: [[], "number"],\n  FPDF_DestroyClipPath: [["number"], null],\n  FPDF_DestroyLibrary: [[], null],\n  FPDF_DeviceToPage: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "boolean"\n  ],\n  FPDF_DocumentHasValidCrossReferenceTable: [["number"], "boolean"],\n  FPDF_FFLDraw: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    null\n  ],\n  FPDF_FreeDefaultSystemFontInfo: [["number"], null],\n  FPDF_GetDefaultSystemFontInfo: [[], "number"],\n  FPDF_GetDefaultTTFMap: [[], "number"],\n  FPDF_GetDefaultTTFMapCount: [[], "number"],\n  FPDF_GetDefaultTTFMapEntry: [["number"], "number"],\n  FPDF_GetDocPermissions: [["number"], "number"],\n  FPDF_GetDocUserPermissions: [["number"], "number"],\n  FPDF_GetFileIdentifier: [["number", "number", "number", "number"], "number"],\n  FPDF_GetFileVersion: [["number", "number"], "boolean"],\n  FPDF_GetFormType: [["number"], "number"],\n  FPDF_GetLastError: [[], "number"],\n  FPDF_GetMetaText: [["number", "string", "number", "number"], "number"],\n  FPDF_GetNamedDest: [["number", "number", "number", "number"], "number"],\n  FPDF_GetNamedDestByName: [["number", "string"], "number"],\n  FPDF_GetPageAAction: [["number", "number"], "number"],\n  FPDF_GetPageBoundingBox: [["number", "number"], "boolean"],\n  FPDF_GetPageCount: [["number"], "number"],\n  FPDF_GetPageHeight: [["number"], "number"],\n  FPDF_GetPageHeightF: [["number"], "number"],\n  FPDF_GetPageLabel: [["number", "number", "number", "number"], "number"],\n  FPDF_GetPageSizeByIndex: [["number", "number", "number", "number"], "number"],\n  FPDF_GetPageSizeByIndexF: [["number", "number", "number"], "boolean"],\n  FPDF_GetPageWidth: [["number"], "number"],\n  FPDF_GetPageWidthF: [["number"], "number"],\n  FPDF_GetSecurityHandlerRevision: [["number"], "number"],\n  FPDF_GetSignatureCount: [["number"], "number"],\n  FPDF_GetSignatureObject: [["number", "number"], "number"],\n  FPDF_GetTrailerEnds: [["number", "number", "number"], "number"],\n  FPDF_GetXFAPacketContent: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_GetXFAPacketCount: [["number"], "number"],\n  FPDF_GetXFAPacketName: [["number", "number", "number", "number"], "number"],\n  FPDF_ImportNPagesToOne: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDF_ImportPages: [["number", "number", "string", "number"], "boolean"],\n  FPDF_ImportPagesByIndex: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_InitLibrary: [[], null],\n  FPDF_InitLibraryWithConfig: [["number"], null],\n  FPDF_LoadCustomDocument: [["number", "string"], "number"],\n  FPDF_LoadDocument: [["number", "string"], "number"],\n  FPDF_LoadMemDocument: [["number", "number", "string"], "number"],\n  FPDF_LoadMemDocument64: [["number", "number", "string"], "number"],\n  FPDF_LoadPage: [["number", "number"], "number"],\n  FPDF_LoadXFA: [["number"], "boolean"],\n  FPDF_MovePages: [["number", "number", "number", "number"], "boolean"],\n  FPDF_NewFormObjectFromXObject: [["number"], "number"],\n  FPDF_NewXObjectFromPage: [["number", "number", "number"], "number"],\n  FPDF_PageToDevice: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "boolean"\n  ],\n  FPDF_RemoveFormFieldHighlight: [["number"], null],\n  FPDF_RenderPage_Close: [["number"], null],\n  FPDF_RenderPage_Continue: [["number", "number"], "number"],\n  FPDF_RenderPageBitmap: [\n    ["number", "number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDF_RenderPageBitmap_Start: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "number"\n  ],\n  FPDF_RenderPageBitmapWithColorScheme_Start: [\n    [\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number",\n      "number"\n    ],\n    "number"\n  ],\n  FPDF_RenderPageBitmapWithMatrix: [\n    ["number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDF_SaveAsCopy: [["number", "number", "number"], "boolean"],\n  FPDF_SaveWithVersion: [["number", "number", "number", "number"], "boolean"],\n  FPDF_SetFormFieldHighlightAlpha: [["number", "number"], null],\n  FPDF_SetFormFieldHighlightColor: [["number", "number", "number"], null],\n  FPDF_SetSandBoxPolicy: [["number", "boolean"], null],\n  FPDF_SetSystemFontInfo: [["number"], null],\n  FPDF_StructElement_Attr_CountChildren: [["number"], "number"],\n  FPDF_StructElement_Attr_GetBlobValue: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_StructElement_Attr_GetBooleanValue: [["number", "number"], "boolean"],\n  FPDF_StructElement_Attr_GetChildAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_Attr_GetCount: [["number"], "number"],\n  FPDF_StructElement_Attr_GetName: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_StructElement_Attr_GetNumberValue: [["number", "number"], "boolean"],\n  FPDF_StructElement_Attr_GetStringValue: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDF_StructElement_Attr_GetType: [["number"], "number"],\n  FPDF_StructElement_Attr_GetValue: [["number", "string"], "number"],\n  FPDF_StructElement_CountChildren: [["number"], "number"],\n  FPDF_StructElement_GetActualText: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetAltText: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetAttributeAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_GetAttributeCount: [["number"], "number"],\n  FPDF_StructElement_GetChildAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_GetChildMarkedContentID: [["number", "number"], "number"],\n  FPDF_StructElement_GetID: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetLang: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetMarkedContentID: [["number"], "number"],\n  FPDF_StructElement_GetMarkedContentIdAtIndex: [["number", "number"], "number"],\n  FPDF_StructElement_GetMarkedContentIdCount: [["number"], "number"],\n  FPDF_StructElement_GetObjType: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetParent: [["number"], "number"],\n  FPDF_StructElement_GetStringAttribute: [\n    ["number", "string", "number", "number"],\n    "number"\n  ],\n  FPDF_StructElement_GetTitle: [["number", "number", "number"], "number"],\n  FPDF_StructElement_GetType: [["number", "number", "number"], "number"],\n  FPDF_StructTree_Close: [["number"], null],\n  FPDF_StructTree_CountChildren: [["number"], "number"],\n  FPDF_StructTree_GetChildAtIndex: [["number", "number"], "number"],\n  FPDF_StructTree_GetForPage: [["number"], "number"],\n  FPDF_VIEWERREF_GetDuplex: [["number"], "number"],\n  FPDF_VIEWERREF_GetName: [["number", "string", "number", "number"], "number"],\n  FPDF_VIEWERREF_GetNumCopies: [["number"], "number"],\n  FPDF_VIEWERREF_GetPrintPageRange: [["number"], "number"],\n  FPDF_VIEWERREF_GetPrintPageRangeCount: [["number"], "number"],\n  FPDF_VIEWERREF_GetPrintPageRangeElement: [["number", "number"], "number"],\n  FPDF_VIEWERREF_GetPrintScaling: [["number"], "boolean"],\n  FPDFAction_GetDest: [["number", "number"], "number"],\n  FPDFAction_GetFilePath: [["number", "number", "number"], "number"],\n  FPDFAction_GetType: [["number"], "number"],\n  FPDFAction_GetURIPath: [["number", "number", "number", "number"], "number"],\n  FPDFAnnot_AddFileAttachment: [["number", "number"], "number"],\n  FPDFAnnot_AddInkStroke: [["number", "number", "number"], "number"],\n  FPDFAnnot_AppendAttachmentPoints: [["number", "number"], "boolean"],\n  FPDFAnnot_AppendObject: [["number", "number"], "boolean"],\n  FPDFAnnot_CountAttachmentPoints: [["number"], "number"],\n  FPDFAnnot_GetAP: [["number", "number", "number", "number"], "number"],\n  FPDFAnnot_GetAttachmentPoints: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetBorder: [["number", "number", "number", "number"], "boolean"],\n  FPDFAnnot_GetColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_GetFileAttachment: [["number"], "number"],\n  FPDFAnnot_GetFlags: [["number"], "number"],\n  FPDFAnnot_GetFocusableSubtypes: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetFocusableSubtypesCount: [["number"], "number"],\n  FPDFAnnot_GetFontColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_GetFontSize: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetFormAdditionalActionJavaScript: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormControlCount: [["number", "number"], "number"],\n  FPDFAnnot_GetFormControlIndex: [["number", "number"], "number"],\n  FPDFAnnot_GetFormFieldAlternateName: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormFieldAtPoint: [["number", "number", "number"], "number"],\n  FPDFAnnot_GetFormFieldExportValue: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormFieldFlags: [["number", "number"], "number"],\n  FPDFAnnot_GetFormFieldName: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetFormFieldType: [["number", "number"], "number"],\n  FPDFAnnot_GetFormFieldValue: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetInkListCount: [["number"], "number"],\n  FPDFAnnot_GetInkListPath: [["number", "number", "number", "number"], "number"],\n  FPDFAnnot_GetLine: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_GetLink: [["number"], "number"],\n  FPDFAnnot_GetLinkedAnnot: [["number", "string"], "number"],\n  FPDFAnnot_GetNumberValue: [["number", "string", "number"], "boolean"],\n  FPDFAnnot_GetObject: [["number", "number"], "number"],\n  FPDFAnnot_GetObjectCount: [["number"], "number"],\n  FPDFAnnot_GetOptionCount: [["number", "number"], "number"],\n  FPDFAnnot_GetOptionLabel: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFAnnot_GetRect: [["number", "number"], "boolean"],\n  FPDFAnnot_GetStringValue: [["number", "string", "number", "number"], "number"],\n  FPDFAnnot_GetSubtype: [["number"], "number"],\n  FPDFAnnot_GetValueType: [["number", "string"], "number"],\n  FPDFAnnot_GetVertices: [["number", "number", "number"], "number"],\n  FPDFAnnot_HasAttachmentPoints: [["number"], "boolean"],\n  FPDFAnnot_HasKey: [["number", "string"], "boolean"],\n  FPDFAnnot_IsChecked: [["number", "number"], "boolean"],\n  FPDFAnnot_IsObjectSupportedSubtype: [["number"], "boolean"],\n  FPDFAnnot_IsOptionSelected: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_IsSupportedSubtype: [["number"], "boolean"],\n  FPDFAnnot_RemoveInkList: [["number"], "boolean"],\n  FPDFAnnot_RemoveObject: [["number", "number"], "boolean"],\n  FPDFAnnot_SetAP: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetAttachmentPoints: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetBorder: [["number", "number", "number", "number"], "boolean"],\n  FPDFAnnot_SetColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_SetFlags: [["number", "number"], "boolean"],\n  FPDFAnnot_SetFocusableSubtypes: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetFontColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFAnnot_SetFormFieldFlags: [["number", "number", "number"], "boolean"],\n  FPDFAnnot_SetRect: [["number", "number"], "boolean"],\n  FPDFAnnot_SetStringValue: [["number", "string", "number"], "boolean"],\n  FPDFAnnot_SetURI: [["number", "number"], "boolean"],\n  FPDFAnnot_UpdateObject: [["number", "number"], "boolean"],\n  FPDFAttachment_GetFile: [["number", "number", "number", "number"], "boolean"],\n  FPDFAttachment_GetName: [["number", "number", "number"], "number"],\n  FPDFAttachment_GetStringValue: [\n    ["number", "string", "number", "number"],\n    "number"\n  ],\n  FPDFAttachment_GetSubtype: [["number", "number", "number"], "number"],\n  FPDFAttachment_GetValueType: [["number", "string"], "number"],\n  FPDFAttachment_HasKey: [["number", "string"], "boolean"],\n  FPDFAttachment_SetFile: [["number", "number", "number", "number"], "boolean"],\n  FPDFAttachment_SetStringValue: [["number", "string", "number"], "boolean"],\n  FPDFAvail_Create: [["number", "number"], "number"],\n  FPDFAvail_Destroy: [["number"], null],\n  FPDFAvail_GetDocument: [["number", "string"], "number"],\n  FPDFAvail_GetFirstPageNum: [["number"], "number"],\n  FPDFAvail_IsDocAvail: [["number", "number"], "number"],\n  FPDFAvail_IsFormAvail: [["number", "number"], "number"],\n  FPDFAvail_IsLinearized: [["number"], "number"],\n  FPDFAvail_IsPageAvail: [["number", "number", "number"], "number"],\n  FPDFBitmap_Create: [["number", "number", "number"], "number"],\n  FPDFBitmap_CreateEx: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFBitmap_Destroy: [["number"], null],\n  FPDFBitmap_FillRect: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFBitmap_GetBuffer: [["number"], "number"],\n  FPDFBitmap_GetFormat: [["number"], "number"],\n  FPDFBitmap_GetHeight: [["number"], "number"],\n  FPDFBitmap_GetStride: [["number"], "number"],\n  FPDFBitmap_GetWidth: [["number"], "number"],\n  FPDFBookmark_Find: [["number", "number"], "number"],\n  FPDFBookmark_GetAction: [["number"], "number"],\n  FPDFBookmark_GetCount: [["number"], "number"],\n  FPDFBookmark_GetDest: [["number", "number"], "number"],\n  FPDFBookmark_GetFirstChild: [["number", "number"], "number"],\n  FPDFBookmark_GetNextSibling: [["number", "number"], "number"],\n  FPDFBookmark_GetTitle: [["number", "number", "number"], "number"],\n  FPDFCatalog_IsTagged: [["number"], "boolean"],\n  FPDFCatalog_SetLanguage: [["number", "string"], "boolean"],\n  FPDFClipPath_CountPaths: [["number"], "number"],\n  FPDFClipPath_CountPathSegments: [["number", "number"], "number"],\n  FPDFClipPath_GetPathSegment: [["number", "number", "number"], "number"],\n  FPDFDest_GetDestPageIndex: [["number", "number"], "number"],\n  FPDFDest_GetLocationInPage: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFDest_GetView: [["number", "number", "number"], "number"],\n  FPDFDoc_AddAttachment: [["number", "number"], "number"],\n  FPDFDoc_CloseJavaScriptAction: [["number"], null],\n  FPDFDoc_DeleteAttachment: [["number", "number"], "boolean"],\n  FPDFDOC_ExitFormFillEnvironment: [["number"], null],\n  FPDFDoc_GetAttachment: [["number", "number"], "number"],\n  FPDFDoc_GetAttachmentCount: [["number"], "number"],\n  FPDFDoc_GetJavaScriptAction: [["number", "number"], "number"],\n  FPDFDoc_GetJavaScriptActionCount: [["number"], "number"],\n  FPDFDoc_GetPageMode: [["number"], "number"],\n  FPDFDOC_InitFormFillEnvironment: [["number", "number"], "number"],\n  FPDFFont_Close: [["number"], null],\n  FPDFFont_GetAscent: [["number", "number", "number"], "boolean"],\n  FPDFFont_GetBaseFontName: [["number", "number", "number"], "number"],\n  FPDFFont_GetDescent: [["number", "number", "number"], "boolean"],\n  FPDFFont_GetFamilyName: [["number", "number", "number"], "number"],\n  FPDFFont_GetFlags: [["number"], "number"],\n  FPDFFont_GetFontData: [["number", "number", "number", "number"], "boolean"],\n  FPDFFont_GetGlyphPath: [["number", "number", "number"], "number"],\n  FPDFFont_GetGlyphWidth: [["number", "number", "number", "number"], "boolean"],\n  FPDFFont_GetIsEmbedded: [["number"], "number"],\n  FPDFFont_GetItalicAngle: [["number", "number"], "boolean"],\n  FPDFFont_GetWeight: [["number"], "number"],\n  FPDFFormObj_CountObjects: [["number"], "number"],\n  FPDFFormObj_GetObject: [["number", "number"], "number"],\n  FPDFFormObj_RemoveObject: [["number", "number"], "boolean"],\n  FPDFGlyphPath_CountGlyphSegments: [["number"], "number"],\n  FPDFGlyphPath_GetGlyphPathSegment: [["number", "number"], "number"],\n  FPDFImageObj_GetBitmap: [["number"], "number"],\n  FPDFImageObj_GetIccProfileDataDecoded: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFImageObj_GetImageDataDecoded: [["number", "number", "number"], "number"],\n  FPDFImageObj_GetImageDataRaw: [["number", "number", "number"], "number"],\n  FPDFImageObj_GetImageFilter: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFImageObj_GetImageFilterCount: [["number"], "number"],\n  FPDFImageObj_GetImageMetadata: [["number", "number", "number"], "boolean"],\n  FPDFImageObj_GetImagePixelSize: [["number", "number", "number"], "boolean"],\n  FPDFImageObj_GetRenderedBitmap: [["number", "number", "number"], "number"],\n  FPDFImageObj_LoadJpegFile: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFImageObj_LoadJpegFileInline: [\n    ["number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFImageObj_SetBitmap: [["number", "number", "number", "number"], "boolean"],\n  FPDFImageObj_SetMatrix: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFJavaScriptAction_GetName: [["number", "number", "number"], "number"],\n  FPDFJavaScriptAction_GetScript: [["number", "number", "number"], "number"],\n  FPDFLink_CloseWebLinks: [["number"], null],\n  FPDFLink_CountQuadPoints: [["number"], "number"],\n  FPDFLink_CountRects: [["number", "number"], "number"],\n  FPDFLink_CountWebLinks: [["number"], "number"],\n  FPDFLink_Enumerate: [["number", "number", "number"], "boolean"],\n  FPDFLink_GetAction: [["number"], "number"],\n  FPDFLink_GetAnnot: [["number", "number"], "number"],\n  FPDFLink_GetAnnotRect: [["number", "number"], "boolean"],\n  FPDFLink_GetDest: [["number", "number"], "number"],\n  FPDFLink_GetLinkAtPoint: [["number", "number", "number"], "number"],\n  FPDFLink_GetLinkZOrderAtPoint: [["number", "number", "number"], "number"],\n  FPDFLink_GetQuadPoints: [["number", "number", "number"], "boolean"],\n  FPDFLink_GetRect: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFLink_GetTextRange: [["number", "number", "number", "number"], "boolean"],\n  FPDFLink_GetURL: [["number", "number", "number", "number"], "number"],\n  FPDFLink_LoadWebLinks: [["number"], "number"],\n  FPDFPage_CloseAnnot: [["number"], null],\n  FPDFPage_CountObjects: [["number"], "number"],\n  FPDFPage_CreateAnnot: [["number", "number"], "number"],\n  FPDFPage_Delete: [["number", "number"], null],\n  FPDFPage_Flatten: [["number", "number"], "number"],\n  FPDFPage_FormFieldZOrderAtPoint: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFPage_GenerateContent: [["number"], "boolean"],\n  FPDFPage_GetAnnot: [["number", "number"], "number"],\n  FPDFPage_GetAnnotCount: [["number"], "number"],\n  FPDFPage_GetAnnotIndex: [["number", "number"], "number"],\n  FPDFPage_GetArtBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetBleedBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetCropBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetDecodedThumbnailData: [["number", "number", "number"], "number"],\n  FPDFPage_GetMediaBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_GetObject: [["number", "number"], "number"],\n  FPDFPage_GetRawThumbnailData: [["number", "number", "number"], "number"],\n  FPDFPage_GetRotation: [["number"], "number"],\n  FPDFPage_GetThumbnailAsBitmap: [["number"], "number"],\n  FPDFPage_GetTrimBox: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPage_HasFormFieldAtPoint: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFPage_HasTransparency: [["number"], "boolean"],\n  FPDFPage_InsertClipPath: [["number", "number"], null],\n  FPDFPage_InsertObject: [["number", "number"], null],\n  FPDFPage_InsertObjectAtIndex: [["number", "number", "number"], "boolean"],\n  FPDFPage_New: [["number", "number", "number", "number"], "number"],\n  FPDFPage_RemoveAnnot: [["number", "number"], "boolean"],\n  FPDFPage_RemoveObject: [["number", "number"], "boolean"],\n  FPDFPage_SetArtBox: [["number", "number", "number", "number", "number"], null],\n  FPDFPage_SetBleedBox: [\n    ["number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPage_SetCropBox: [["number", "number", "number", "number", "number"], null],\n  FPDFPage_SetMediaBox: [\n    ["number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPage_SetRotation: [["number", "number"], null],\n  FPDFPage_SetTrimBox: [["number", "number", "number", "number", "number"], null],\n  FPDFPage_TransformAnnots: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPage_TransFormWithClip: [["number", "number", "number"], "boolean"],\n  FPDFPageObj_AddMark: [["number", "string"], "number"],\n  FPDFPageObj_CountMarks: [["number"], "number"],\n  FPDFPageObj_CreateNewPath: [["number", "number"], "number"],\n  FPDFPageObj_CreateNewRect: [["number", "number", "number", "number"], "number"],\n  FPDFPageObj_CreateTextObj: [["number", "number", "number"], "number"],\n  FPDFPageObj_Destroy: [["number"], null],\n  FPDFPageObj_GetBounds: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_GetClipPath: [["number"], "number"],\n  FPDFPageObj_GetDashArray: [["number", "number", "number"], "boolean"],\n  FPDFPageObj_GetDashCount: [["number"], "number"],\n  FPDFPageObj_GetDashPhase: [["number", "number"], "boolean"],\n  FPDFPageObj_GetFillColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_GetIsActive: [["number", "number"], "boolean"],\n  FPDFPageObj_GetLineCap: [["number"], "number"],\n  FPDFPageObj_GetLineJoin: [["number"], "number"],\n  FPDFPageObj_GetMark: [["number", "number"], "number"],\n  FPDFPageObj_GetMarkedContentID: [["number"], "number"],\n  FPDFPageObj_GetMatrix: [["number", "number"], "boolean"],\n  FPDFPageObj_GetRotatedBounds: [["number", "number"], "boolean"],\n  FPDFPageObj_GetStrokeColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_GetStrokeWidth: [["number", "number"], "boolean"],\n  FPDFPageObj_GetType: [["number"], "number"],\n  FPDFPageObj_HasTransparency: [["number"], "boolean"],\n  FPDFPageObj_NewImageObj: [["number"], "number"],\n  FPDFPageObj_NewTextObj: [["number", "string", "number"], "number"],\n  FPDFPageObj_RemoveMark: [["number", "number"], "boolean"],\n  FPDFPageObj_SetBlendMode: [["number", "string"], null],\n  FPDFPageObj_SetDashArray: [["number", "number", "number", "number"], "boolean"],\n  FPDFPageObj_SetDashPhase: [["number", "number"], "boolean"],\n  FPDFPageObj_SetFillColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_SetIsActive: [["number", "boolean"], "boolean"],\n  FPDFPageObj_SetLineCap: [["number", "number"], "boolean"],\n  FPDFPageObj_SetLineJoin: [["number", "number"], "boolean"],\n  FPDFPageObj_SetMatrix: [["number", "number"], "boolean"],\n  FPDFPageObj_SetStrokeColor: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObj_SetStrokeWidth: [["number", "number"], "boolean"],\n  FPDFPageObj_Transform: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPageObj_TransformClipPath: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    null\n  ],\n  FPDFPageObj_TransformF: [["number", "number"], "boolean"],\n  FPDFPageObjMark_CountParams: [["number"], "number"],\n  FPDFPageObjMark_GetName: [["number", "number", "number", "number"], "boolean"],\n  FPDFPageObjMark_GetParamBlobValue: [\n    ["number", "string", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_GetParamIntValue: [["number", "string", "number"], "boolean"],\n  FPDFPageObjMark_GetParamKey: [\n    ["number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_GetParamStringValue: [\n    ["number", "string", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_GetParamValueType: [["number", "string"], "number"],\n  FPDFPageObjMark_RemoveParam: [["number", "number", "string"], "boolean"],\n  FPDFPageObjMark_SetBlobParam: [\n    ["number", "number", "number", "string", "number", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_SetIntParam: [\n    ["number", "number", "number", "string", "number"],\n    "boolean"\n  ],\n  FPDFPageObjMark_SetStringParam: [\n    ["number", "number", "number", "string", "string"],\n    "boolean"\n  ],\n  FPDFPath_BezierTo: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFPath_Close: [["number"], "boolean"],\n  FPDFPath_CountSegments: [["number"], "number"],\n  FPDFPath_GetDrawMode: [["number", "number", "number"], "boolean"],\n  FPDFPath_GetPathSegment: [["number", "number"], "number"],\n  FPDFPath_LineTo: [["number", "number", "number"], "boolean"],\n  FPDFPath_MoveTo: [["number", "number", "number"], "boolean"],\n  FPDFPath_SetDrawMode: [["number", "number", "boolean"], "boolean"],\n  FPDFPathSegment_GetClose: [["number"], "boolean"],\n  FPDFPathSegment_GetPoint: [["number", "number", "number"], "boolean"],\n  FPDFPathSegment_GetType: [["number"], "number"],\n  FPDFSignatureObj_GetByteRange: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetContents: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetDocMDPPermission: [["number"], "number"],\n  FPDFSignatureObj_GetReason: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetSubFilter: [["number", "number", "number"], "number"],\n  FPDFSignatureObj_GetTime: [["number", "number", "number"], "number"],\n  FPDFText_ClosePage: [["number"], null],\n  FPDFText_CountChars: [["number"], "number"],\n  FPDFText_CountRects: [["number", "number", "number"], "number"],\n  FPDFText_FindClose: [["number"], null],\n  FPDFText_FindNext: [["number"], "boolean"],\n  FPDFText_FindPrev: [["number"], "boolean"],\n  FPDFText_FindStart: [["number", "number", "number", "number"], "number"],\n  FPDFText_GetBoundedText: [\n    ["number", "number", "number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFText_GetCharAngle: [["number", "number"], "number"],\n  FPDFText_GetCharBox: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetCharIndexAtPos: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFText_GetCharIndexFromTextIndex: [["number", "number"], "number"],\n  FPDFText_GetCharOrigin: [["number", "number", "number", "number"], "boolean"],\n  FPDFText_GetFillColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetFontInfo: [\n    ["number", "number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFText_GetFontSize: [["number", "number"], "number"],\n  FPDFText_GetFontWeight: [["number", "number"], "number"],\n  FPDFText_GetLooseCharBox: [["number", "number", "number"], "boolean"],\n  FPDFText_GetMatrix: [["number", "number", "number"], "boolean"],\n  FPDFText_GetRect: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetSchCount: [["number"], "number"],\n  FPDFText_GetSchResultIndex: [["number"], "number"],\n  FPDFText_GetStrokeColor: [\n    ["number", "number", "number", "number", "number", "number"],\n    "boolean"\n  ],\n  FPDFText_GetText: [["number", "number", "number", "number"], "number"],\n  FPDFText_GetTextIndexFromCharIndex: [["number", "number"], "number"],\n  FPDFText_GetTextObject: [["number", "number"], "number"],\n  FPDFText_GetUnicode: [["number", "number"], "number"],\n  FPDFText_HasUnicodeMapError: [["number", "number"], "number"],\n  FPDFText_IsGenerated: [["number", "number"], "number"],\n  FPDFText_IsHyphen: [["number", "number"], "number"],\n  FPDFText_LoadCidType2Font: [\n    ["number", "number", "number", "string", "number", "number"],\n    "number"\n  ],\n  FPDFText_LoadFont: [\n    ["number", "number", "number", "number", "boolean"],\n    "number"\n  ],\n  FPDFText_LoadPage: [["number"], "number"],\n  FPDFText_LoadStandardFont: [["number", "string"], "number"],\n  FPDFText_SetCharcodes: [["number", "number", "number"], "boolean"],\n  FPDFText_SetText: [["number", "number"], "boolean"],\n  FPDFTextObj_GetFont: [["number"], "number"],\n  FPDFTextObj_GetFontSize: [["number", "number"], "boolean"],\n  FPDFTextObj_GetRenderedBitmap: [\n    ["number", "number", "number", "number"],\n    "number"\n  ],\n  FPDFTextObj_GetText: [["number", "number", "number", "number"], "number"],\n  FPDFTextObj_GetTextRenderMode: [["number"], "number"],\n  FPDFTextObj_SetTextRenderMode: [["number", "number"], "boolean"],\n  PDFiumExt_CloseFileWriter: [["number"], null],\n  PDFiumExt_CloseFormFillInfo: [["number"], null],\n  PDFiumExt_ExitFormFillEnvironment: [["number"], null],\n  PDFiumExt_GetFileWriterData: [["number", "number", "number"], "number"],\n  PDFiumExt_GetFileWriterSize: [["number"], "number"],\n  PDFiumExt_Init: [[], null],\n  PDFiumExt_InitFormFillEnvironment: [["number", "number"], "number"],\n  PDFiumExt_OpenFileWriter: [[], "number"],\n  PDFiumExt_OpenFormFillInfo: [[], "number"],\n  PDFiumExt_SaveAsCopy: [["number", "number"], "number"]\n};\nasync function createWrappedModule(pdfium) {\n  const module = {\n    pdfium\n  };\n  for (const key in functions) {\n    const ident = key;\n    const args = functions[ident][0];\n    const ret = functions[ident][1];\n    module[ident] = pdfium.cwrap(key, ret, args);\n  }\n  return module;\n}\nasync function init(moduleOverrides) {\n  const pdfium = await createPdfium(moduleOverrides);\n  return createWrappedModule(pdfium);\n}\nvar Rotation = /* @__PURE__ */ ((Rotation2) => {\n  Rotation2[Rotation2["Degree0"] = 0] = "Degree0";\n  Rotation2[Rotation2["Degree90"] = 1] = "Degree90";\n  Rotation2[Rotation2["Degree180"] = 2] = "Degree180";\n  Rotation2[Rotation2["Degree270"] = 3] = "Degree270";\n  return Rotation2;\n})(Rotation || {});\nfunction toIntPos(p) {\n  return { x: Math.floor(p.x), y: Math.floor(p.y) };\n}\nfunction toIntSize(s) {\n  return { width: Math.ceil(s.width), height: Math.ceil(s.height) };\n}\nfunction toIntRect(r) {\n  return {\n    origin: toIntPos(r.origin),\n    size: toIntSize(r.size)\n  };\n}\nfunction swap(size) {\n  const { width, height } = size;\n  return {\n    width: height,\n    height: width\n  };\n}\nfunction transformSize(size, rotation, scaleFactor) {\n  size = rotation % 2 === 0 ? size : swap(size);\n  return {\n    width: size.width * scaleFactor,\n    height: size.height * scaleFactor\n  };\n}\nfunction quadToRect(q) {\n  const xs = [q.p1.x, q.p2.x, q.p3.x, q.p4.x];\n  const ys = [q.p1.y, q.p2.y, q.p3.y, q.p4.y];\n  return {\n    origin: { x: Math.min(...xs), y: Math.min(...ys) },\n    size: {\n      width: Math.max(...xs) - Math.min(...xs),\n      height: Math.max(...ys) - Math.min(...ys)\n    }\n  };\n}\nfunction rectToQuad(r) {\n  return {\n    p1: { x: r.origin.x, y: r.origin.y },\n    p2: { x: r.origin.x + r.size.width, y: r.origin.y },\n    p3: { x: r.origin.x + r.size.width, y: r.origin.y + r.size.height },\n    p4: { x: r.origin.x, y: r.origin.y + r.size.height }\n  };\n}\nfunction rotateRect(containerSize, rect, rotation) {\n  let x = rect.origin.x;\n  let y = rect.origin.y;\n  let size = rect.size;\n  switch (rotation) {\n    case 0:\n      break;\n    case 1:\n      x = containerSize.height - rect.origin.y - rect.size.height;\n      y = rect.origin.x;\n      size = swap(rect.size);\n      break;\n    case 2:\n      x = containerSize.width - rect.origin.x - rect.size.width;\n      y = containerSize.height - rect.origin.y - rect.size.height;\n      break;\n    case 3:\n      x = rect.origin.y;\n      y = containerSize.width - rect.origin.x - rect.size.width;\n      size = swap(rect.size);\n      break;\n  }\n  return {\n    origin: {\n      x,\n      y\n    },\n    size: {\n      width: size.width,\n      height: size.height\n    }\n  };\n}\nfunction scaleRect(rect, scaleFactor) {\n  return {\n    origin: {\n      x: rect.origin.x * scaleFactor,\n      y: rect.origin.y * scaleFactor\n    },\n    size: {\n      width: rect.size.width * scaleFactor,\n      height: rect.size.height * scaleFactor\n    }\n  };\n}\nfunction transformRect(containerSize, rect, rotation, scaleFactor) {\n  return scaleRect(rotateRect(containerSize, rect, rotation), scaleFactor);\n}\nconst makeMatrix = (rectangle, rotation, scaleFactor) => {\n  const { width, height } = rectangle.size;\n  switch (rotation) {\n    case 0:\n      return {\n        a: scaleFactor,\n        b: 0,\n        c: 0,\n        d: -scaleFactor,\n        e: 0,\n        f: height * scaleFactor\n      };\n    case 1:\n      return {\n        a: 0,\n        b: scaleFactor,\n        c: scaleFactor,\n        d: 0,\n        e: 0,\n        f: 0\n      };\n    case 2:\n      return {\n        a: -scaleFactor,\n        b: 0,\n        c: 0,\n        d: scaleFactor,\n        e: width * scaleFactor,\n        f: 0\n      };\n    case 3:\n      return {\n        a: 0,\n        b: -scaleFactor,\n        c: -scaleFactor,\n        d: 0,\n        e: height * scaleFactor,\n        f: width * scaleFactor\n      };\n  }\n};\nclass NoopLogger {\n  /** {@inheritDoc Logger.debug} */\n  debug() {\n  }\n  /** {@inheritDoc Logger.info} */\n  info() {\n  }\n  /** {@inheritDoc Logger.warn} */\n  warn() {\n  }\n  /** {@inheritDoc Logger.error} */\n  error() {\n  }\n  /** {@inheritDoc Logger.perf} */\n  perf() {\n  }\n}\nclass TaskAbortedError extends Error {\n  constructor(reason) {\n    super(`Task aborted: ${JSON.stringify(reason)}`);\n    this.name = "TaskAbortedError";\n  }\n}\nclass TaskRejectedError extends Error {\n  constructor(reason) {\n    super(`Task rejected: ${JSON.stringify(reason)}`);\n    this.name = "TaskRejectedError";\n  }\n}\nclass Task {\n  constructor() {\n    this.state = {\n      stage: 0\n      /* Pending */\n    };\n    this.resolvedCallbacks = [];\n    this.rejectedCallbacks = [];\n    this._promise = null;\n    this.progressCbs = [];\n  }\n  /**\n   * Convert task to promise\n   * @returns promise that will be resolved when task is settled\n   */\n  toPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.wait(\n          (result) => resolve(result),\n          (error) => {\n            if (error.type === "abort") {\n              reject(new TaskAbortedError(error.reason));\n            } else {\n              reject(new TaskRejectedError(error.reason));\n            }\n          }\n        );\n      });\n    }\n    return this._promise;\n  }\n  /**\n   * wait for task to be settled\n   * @param resolvedCallback - callback for resolved value\n   * @param rejectedCallback - callback for rejected value\n   */\n  wait(resolvedCallback, rejectedCallback) {\n    switch (this.state.stage) {\n      case 0:\n        this.resolvedCallbacks.push(resolvedCallback);\n        this.rejectedCallbacks.push(rejectedCallback);\n        break;\n      case 1:\n        resolvedCallback(this.state.result);\n        break;\n      case 2:\n        rejectedCallback({\n          type: "reject",\n          reason: this.state.reason\n        });\n        break;\n      case 3:\n        rejectedCallback({\n          type: "abort",\n          reason: this.state.reason\n        });\n        break;\n    }\n  }\n  /**\n   * resolve task with specific result\n   * @param result - result value\n   */\n  resolve(result) {\n    if (this.state.stage === 0) {\n      this.state = {\n        stage: 1,\n        result\n      };\n      for (const resolvedCallback of this.resolvedCallbacks) {\n        try {\n          resolvedCallback(result);\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * reject task with specific reason\n   * @param reason - abort reason\n   *\n   */\n  reject(reason) {\n    if (this.state.stage === 0) {\n      this.state = {\n        stage: 2,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: "reject",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * abort task with specific reason\n   * @param reason - abort reason\n   */\n  abort(reason) {\n    if (this.state.stage === 0) {\n      this.state = {\n        stage: 3,\n        reason\n      };\n      for (const rejectedCallback of this.rejectedCallbacks) {\n        try {\n          rejectedCallback({\n            type: "abort",\n            reason\n          });\n        } catch (e) {\n        }\n      }\n      this.resolvedCallbacks = [];\n      this.rejectedCallbacks = [];\n    }\n  }\n  /**\n   * fail task with a TaskError from another task\n   * This is a convenience method for error propagation between tasks\n   * @param error - TaskError from another task\n   */\n  fail(error) {\n    if (error.type === "abort") {\n      this.abort(error.reason);\n    } else {\n      this.reject(error.reason);\n    }\n  }\n  /**\n   * add a progress callback\n   * @param cb - progress callback\n   */\n  onProgress(cb) {\n    this.progressCbs.push(cb);\n  }\n  /**\n   * call progress callback\n   * @param p - progress value\n   */\n  progress(p) {\n    for (const cb of this.progressCbs) cb(p);\n  }\n  /**\n   * Static method to wait for all tasks to resolve\n   * Returns a new task that resolves with an array of all results\n   * Rejects immediately if any task fails\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static all(tasks) {\n    const combinedTask = new Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let resolvedCount = 0;\n    let isSettled = false;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          results[index] = result;\n          resolvedCount++;\n          if (resolvedCount === tasks.length) {\n            isSettled = true;\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === "abort") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method to wait for all tasks to settle (resolve, reject, or abort)\n   * Always resolves with an array of settlement results\n   *\n   * @param tasks - array of tasks to wait for\n   * @returns new task that resolves when all input tasks settle\n   * @public\n   */\n  static allSettled(tasks) {\n    const combinedTask = new Task();\n    if (tasks.length === 0) {\n      combinedTask.resolve([]);\n      return combinedTask;\n    }\n    const results = new Array(tasks.length);\n    let settledCount = 0;\n    tasks.forEach((task, index) => {\n      task.wait(\n        (result) => {\n          results[index] = { status: "resolved", value: result };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        },\n        (error) => {\n          results[index] = {\n            status: error.type === "abort" ? "aborted" : "rejected",\n            reason: error.reason\n          };\n          settledCount++;\n          if (settledCount === tasks.length) {\n            combinedTask.resolve(results);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Static method that resolves/rejects with the first task that settles\n   *\n   * @param tasks - array of tasks to race\n   * @returns new task that settles with the first input task that settles\n   * @public\n   */\n  static race(tasks) {\n    const combinedTask = new Task();\n    if (tasks.length === 0) {\n      combinedTask.reject("No tasks provided");\n      return combinedTask;\n    }\n    let isSettled = false;\n    tasks.forEach((task) => {\n      task.wait(\n        (result) => {\n          if (isSettled) return;\n          isSettled = true;\n          combinedTask.resolve(result);\n        },\n        (error) => {\n          if (isSettled) return;\n          isSettled = true;\n          if (error.type === "abort") {\n            combinedTask.abort(error.reason);\n          } else {\n            combinedTask.reject(error.reason);\n          }\n        }\n      );\n    });\n    return combinedTask;\n  }\n  /**\n   * Utility to track progress of multiple tasks\n   *\n   * @param tasks - array of tasks to track\n   * @param onProgress - callback called when any task completes\n   * @returns new task that resolves when all input tasks resolve\n   * @public\n   */\n  static withProgress(tasks, onProgress) {\n    const combinedTask = Task.all(tasks);\n    if (onProgress) {\n      let completedCount = 0;\n      tasks.forEach((task) => {\n        task.wait(\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          },\n          () => {\n            completedCount++;\n            onProgress(completedCount, tasks.length);\n          }\n        );\n      });\n    }\n    return combinedTask;\n  }\n}\nconst PdfSoftHyphenMarker = "­";\nconst PdfZeroWidthSpace = "​";\nconst PdfWordJoiner = "⁠";\nconst PdfBomOrZwnbsp = "\\uFEFF";\nconst PdfNonCharacterFFFE = "￾";\nconst PdfNonCharacterFFFF = "￿";\nconst PdfUnwantedTextMarkers = Object.freeze([\n  PdfSoftHyphenMarker,\n  PdfZeroWidthSpace,\n  PdfWordJoiner,\n  PdfBomOrZwnbsp,\n  PdfNonCharacterFFFE,\n  PdfNonCharacterFFFF\n]);\nconst PdfUnwantedTextRegex = new RegExp(`[${PdfUnwantedTextMarkers.join("")}]`, "g");\nfunction stripPdfUnwantedMarkers(text) {\n  return text.replace(PdfUnwantedTextRegex, "");\n}\nvar PdfZoomMode = /* @__PURE__ */ ((PdfZoomMode2) => {\n  PdfZoomMode2[PdfZoomMode2["Unknown"] = 0] = "Unknown";\n  PdfZoomMode2[PdfZoomMode2["XYZ"] = 1] = "XYZ";\n  PdfZoomMode2[PdfZoomMode2["FitPage"] = 2] = "FitPage";\n  PdfZoomMode2[PdfZoomMode2["FitHorizontal"] = 3] = "FitHorizontal";\n  PdfZoomMode2[PdfZoomMode2["FitVertical"] = 4] = "FitVertical";\n  PdfZoomMode2[PdfZoomMode2["FitRectangle"] = 5] = "FitRectangle";\n  return PdfZoomMode2;\n})(PdfZoomMode || {});\nvar PdfStandardFont = /* @__PURE__ */ ((PdfStandardFont2) => {\n  PdfStandardFont2[PdfStandardFont2["Unknown"] = -1] = "Unknown";\n  PdfStandardFont2[PdfStandardFont2["Courier"] = 0] = "Courier";\n  PdfStandardFont2[PdfStandardFont2["Courier_Bold"] = 1] = "Courier_Bold";\n  PdfStandardFont2[PdfStandardFont2["Courier_BoldOblique"] = 2] = "Courier_BoldOblique";\n  PdfStandardFont2[PdfStandardFont2["Courier_Oblique"] = 3] = "Courier_Oblique";\n  PdfStandardFont2[PdfStandardFont2["Helvetica"] = 4] = "Helvetica";\n  PdfStandardFont2[PdfStandardFont2["Helvetica_Bold"] = 5] = "Helvetica_Bold";\n  PdfStandardFont2[PdfStandardFont2["Helvetica_BoldOblique"] = 6] = "Helvetica_BoldOblique";\n  PdfStandardFont2[PdfStandardFont2["Helvetica_Oblique"] = 7] = "Helvetica_Oblique";\n  PdfStandardFont2[PdfStandardFont2["Times_Roman"] = 8] = "Times_Roman";\n  PdfStandardFont2[PdfStandardFont2["Times_Bold"] = 9] = "Times_Bold";\n  PdfStandardFont2[PdfStandardFont2["Times_BoldItalic"] = 10] = "Times_BoldItalic";\n  PdfStandardFont2[PdfStandardFont2["Times_Italic"] = 11] = "Times_Italic";\n  PdfStandardFont2[PdfStandardFont2["Symbol"] = 12] = "Symbol";\n  PdfStandardFont2[PdfStandardFont2["ZapfDingbats"] = 13] = "ZapfDingbats";\n  return PdfStandardFont2;\n})(PdfStandardFont || {});\nvar PdfTextAlignment = /* @__PURE__ */ ((PdfTextAlignment2) => {\n  PdfTextAlignment2[PdfTextAlignment2["Left"] = 0] = "Left";\n  PdfTextAlignment2[PdfTextAlignment2["Center"] = 1] = "Center";\n  PdfTextAlignment2[PdfTextAlignment2["Right"] = 2] = "Right";\n  return PdfTextAlignment2;\n})(PdfTextAlignment || {});\nvar PdfBlendMode = /* @__PURE__ */ ((PdfBlendMode2) => {\n  PdfBlendMode2[PdfBlendMode2["Normal"] = 0] = "Normal";\n  PdfBlendMode2[PdfBlendMode2["Multiply"] = 1] = "Multiply";\n  PdfBlendMode2[PdfBlendMode2["Screen"] = 2] = "Screen";\n  PdfBlendMode2[PdfBlendMode2["Overlay"] = 3] = "Overlay";\n  PdfBlendMode2[PdfBlendMode2["Darken"] = 4] = "Darken";\n  PdfBlendMode2[PdfBlendMode2["Lighten"] = 5] = "Lighten";\n  PdfBlendMode2[PdfBlendMode2["ColorDodge"] = 6] = "ColorDodge";\n  PdfBlendMode2[PdfBlendMode2["ColorBurn"] = 7] = "ColorBurn";\n  PdfBlendMode2[PdfBlendMode2["HardLight"] = 8] = "HardLight";\n  PdfBlendMode2[PdfBlendMode2["SoftLight"] = 9] = "SoftLight";\n  PdfBlendMode2[PdfBlendMode2["Difference"] = 10] = "Difference";\n  PdfBlendMode2[PdfBlendMode2["Exclusion"] = 11] = "Exclusion";\n  PdfBlendMode2[PdfBlendMode2["Hue"] = 12] = "Hue";\n  PdfBlendMode2[PdfBlendMode2["Saturation"] = 13] = "Saturation";\n  PdfBlendMode2[PdfBlendMode2["Color"] = 14] = "Color";\n  PdfBlendMode2[PdfBlendMode2["Luminosity"] = 15] = "Luminosity";\n  return PdfBlendMode2;\n})(PdfBlendMode || {});\nvar PdfActionType = /* @__PURE__ */ ((PdfActionType2) => {\n  PdfActionType2[PdfActionType2["Unsupported"] = 0] = "Unsupported";\n  PdfActionType2[PdfActionType2["Goto"] = 1] = "Goto";\n  PdfActionType2[PdfActionType2["RemoteGoto"] = 2] = "RemoteGoto";\n  PdfActionType2[PdfActionType2["URI"] = 3] = "URI";\n  PdfActionType2[PdfActionType2["LaunchAppOrOpenFile"] = 4] = "LaunchAppOrOpenFile";\n  return PdfActionType2;\n})(PdfActionType || {});\nvar PdfAnnotationSubtype = /* @__PURE__ */ ((PdfAnnotationSubtype2) => {\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["UNKNOWN"] = 0] = "UNKNOWN";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["TEXT"] = 1] = "TEXT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["LINK"] = 2] = "LINK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["FREETEXT"] = 3] = "FREETEXT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["LINE"] = 4] = "LINE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SQUARE"] = 5] = "SQUARE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["CIRCLE"] = 6] = "CIRCLE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["POLYGON"] = 7] = "POLYGON";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["POLYLINE"] = 8] = "POLYLINE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["HIGHLIGHT"] = 9] = "HIGHLIGHT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["UNDERLINE"] = 10] = "UNDERLINE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SQUIGGLY"] = 11] = "SQUIGGLY";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["STRIKEOUT"] = 12] = "STRIKEOUT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["STAMP"] = 13] = "STAMP";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["CARET"] = 14] = "CARET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["INK"] = 15] = "INK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["POPUP"] = 16] = "POPUP";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["FILEATTACHMENT"] = 17] = "FILEATTACHMENT";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SOUND"] = 18] = "SOUND";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["MOVIE"] = 19] = "MOVIE";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["WIDGET"] = 20] = "WIDGET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["SCREEN"] = 21] = "SCREEN";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["PRINTERMARK"] = 22] = "PRINTERMARK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["TRAPNET"] = 23] = "TRAPNET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["WATERMARK"] = 24] = "WATERMARK";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["THREED"] = 25] = "THREED";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["RICHMEDIA"] = 26] = "RICHMEDIA";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["XFAWIDGET"] = 27] = "XFAWIDGET";\n  PdfAnnotationSubtype2[PdfAnnotationSubtype2["REDACT"] = 28] = "REDACT";\n  return PdfAnnotationSubtype2;\n})(PdfAnnotationSubtype || {});\nvar AppearanceMode = /* @__PURE__ */ ((AppearanceMode2) => {\n  AppearanceMode2[AppearanceMode2["Normal"] = 0] = "Normal";\n  AppearanceMode2[AppearanceMode2["Rollover"] = 1] = "Rollover";\n  AppearanceMode2[AppearanceMode2["Down"] = 2] = "Down";\n  return AppearanceMode2;\n})(AppearanceMode || {});\nvar PdfAnnotationIcon = /* @__PURE__ */ ((PdfAnnotationIcon2) => {\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Unknown"] = -1] = "Unknown";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Comment"] = 0] = "Comment";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Key"] = 1] = "Key";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Note"] = 2] = "Note";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Help"] = 3] = "Help";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["NewParagraph"] = 4] = "NewParagraph";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Paragraph"] = 5] = "Paragraph";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Insert"] = 6] = "Insert";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Graph"] = 7] = "Graph";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["PushPin"] = 8] = "PushPin";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Paperclip"] = 9] = "Paperclip";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Tag"] = 10] = "Tag";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Speaker"] = 11] = "Speaker";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Mic"] = 12] = "Mic";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Approved"] = 13] = "Approved";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Experimental"] = 14] = "Experimental";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["NotApproved"] = 15] = "NotApproved";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["AsIs"] = 16] = "AsIs";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Expired"] = 17] = "Expired";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["NotForPublicRelease"] = 18] = "NotForPublicRelease";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Confidential"] = 19] = "Confidential";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Final"] = 20] = "Final";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Sold"] = 21] = "Sold";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Departmental"] = 22] = "Departmental";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["ForComment"] = 23] = "ForComment";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["TopSecret"] = 24] = "TopSecret";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["Draft"] = 25] = "Draft";\n  PdfAnnotationIcon2[PdfAnnotationIcon2["ForPublicRelease"] = 26] = "ForPublicRelease";\n  return PdfAnnotationIcon2;\n})(PdfAnnotationIcon || {});\nvar PdfAnnotationLineEnding = /* @__PURE__ */ ((PdfAnnotationLineEnding2) => {\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["None"] = 0] = "None";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Square"] = 1] = "Square";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Circle"] = 2] = "Circle";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Diamond"] = 3] = "Diamond";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["OpenArrow"] = 4] = "OpenArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["ClosedArrow"] = 5] = "ClosedArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Butt"] = 6] = "Butt";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["ROpenArrow"] = 7] = "ROpenArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["RClosedArrow"] = 8] = "RClosedArrow";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Slash"] = 9] = "Slash";\n  PdfAnnotationLineEnding2[PdfAnnotationLineEnding2["Unknown"] = 10] = "Unknown";\n  return PdfAnnotationLineEnding2;\n})(PdfAnnotationLineEnding || {});\nvar PDF_FORM_FIELD_TYPE = /* @__PURE__ */ ((PDF_FORM_FIELD_TYPE2) => {\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["PUSHBUTTON"] = 1] = "PUSHBUTTON";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["CHECKBOX"] = 2] = "CHECKBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["RADIOBUTTON"] = 3] = "RADIOBUTTON";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["COMBOBOX"] = 4] = "COMBOBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["LISTBOX"] = 5] = "LISTBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["TEXTFIELD"] = 6] = "TEXTFIELD";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["SIGNATURE"] = 7] = "SIGNATURE";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA"] = 8] = "XFA";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_CHECKBOX"] = 9] = "XFA_CHECKBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_COMBOBOX"] = 10] = "XFA_COMBOBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_IMAGEFIELD"] = 11] = "XFA_IMAGEFIELD";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_LISTBOX"] = 12] = "XFA_LISTBOX";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_PUSHBUTTON"] = 13] = "XFA_PUSHBUTTON";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_SIGNATURE"] = 14] = "XFA_SIGNATURE";\n  PDF_FORM_FIELD_TYPE2[PDF_FORM_FIELD_TYPE2["XFA_TEXTFIELD"] = 15] = "XFA_TEXTFIELD";\n  return PDF_FORM_FIELD_TYPE2;\n})(PDF_FORM_FIELD_TYPE || {});\nvar PdfAnnotationColorType = /* @__PURE__ */ ((PdfAnnotationColorType2) => {\n  PdfAnnotationColorType2[PdfAnnotationColorType2["Color"] = 0] = "Color";\n  PdfAnnotationColorType2[PdfAnnotationColorType2["InteriorColor"] = 1] = "InteriorColor";\n  return PdfAnnotationColorType2;\n})(PdfAnnotationColorType || {});\nvar PdfAnnotationBorderStyle = /* @__PURE__ */ ((PdfAnnotationBorderStyle2) => {\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["UNKNOWN"] = 0] = "UNKNOWN";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["SOLID"] = 1] = "SOLID";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["DASHED"] = 2] = "DASHED";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["BEVELED"] = 3] = "BEVELED";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["INSET"] = 4] = "INSET";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["UNDERLINE"] = 5] = "UNDERLINE";\n  PdfAnnotationBorderStyle2[PdfAnnotationBorderStyle2["CLOUDY"] = 6] = "CLOUDY";\n  return PdfAnnotationBorderStyle2;\n})(PdfAnnotationBorderStyle || {});\nvar PdfPageObjectType = /* @__PURE__ */ ((PdfPageObjectType2) => {\n  PdfPageObjectType2[PdfPageObjectType2["UNKNOWN"] = 0] = "UNKNOWN";\n  PdfPageObjectType2[PdfPageObjectType2["TEXT"] = 1] = "TEXT";\n  PdfPageObjectType2[PdfPageObjectType2["PATH"] = 2] = "PATH";\n  PdfPageObjectType2[PdfPageObjectType2["IMAGE"] = 3] = "IMAGE";\n  PdfPageObjectType2[PdfPageObjectType2["SHADING"] = 4] = "SHADING";\n  PdfPageObjectType2[PdfPageObjectType2["FORM"] = 5] = "FORM";\n  return PdfPageObjectType2;\n})(PdfPageObjectType || {});\nconst PdfAnnotationFlagName = Object.freeze({\n  [\n    1\n    /* INVISIBLE */\n  ]: "invisible",\n  [\n    2\n    /* HIDDEN */\n  ]: "hidden",\n  [\n    4\n    /* PRINT */\n  ]: "print",\n  [\n    8\n    /* NO_ZOOM */\n  ]: "noZoom",\n  [\n    16\n    /* NO_ROTATE */\n  ]: "noRotate",\n  [\n    32\n    /* NO_VIEW */\n  ]: "noView",\n  [\n    64\n    /* READ_ONLY */\n  ]: "readOnly",\n  [\n    128\n    /* LOCKED */\n  ]: "locked",\n  [\n    256\n    /* TOGGLE_NOVIEW */\n  ]: "toggleNoView"\n});\nconst PdfAnnotationFlagValue = Object.entries(\n  PdfAnnotationFlagName\n).reduce(\n  (acc, [bit, name]) => {\n    acc[name] = Number(bit);\n    return acc;\n  },\n  {}\n);\nfunction flagsToNames(raw) {\n  return Object.keys(PdfAnnotationFlagName).filter((flag) => (raw & flag) !== 0).map((flag) => PdfAnnotationFlagName[flag]);\n}\nfunction namesToFlags(names) {\n  return names.reduce(\n    (mask, name) => mask | PdfAnnotationFlagValue[name],\n    0\n    /* NONE */\n  );\n}\nvar MatchFlag = /* @__PURE__ */ ((MatchFlag2) => {\n  MatchFlag2[MatchFlag2["None"] = 0] = "None";\n  MatchFlag2[MatchFlag2["MatchCase"] = 1] = "MatchCase";\n  MatchFlag2[MatchFlag2["MatchWholeWord"] = 2] = "MatchWholeWord";\n  MatchFlag2[MatchFlag2["MatchConsecutive"] = 4] = "MatchConsecutive";\n  return MatchFlag2;\n})(MatchFlag || {});\nvar PdfErrorCode = /* @__PURE__ */ ((PdfErrorCode2) => {\n  PdfErrorCode2[PdfErrorCode2["Ok"] = 0] = "Ok";\n  PdfErrorCode2[PdfErrorCode2["Unknown"] = 1] = "Unknown";\n  PdfErrorCode2[PdfErrorCode2["NotFound"] = 2] = "NotFound";\n  PdfErrorCode2[PdfErrorCode2["WrongFormat"] = 3] = "WrongFormat";\n  PdfErrorCode2[PdfErrorCode2["Password"] = 4] = "Password";\n  PdfErrorCode2[PdfErrorCode2["Security"] = 5] = "Security";\n  PdfErrorCode2[PdfErrorCode2["PageError"] = 6] = "PageError";\n  PdfErrorCode2[PdfErrorCode2["XFALoad"] = 7] = "XFALoad";\n  PdfErrorCode2[PdfErrorCode2["XFALayout"] = 8] = "XFALayout";\n  PdfErrorCode2[PdfErrorCode2["Cancelled"] = 9] = "Cancelled";\n  PdfErrorCode2[PdfErrorCode2["Initialization"] = 10] = "Initialization";\n  PdfErrorCode2[PdfErrorCode2["NotReady"] = 11] = "NotReady";\n  PdfErrorCode2[PdfErrorCode2["NotSupport"] = 12] = "NotSupport";\n  PdfErrorCode2[PdfErrorCode2["LoadDoc"] = 13] = "LoadDoc";\n  PdfErrorCode2[PdfErrorCode2["DocNotOpen"] = 14] = "DocNotOpen";\n  PdfErrorCode2[PdfErrorCode2["CantCloseDoc"] = 15] = "CantCloseDoc";\n  PdfErrorCode2[PdfErrorCode2["CantCreateNewDoc"] = 16] = "CantCreateNewDoc";\n  PdfErrorCode2[PdfErrorCode2["CantImportPages"] = 17] = "CantImportPages";\n  PdfErrorCode2[PdfErrorCode2["CantCreateAnnot"] = 18] = "CantCreateAnnot";\n  PdfErrorCode2[PdfErrorCode2["CantSetAnnotRect"] = 19] = "CantSetAnnotRect";\n  PdfErrorCode2[PdfErrorCode2["CantSetAnnotContent"] = 20] = "CantSetAnnotContent";\n  PdfErrorCode2[PdfErrorCode2["CantRemoveInkList"] = 21] = "CantRemoveInkList";\n  PdfErrorCode2[PdfErrorCode2["CantAddInkStoke"] = 22] = "CantAddInkStoke";\n  PdfErrorCode2[PdfErrorCode2["CantReadAttachmentSize"] = 23] = "CantReadAttachmentSize";\n  PdfErrorCode2[PdfErrorCode2["CantReadAttachmentContent"] = 24] = "CantReadAttachmentContent";\n  PdfErrorCode2[PdfErrorCode2["CantFocusAnnot"] = 25] = "CantFocusAnnot";\n  PdfErrorCode2[PdfErrorCode2["CantSelectText"] = 26] = "CantSelectText";\n  PdfErrorCode2[PdfErrorCode2["CantSelectOption"] = 27] = "CantSelectOption";\n  PdfErrorCode2[PdfErrorCode2["CantCheckField"] = 28] = "CantCheckField";\n  PdfErrorCode2[PdfErrorCode2["CantSetAnnotString"] = 29] = "CantSetAnnotString";\n  return PdfErrorCode2;\n})(PdfErrorCode || {});\nclass PdfTaskHelper {\n  /**\n   * Create a task\n   * @returns new task\n   */\n  static create() {\n    return new Task();\n  }\n  /**\n   * Create a task that has been resolved with value\n   * @param result - resolved value\n   * @returns resolved task\n   */\n  static resolve(result) {\n    const task = new Task();\n    task.resolve(result);\n    return task;\n  }\n  /**\n   * Create a task that has been rejected with error\n   * @param reason - rejected error\n   * @returns rejected task\n   */\n  static reject(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n  /**\n   * Create a task that has been aborted with error\n   * @param reason - aborted error\n   * @returns aborted task\n   */\n  static abort(reason) {\n    const task = new Task();\n    task.reject(reason);\n    return task;\n  }\n}\nfunction pdfColorToWebColor(c) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  const toHex = (n) => clamp(n).toString(16).padStart(2, "0");\n  return `#${toHex(c.red)}${toHex(c.green)}${toHex(c.blue)}`;\n}\nfunction webColorToPdfColor(color) {\n  if (/^#?[0-9a-f]{3}$/i.test(color)) {\n    color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, "#$1$1$2$2$3$3").toLowerCase();\n  }\n  const [, r, g, b] = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color) ?? (() => {\n    throw new Error(`Invalid hex colour: "${color}"`);\n  })();\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16)\n  };\n}\nfunction pdfAlphaToWebOpacity(alpha) {\n  const clamp = (n) => Math.max(0, Math.min(255, n));\n  return clamp(alpha) / 255;\n}\nfunction webOpacityToPdfAlpha(opacity) {\n  const clamp = (n, hi = 255) => Math.max(0, Math.min(hi, n));\n  return clamp(Math.round(opacity * 255));\n}\nfunction pdfDateToDate(pdf) {\n  if (!(pdf == null ? void 0 : pdf.startsWith("D:")) || pdf.length < 16) return;\n  const y = +pdf.slice(2, 6);\n  const mo = +pdf.slice(6, 8) - 1;\n  const d = +pdf.slice(8, 10);\n  const H = +pdf.slice(10, 12);\n  const M = +pdf.slice(12, 14);\n  const S = +pdf.slice(14, 16);\n  return new Date(Date.UTC(y, mo, d, H, M, S));\n}\nfunction dateToPdfDate(date = /* @__PURE__ */ new Date()) {\n  const z = (n, len = 2) => n.toString().padStart(len, "0");\n  const YYYY = date.getUTCFullYear();\n  const MM = z(date.getUTCMonth() + 1);\n  const DD = z(date.getUTCDate());\n  const HH = z(date.getUTCHours());\n  const mm = z(date.getUTCMinutes());\n  const SS = z(date.getUTCSeconds());\n  return `D:${YYYY}${MM}${DD}${HH}${mm}${SS}`;\n}\nconst TEXT_ALIGNMENT_INFOS = Object.freeze([\n  { id: PdfTextAlignment.Left, label: "Left", css: "left" },\n  { id: PdfTextAlignment.Center, label: "Center", css: "center" },\n  { id: PdfTextAlignment.Right, label: "Right", css: "right" }\n]);\nTEXT_ALIGNMENT_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nTEXT_ALIGNMENT_INFOS.reduce(\n  (m, info) => {\n    m[info.css] = info.id;\n    return m;\n  },\n  {}\n);\nTEXT_ALIGNMENT_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nvar PdfStandardFontFamily = /* @__PURE__ */ ((PdfStandardFontFamily2) => {\n  PdfStandardFontFamily2["Courier"] = "Courier";\n  PdfStandardFontFamily2["Helvetica"] = "Helvetica";\n  PdfStandardFontFamily2["Times"] = "Times";\n  PdfStandardFontFamily2["Symbol"] = "Symbol";\n  PdfStandardFontFamily2["ZapfDingbats"] = "ZapfDingbats";\n  PdfStandardFontFamily2["Unknown"] = "Unknown";\n  return PdfStandardFontFamily2;\n})(PdfStandardFontFamily || {});\nPdfStandardFont.Helvetica;\nconst HELVETICA_DESC = {\n  id: PdfStandardFont.Helvetica,\n  family: "Helvetica",\n  bold: false,\n  italic: false,\n  label: "Helvetica",\n  css: "Helvetica, Arial, sans-serif"\n};\nconst STANDARD_FONT_DESCRIPTORS = Object.freeze([\n  {\n    id: PdfStandardFont.Courier,\n    family: "Courier",\n    bold: false,\n    italic: false,\n    label: "Courier",\n    css: "Courier, monospace"\n  },\n  {\n    id: PdfStandardFont.Courier_Bold,\n    family: "Courier",\n    bold: true,\n    italic: false,\n    label: "Courier Bold",\n    css: \'"Courier-Bold", Courier, monospace\'\n  },\n  {\n    id: PdfStandardFont.Courier_BoldOblique,\n    family: "Courier",\n    bold: true,\n    italic: true,\n    label: "Courier Bold Oblique",\n    css: \'"Courier-BoldOblique", Courier, monospace\'\n  },\n  {\n    id: PdfStandardFont.Courier_Oblique,\n    family: "Courier",\n    bold: false,\n    italic: true,\n    label: "Courier Oblique",\n    css: \'"Courier-Oblique", Courier, monospace\'\n  },\n  HELVETICA_DESC,\n  {\n    id: PdfStandardFont.Helvetica_Bold,\n    family: "Helvetica",\n    bold: true,\n    italic: false,\n    label: "Helvetica Bold",\n    css: \'"Helvetica-Bold", Arial, sans-serif\'\n  },\n  {\n    id: PdfStandardFont.Helvetica_BoldOblique,\n    family: "Helvetica",\n    bold: true,\n    italic: true,\n    label: "Helvetica Bold Oblique",\n    css: \'"Helvetica-BoldOblique", Arial, sans-serif\'\n  },\n  {\n    id: PdfStandardFont.Helvetica_Oblique,\n    family: "Helvetica",\n    bold: false,\n    italic: true,\n    label: "Helvetica Oblique",\n    css: \'"Helvetica-Oblique", Arial, sans-serif\'\n  },\n  {\n    id: PdfStandardFont.Times_Roman,\n    family: "Times",\n    bold: false,\n    italic: false,\n    label: "Times Roman",\n    css: \'"Times New Roman", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Times_Bold,\n    family: "Times",\n    bold: true,\n    italic: false,\n    label: "Times Bold",\n    css: \'"Times New Roman Bold", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Times_BoldItalic,\n    family: "Times",\n    bold: true,\n    italic: true,\n    label: "Times Bold Italic",\n    css: \'"Times New Roman Bold Italic", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Times_Italic,\n    family: "Times",\n    bold: false,\n    italic: true,\n    label: "Times Italic",\n    css: \'"Times New Roman Italic", Times, serif\'\n  },\n  {\n    id: PdfStandardFont.Symbol,\n    family: "Symbol",\n    bold: false,\n    italic: false,\n    label: "Symbol",\n    css: "Symbol"\n  },\n  {\n    id: PdfStandardFont.ZapfDingbats,\n    family: "ZapfDingbats",\n    bold: false,\n    italic: false,\n    label: "Zapf Dingbats",\n    css: "ZapfDingbats"\n  }\n]);\nSTANDARD_FONT_DESCRIPTORS.reduce((m, d) => (m[d.id] = d, m), {});\nconst familyStyleToId = /* @__PURE__ */ new Map();\nfor (const d of STANDARD_FONT_DESCRIPTORS) {\n  familyStyleToId.set(`${d.family}_${d.bold}_${d.italic}`, d.id);\n}\nObject.values(PdfStandardFontFamily).filter(\n  (f) => f !== "Unknown"\n  /* Unknown */\n).map((family) => ({ value: family, label: family }));\n[\n  ...new Set(STANDARD_FONT_DESCRIPTORS.map((d) => d.family))\n];\nconst BLEND_MODE_INFOS = Object.freeze([\n  { id: PdfBlendMode.Normal, label: "Normal", css: "normal" },\n  { id: PdfBlendMode.Multiply, label: "Multiply", css: "multiply" },\n  { id: PdfBlendMode.Screen, label: "Screen", css: "screen" },\n  { id: PdfBlendMode.Overlay, label: "Overlay", css: "overlay" },\n  { id: PdfBlendMode.Darken, label: "Darken", css: "darken" },\n  { id: PdfBlendMode.Lighten, label: "Lighten", css: "lighten" },\n  { id: PdfBlendMode.ColorDodge, label: "Color Dodge", css: "color-dodge" },\n  { id: PdfBlendMode.ColorBurn, label: "Color Burn", css: "color-burn" },\n  { id: PdfBlendMode.HardLight, label: "Hard Light", css: "hard-light" },\n  { id: PdfBlendMode.SoftLight, label: "Soft Light", css: "soft-light" },\n  { id: PdfBlendMode.Difference, label: "Difference", css: "difference" },\n  { id: PdfBlendMode.Exclusion, label: "Exclusion", css: "exclusion" },\n  { id: PdfBlendMode.Hue, label: "Hue", css: "hue" },\n  { id: PdfBlendMode.Saturation, label: "Saturation", css: "saturation" },\n  { id: PdfBlendMode.Color, label: "Color", css: "color" },\n  { id: PdfBlendMode.Luminosity, label: "Luminosity", css: "luminosity" }\n]);\nBLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.id] = info;\n    return m;\n  },\n  {}\n);\nBLEND_MODE_INFOS.reduce(\n  (m, info) => {\n    m[info.css] = info.id;\n    return m;\n  },\n  {}\n);\nBLEND_MODE_INFOS.map((info) => ({\n  value: info.id,\n  label: info.label\n}));\nconst V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nfunction isUuidV4(str) {\n  return V4_REGEX.test(str);\n}\nfunction getRandomBytes(len) {\n  var _a;\n  if (typeof ((_a = globalThis.crypto) == null ? void 0 : _a.getRandomValues) === "function") {\n    return globalThis.crypto.getRandomValues(new Uint8Array(len));\n  }\n  if (typeof require === "function") {\n    try {\n      const { randomBytes } = require("crypto");\n      return randomBytes(len);\n    } catch {\n    }\n  }\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) bytes[i] = Math.floor(Math.random() * 256);\n  return bytes;\n}\nfunction uuidV4() {\n  var _a;\n  if (typeof ((_a = globalThis.crypto) == null ? void 0 : _a.randomUUID) === "function") {\n    return globalThis.crypto.randomUUID();\n  }\n  const bytes = getRandomBytes(16);\n  bytes[6] = bytes[6] & 15 | 64;\n  bytes[8] = bytes[8] & 63 | 128;\n  const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");\n  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;\n}\nfunction ignore() {\n}\nconst LOG_SOURCE$1 = "WebWorkerEngineRunner";\nconst LOG_CATEGORY$1 = "Engine";\nclass EngineRunner {\n  /**\n   * Create instance of EngineRunnder\n   * @param logger - logger instance\n   */\n  constructor(logger = new NoopLogger()) {\n    this.logger = logger;\n    this.tasks = /* @__PURE__ */ new Map();\n    this.execute = (request) => {\n      this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "runner start exeucte request");\n      if (!this.engine) {\n        const error = {\n          type: "reject",\n          reason: {\n            code: PdfErrorCode.NotReady,\n            message: "engine has not started yet"\n          }\n        };\n        const response = {\n          id: request.id,\n          type: "ExecuteResponse",\n          data: {\n            type: "error",\n            value: error\n          }\n        };\n        this.respond(response);\n        return;\n      }\n      const engine = this.engine;\n      const { name, args } = request.data;\n      if (!engine[name]) {\n        const error = {\n          type: "reject",\n          reason: {\n            code: PdfErrorCode.NotSupport,\n            message: `engine method ${name} is not supported yet`\n          }\n        };\n        const response = {\n          id: request.id,\n          type: "ExecuteResponse",\n          data: {\n            type: "error",\n            value: error\n          }\n        };\n        this.respond(response);\n        return;\n      }\n      let task;\n      switch (name) {\n        case "isSupport":\n          task = this.engine[name](...args);\n          break;\n        case "initialize":\n          task = this.engine[name](...args);\n          break;\n        case "destroy":\n          task = this.engine[name](...args);\n          break;\n        case "openDocumentUrl":\n          task = this.engine[name](...args);\n          break;\n        case "openDocumentFromBuffer":\n          task = this.engine[name](...args);\n          break;\n        case "openDocumentFromLoader":\n          task = this.engine[name](...args);\n          break;\n        case "getDocPermissions":\n          task = this.engine[name](...args);\n          break;\n        case "getDocUserPermissions":\n          task = this.engine[name](...args);\n          break;\n        case "getMetadata":\n          task = this.engine[name](...args);\n          break;\n        case "getBookmarks":\n          task = this.engine[name](...args);\n          break;\n        case "getSignatures":\n          task = this.engine[name](...args);\n          break;\n        case "renderPage":\n          task = this.engine[name](...args);\n          break;\n        case "renderPageRect":\n          task = this.engine[name](...args);\n          break;\n        case "renderAnnotation":\n          task = this.engine[name](...args);\n          break;\n        case "renderThumbnail":\n          task = this.engine[name](...args);\n          break;\n        case "getAllAnnotations":\n          task = this.engine[name](...args);\n          break;\n        case "getPageAnnotations":\n          task = this.engine[name](...args);\n          break;\n        case "createPageAnnotation":\n          task = this.engine[name](...args);\n          break;\n        case "updatePageAnnotation":\n          task = this.engine[name](...args);\n          break;\n        case "removePageAnnotation":\n          task = this.engine[name](...args);\n          break;\n        case "getPageTextRects":\n          task = this.engine[name](...args);\n          break;\n        case "searchAllPages":\n          task = this.engine[name](...args);\n          break;\n        case "closeDocument":\n          task = this.engine[name](...args);\n          break;\n        case "saveAsCopy":\n          task = this.engine[name](...args);\n          break;\n        case "getAttachments":\n          task = this.engine[name](...args);\n          break;\n        case "readAttachmentContent":\n          task = this.engine[name](...args);\n          break;\n        case "setFormFieldValue":\n          task = this.engine[name](...args);\n          break;\n        case "flattenPage":\n          task = this.engine[name](...args);\n          break;\n        case "extractPages":\n          task = this.engine[name](...args);\n          break;\n        case "extractText":\n          task = this.engine[name](...args);\n          break;\n        case "getTextSlices":\n          task = this.engine[name](...args);\n          break;\n        case "getPageGlyphs":\n          task = this.engine[name](...args);\n          break;\n        case "getPageGeometry":\n          task = this.engine[name](...args);\n          break;\n        case "merge":\n          task = this.engine[name](...args);\n          break;\n        case "mergePages":\n          task = this.engine[name](...args);\n          break;\n      }\n      this.tasks.set(request.id, task);\n      task.onProgress((progress) => {\n        const response = {\n          id: request.id,\n          type: "ExecuteProgress",\n          data: progress\n        };\n        this.respond(response);\n      });\n      task.wait(\n        (result) => {\n          const response = {\n            id: request.id,\n            type: "ExecuteResponse",\n            data: {\n              type: "result",\n              value: result\n            }\n          };\n          this.respond(response);\n          this.tasks.delete(request.id);\n        },\n        (error) => {\n          const response = {\n            id: request.id,\n            type: "ExecuteResponse",\n            data: {\n              type: "error",\n              value: error\n            }\n          };\n          this.respond(response);\n          this.tasks.delete(request.id);\n        }\n      );\n    };\n  }\n  /**\n   * Listening on post message\n   */\n  listen() {\n    self.onmessage = (evt) => {\n      return this.handle(evt);\n    };\n  }\n  /**\n   * Handle post message\n   */\n  handle(evt) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "webworker receive message event: ", evt.data);\n    try {\n      const request = evt.data;\n      switch (request.type) {\n        case "ExecuteRequest":\n          this.execute(request);\n          break;\n        case "AbortRequest":\n          this.abort(request);\n          break;\n      }\n    } catch (e) {\n      this.logger.info(\n        LOG_SOURCE$1,\n        LOG_CATEGORY$1,\n        "webworker met error when processing message event:",\n        e\n      );\n    }\n  }\n  /**\n   * Send the ready response when pdf engine is ready\n   * @returns\n   *\n   * @protected\n   */\n  ready() {\n    this.listen();\n    this.respond({\n      id: "0",\n      type: "ReadyResponse"\n    });\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "runner is ready");\n  }\n  abort(request) {\n    const t = this.tasks.get(request.id);\n    if (!t) {\n      return;\n    }\n    t.abort({\n      code: PdfErrorCode.Cancelled,\n      message: "aborted by client"\n    });\n    this.tasks.delete(request.id);\n  }\n  /**\n   * Send back the response\n   * @param response - response that needs sent back\n   *\n   * @protected\n   */\n  respond(response) {\n    this.logger.debug(LOG_SOURCE$1, LOG_CATEGORY$1, "runner respond: ", response);\n    self.postMessage(response);\n  }\n}\nfunction readString(wasmModule, readChars, parseChars, defaultLength = 100) {\n  let buffer = wasmModule.wasmExports.malloc(defaultLength);\n  for (let i = 0; i < defaultLength; i++) {\n    wasmModule.HEAP8[buffer + i] = 0;\n  }\n  const actualLength = readChars(buffer, defaultLength);\n  let str;\n  if (actualLength > defaultLength) {\n    wasmModule.wasmExports.free(buffer);\n    buffer = wasmModule.wasmExports.malloc(actualLength);\n    for (let i = 0; i < actualLength; i++) {\n      wasmModule.HEAP8[buffer + i] = 0;\n    }\n    readChars(buffer, actualLength);\n    str = parseChars(buffer);\n  } else {\n    str = parseChars(buffer);\n  }\n  wasmModule.wasmExports.free(buffer);\n  return str;\n}\nfunction readArrayBuffer(wasmModule, readChars) {\n  const bufferSize = readChars(0, 0);\n  const bufferPtr = wasmModule.wasmExports.malloc(bufferSize);\n  readChars(bufferPtr, bufferSize);\n  const arrayBuffer = new ArrayBuffer(bufferSize);\n  const view = new DataView(arrayBuffer);\n  for (let i = 0; i < bufferSize; i++) {\n    view.setInt8(i, wasmModule.getValue(bufferPtr + i, "i8"));\n  }\n  wasmModule.wasmExports.free(bufferPtr);\n  return arrayBuffer;\n}\nclass PdfCache {\n  constructor(pdfium) {\n    this.pdfium = pdfium;\n    this.docs = /* @__PURE__ */ new Map();\n  }\n  /** Open (or re-use) a document */\n  setDocument(id, filePtr, docPtr) {\n    let ctx = this.docs.get(id);\n    if (!ctx) {\n      ctx = new DocumentContext(filePtr, docPtr, this.pdfium);\n      this.docs.set(id, ctx);\n    }\n  }\n  /** Retrieve the DocumentContext for a given PdfDocumentObject */\n  getContext(docId) {\n    return this.docs.get(docId);\n  }\n  /** Close & fully release a document and all its pages */\n  closeDocument(docId) {\n    const ctx = this.docs.get(docId);\n    if (!ctx) return false;\n    ctx.dispose();\n    this.docs.delete(docId);\n    return true;\n  }\n}\nclass DocumentContext {\n  constructor(filePtr, docPtr, pdfium) {\n    this.filePtr = filePtr;\n    this.docPtr = docPtr;\n    this.pageCache = new PageCache(pdfium, docPtr);\n  }\n  /** Main accessor for pages */\n  acquirePage(pageIdx) {\n    return this.pageCache.acquire(pageIdx);\n  }\n  /** Scoped accessor for one-off / bulk operations */\n  borrowPage(pageIdx, fn) {\n    return this.pageCache.borrowPage(pageIdx, fn);\n  }\n  /** Tear down all pages + this document */\n  dispose() {\n    this.pageCache.forceReleaseAll();\n    this.pageCache.pdf.FPDF_CloseDocument(this.docPtr);\n    this.pageCache.pdf.pdfium.wasmExports.free(this.filePtr);\n  }\n}\nclass PageCache {\n  constructor(pdf, docPtr) {\n    this.pdf = pdf;\n    this.docPtr = docPtr;\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  acquire(pageIdx) {\n    let ctx = this.cache.get(pageIdx);\n    if (!ctx) {\n      const pagePtr = this.pdf.FPDF_LoadPage(this.docPtr, pageIdx);\n      ctx = new PageContext(this.pdf, this.docPtr, pageIdx, pagePtr, () => {\n        this.cache.delete(pageIdx);\n      });\n      this.cache.set(pageIdx, ctx);\n    }\n    ctx.clearExpiryTimer();\n    ctx.bumpRefCount();\n    return ctx;\n  }\n  /** Helper: run a function “scoped” to a page.\n   *    – if the page was already cached  → .release() (keeps TTL logic)\n   *    – if the page was loaded just now → .disposeImmediate() (free right away)\n   */\n  borrowPage(pageIdx, fn) {\n    const existed = this.cache.has(pageIdx);\n    const ctx = this.acquire(pageIdx);\n    try {\n      return fn(ctx);\n    } finally {\n      existed ? ctx.release() : ctx.disposeImmediate();\n    }\n  }\n  forceReleaseAll() {\n    for (const ctx of this.cache.values()) {\n      ctx.disposeImmediate();\n    }\n    this.cache.clear();\n  }\n}\nconst PAGE_TTL = 5e3;\nclass PageContext {\n  constructor(pdf, docPtr, pageIdx, pagePtr, onFinalDispose) {\n    this.pdf = pdf;\n    this.docPtr = docPtr;\n    this.pageIdx = pageIdx;\n    this.pagePtr = pagePtr;\n    this.onFinalDispose = onFinalDispose;\n    this.refCount = 0;\n    this.disposed = false;\n  }\n  /** Called by PageCache.acquire() */\n  bumpRefCount() {\n    if (this.disposed) throw new Error("Context already disposed");\n    this.refCount++;\n  }\n  /** Called by PageCache.acquire() */\n  clearExpiryTimer() {\n    if (this.expiryTimer) {\n      clearTimeout(this.expiryTimer);\n      this.expiryTimer = void 0;\n    }\n  }\n  /** Called by PageCache.release() internally */\n  release() {\n    if (this.disposed) return;\n    this.refCount--;\n    if (this.refCount === 0) {\n      this.expiryTimer = setTimeout(() => this.disposeImmediate(), PAGE_TTL);\n    }\n  }\n  /** Tear down _all_ sub-pointers & the page. */\n  disposeImmediate() {\n    if (this.disposed) return;\n    this.disposed = true;\n    if (this.textPagePtr !== void 0) {\n      this.pdf.FPDFText_ClosePage(this.textPagePtr);\n    }\n    if (this.formHandle !== void 0) {\n      this.pdf.FORM_OnBeforeClosePage(this.pagePtr, this.formHandle);\n      this.pdf.PDFiumExt_ExitFormFillEnvironment(this.formHandle);\n    }\n    if (this.formInfoPtr !== void 0) {\n      this.pdf.PDFiumExt_CloseFormFillInfo(this.formInfoPtr);\n    }\n    this.pdf.FPDF_ClosePage(this.pagePtr);\n    this.onFinalDispose();\n  }\n  // ── public helpers ──\n  /** Always safe: opens (once) and returns the text-page ptr. */\n  getTextPage() {\n    this.ensureAlive();\n    if (this.textPagePtr === void 0) {\n      this.textPagePtr = this.pdf.FPDFText_LoadPage(this.pagePtr);\n    }\n    return this.textPagePtr;\n  }\n  /** Always safe: opens (once) and returns the form-fill handle. */\n  getFormHandle() {\n    this.ensureAlive();\n    if (this.formHandle === void 0) {\n      this.formInfoPtr = this.pdf.PDFiumExt_OpenFormFillInfo();\n      this.formHandle = this.pdf.PDFiumExt_InitFormFillEnvironment(this.docPtr, this.formInfoPtr);\n      this.pdf.FORM_OnAfterLoadPage(this.pagePtr, this.formHandle);\n    }\n    return this.formHandle;\n  }\n  /**\n   * Safely execute `fn` with an annotation pointer.\n   * Pointer is ALWAYS closed afterwards.\n   */\n  withAnnotation(annotIdx, fn) {\n    this.ensureAlive();\n    const annotPtr = this.pdf.FPDFPage_GetAnnot(this.pagePtr, annotIdx);\n    try {\n      return fn(annotPtr);\n    } finally {\n      this.pdf.FPDFPage_CloseAnnot(annotPtr);\n    }\n  }\n  ensureAlive() {\n    if (this.disposed) throw new Error("PageContext already disposed");\n  }\n}\nconst LOG_SOURCE = "PDFiumEngine";\nconst LOG_CATEGORY = "Engine";\nconst browserImageDataToBlobConverter = (pdfImageData, imageType = "image/webp") => {\n  if (typeof OffscreenCanvas === "undefined") {\n    throw new Error(\n      "OffscreenCanvas is not available in this environment. This converter is intended for browser use only. Please use createNodeImageDataToBlobConverter() or createNodeCanvasImageDataToBlobConverter() for Node.js."\n    );\n  }\n  const imageData = new ImageData(pdfImageData.data, pdfImageData.width, pdfImageData.height);\n  const off = new OffscreenCanvas(imageData.width, imageData.height);\n  off.getContext("2d").putImageData(imageData, 0, 0);\n  return off.convertToBlob({ type: imageType });\n};\nclass PdfiumEngine {\n  /**\n   * Create an instance of PdfiumEngine\n   * @param wasmModule - pdfium wasm module\n   * @param logger - logger instance\n   * @param imageDataToBlobConverter - function to convert ImageData to Blob\n   */\n  constructor(pdfiumModule, logger = new NoopLogger(), imageDataConverter = browserImageDataToBlobConverter) {\n    this.pdfiumModule = pdfiumModule;\n    this.logger = logger;\n    this.imageDataConverter = imageDataConverter;\n    this.cache = new PdfCache(this.pdfiumModule);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.initialize}\n   *\n   * @public\n   */\n  initialize() {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "initialize");\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Initialize`, "Begin", "General");\n    this.pdfiumModule.PDFiumExt_Init();\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Initialize`, "End", "General");\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.destroy}\n   *\n   * @public\n   */\n  destroy() {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "destroy");\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Destroy`, "Begin", "General");\n    this.pdfiumModule.FPDF_DestroyLibrary();\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Destroy`, "End", "General");\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.openDocumentUrl}\n   *\n   * @public\n   */\n  openDocumentUrl(file, options) {\n    const mode = (options == null ? void 0 : options.mode) ?? "auto";\n    const password = (options == null ? void 0 : options.password) ?? "";\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "openDocumentUrl called", file.url, mode);\n    const task = PdfTaskHelper.create();\n    (async () => {\n      try {\n        if (mode === "full-fetch") {\n          const fetchFullTask = await this.fetchFullAndOpen(file, password);\n          fetchFullTask.wait(\n            (doc) => task.resolve(doc),\n            (err) => task.reject(err.reason)\n          );\n        } else if (mode === "range-request") {\n          const openDocumentWithRangeRequestTask = await this.openDocumentWithRangeRequest(\n            file,\n            password\n          );\n          openDocumentWithRangeRequestTask.wait(\n            (doc) => task.resolve(doc),\n            (err) => task.reject(err.reason)\n          );\n        } else {\n          const { supportsRanges, fileLength, content } = await this.checkRangeSupport(file.url);\n          if (supportsRanges) {\n            const openDocumentWithRangeRequestTask = await this.openDocumentWithRangeRequest(\n              file,\n              password,\n              fileLength\n            );\n            openDocumentWithRangeRequestTask.wait(\n              (doc) => task.resolve(doc),\n              (err) => task.reject(err.reason)\n            );\n          } else if (content) {\n            const pdfFile = { id: file.id, content };\n            this.openDocumentFromBuffer(pdfFile, password).wait(\n              (doc) => task.resolve(doc),\n              (err) => task.reject(err.reason)\n            );\n          } else {\n            const fetchFullTask = await this.fetchFullAndOpen(file, password);\n            fetchFullTask.wait(\n              (doc) => task.resolve(doc),\n              (err) => task.reject(err.reason)\n            );\n          }\n        }\n      } catch (err) {\n        this.logger.error(LOG_SOURCE, LOG_CATEGORY, "openDocumentUrl error", err);\n        task.reject({\n          code: PdfErrorCode.Unknown,\n          message: String(err)\n        });\n      }\n    })();\n    return task;\n  }\n  /**\n   * Check if the server supports range requests:\n   * Sends a HEAD request and sees if \'Accept-Ranges: bytes\'.\n   */\n  async checkRangeSupport(url) {\n    try {\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "checkRangeSupport", url);\n      const headResponse = await fetch(url, { method: "HEAD" });\n      const fileLength = headResponse.headers.get("Content-Length");\n      const acceptRanges = headResponse.headers.get("Accept-Ranges");\n      if (acceptRanges === "bytes") {\n        return {\n          supportsRanges: true,\n          fileLength: parseInt(fileLength ?? "0"),\n          content: null\n        };\n      }\n      const testResponse = await fetch(url, {\n        headers: { Range: "bytes=0-1" }\n      });\n      if (testResponse.status === 200) {\n        const content = await testResponse.arrayBuffer();\n        return {\n          supportsRanges: false,\n          fileLength: parseInt(fileLength ?? "0"),\n          content\n        };\n      }\n      return {\n        supportsRanges: testResponse.status === 206,\n        fileLength: parseInt(fileLength ?? "0"),\n        content: null\n      };\n    } catch (e) {\n      this.logger.error(LOG_SOURCE, LOG_CATEGORY, "checkRangeSupport failed", e);\n      throw new Error("Failed to check range support: " + e);\n    }\n  }\n  /**\n   * Fully fetch the file (using fetch) into an ArrayBuffer,\n   * then call openDocumentFromBuffer.\n   */\n  async fetchFullAndOpen(file, password) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "fetchFullAndOpen", file.url);\n    const response = await fetch(file.url);\n    if (!response.ok) {\n      throw new Error(`Could not fetch PDF: ${response.statusText}`);\n    }\n    const arrayBuf = await response.arrayBuffer();\n    const pdfFile = {\n      id: file.id,\n      content: arrayBuf\n    };\n    return this.openDocumentFromBuffer(pdfFile, password);\n  }\n  /**\n   * Use your synchronous partial-loading approach:\n   * - In your snippet, it\'s done via `openDocumentFromLoader`.\n   * - We\'ll do a synchronous XHR read callback that pulls\n   *   the desired byte ranges.\n   */\n  async openDocumentWithRangeRequest(file, password, knownFileLength) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "openDocumentWithRangeRequest", file.url);\n    const fileLength = knownFileLength ?? (await this.retrieveFileLength(file.url)).fileLength;\n    const callback = (offset, length) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open("GET", file.url, false);\n      xhr.overrideMimeType("text/plain; charset=x-user-defined");\n      xhr.setRequestHeader("Range", `bytes=${offset}-${offset + length - 1}`);\n      xhr.send(null);\n      if (xhr.status === 206 || xhr.status === 200) {\n        return this.convertResponseToUint8Array(xhr.responseText);\n      }\n      throw new Error(`Range request failed with status ${xhr.status}`);\n    };\n    return this.openDocumentFromLoader(\n      {\n        id: file.id,\n        fileLength,\n        callback\n      },\n      password\n    );\n  }\n  /**\n   * Helper to do a HEAD request or partial GET to find file length.\n   */\n  async retrieveFileLength(url) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "retrieveFileLength", url);\n    const resp = await fetch(url, { method: "HEAD" });\n    if (!resp.ok) {\n      throw new Error(`Failed HEAD request for file length: ${resp.statusText}`);\n    }\n    const lenStr = resp.headers.get("Content-Length") || "0";\n    const fileLength = parseInt(lenStr, 10) || 0;\n    if (!fileLength) {\n      throw new Error(`Content-Length not found or zero.`);\n    }\n    return { fileLength };\n  }\n  /**\n   * Convert response text (x-user-defined) to a Uint8Array\n   * for partial data.\n   */\n  convertResponseToUint8Array(text) {\n    const array = new Uint8Array(text.length);\n    for (let i = 0; i < text.length; i++) {\n      array[i] = text.charCodeAt(i) & 255;\n    }\n    return array;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.openDocument}\n   *\n   * @public\n   */\n  openDocumentFromBuffer(file, password = "") {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "openDocumentFromBuffer", file, password);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, "Begin", file.id);\n    const array = new Uint8Array(file.content);\n    const length = array.length;\n    const filePtr = this.malloc(length);\n    this.pdfiumModule.pdfium.HEAPU8.set(array, filePtr);\n    const docPtr = this.pdfiumModule.FPDF_LoadMemDocument(filePtr, length, password);\n    if (!docPtr) {\n      const lastError = this.pdfiumModule.FPDF_GetLastError();\n      this.logger.error(LOG_SOURCE, LOG_CATEGORY, `FPDF_LoadMemDocument failed with ${lastError}`);\n      this.free(filePtr);\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, "End", file.id);\n      return PdfTaskHelper.reject({\n        code: lastError,\n        message: `FPDF_LoadMemDocument failed`\n      });\n    }\n    const pageCount = this.pdfiumModule.FPDF_GetPageCount(docPtr);\n    const pages = [];\n    const sizePtr = this.malloc(8);\n    for (let index = 0; index < pageCount; index++) {\n      const result = this.pdfiumModule.FPDF_GetPageSizeByIndexF(docPtr, index, sizePtr);\n      if (!result) {\n        const lastError = this.pdfiumModule.FPDF_GetLastError();\n        this.logger.error(\n          LOG_SOURCE,\n          LOG_CATEGORY,\n          `FPDF_GetPageSizeByIndexF failed with ${lastError}`\n        );\n        this.free(sizePtr);\n        this.pdfiumModule.FPDF_CloseDocument(docPtr);\n        this.free(filePtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, "End", file.id);\n        return PdfTaskHelper.reject({\n          code: lastError,\n          message: `FPDF_GetPageSizeByIndexF failed`\n        });\n      }\n      const page = {\n        index,\n        size: {\n          width: this.pdfiumModule.pdfium.getValue(sizePtr, "float"),\n          height: this.pdfiumModule.pdfium.getValue(sizePtr + 4, "float")\n        }\n      };\n      pages.push(page);\n    }\n    this.free(sizePtr);\n    const pdfDoc = {\n      id: file.id,\n      pageCount,\n      pages\n    };\n    this.cache.setDocument(file.id, filePtr, docPtr);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromBuffer`, "End", file.id);\n    return PdfTaskHelper.resolve(pdfDoc);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.openDocumentFromLoader}\n   *\n   * @public\n   */\n  openDocumentFromLoader(fileLoader, password = "") {\n    const { fileLength, callback, ...file } = fileLoader;\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "openDocumentFromLoader", file, password);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, "Begin", file.id);\n    const readBlock = (_pThis, offset, pBuf, length) => {\n      try {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "readBlock", offset, length, pBuf);\n        if (offset < 0 || offset >= fileLength) {\n          this.logger.error(LOG_SOURCE, LOG_CATEGORY, "Offset out of bounds:", offset);\n          return 0;\n        }\n        const data = callback(offset, length);\n        const dest = new Uint8Array(this.pdfiumModule.pdfium.HEAPU8.buffer, pBuf, data.length);\n        dest.set(data);\n        return data.length;\n      } catch (error) {\n        this.logger.error(LOG_SOURCE, LOG_CATEGORY, "ReadBlock error:", error);\n        return 0;\n      }\n    };\n    const callbackPtr = this.pdfiumModule.pdfium.addFunction(readBlock, "iiiii");\n    const structSize = 12;\n    const fileAccessPtr = this.malloc(structSize);\n    this.pdfiumModule.pdfium.setValue(fileAccessPtr, fileLength, "i32");\n    this.pdfiumModule.pdfium.setValue(fileAccessPtr + 4, callbackPtr, "i32");\n    this.pdfiumModule.pdfium.setValue(fileAccessPtr + 8, 0, "i32");\n    const docPtr = this.pdfiumModule.FPDF_LoadCustomDocument(fileAccessPtr, password);\n    if (!docPtr) {\n      const lastError = this.pdfiumModule.FPDF_GetLastError();\n      this.logger.error(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `FPDF_LoadCustomDocument failed with ${lastError}`\n      );\n      this.free(fileAccessPtr);\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, "End", file.id);\n      return PdfTaskHelper.reject({\n        code: lastError,\n        message: `FPDF_LoadCustomDocument failed`\n      });\n    }\n    const pageCount = this.pdfiumModule.FPDF_GetPageCount(docPtr);\n    const pages = [];\n    const sizePtr = this.malloc(8);\n    for (let index = 0; index < pageCount; index++) {\n      const result = this.pdfiumModule.FPDF_GetPageSizeByIndexF(docPtr, index, sizePtr);\n      if (!result) {\n        const lastError = this.pdfiumModule.FPDF_GetLastError();\n        this.logger.error(\n          LOG_SOURCE,\n          LOG_CATEGORY,\n          `FPDF_GetPageSizeByIndexF failed with ${lastError}`\n        );\n        this.free(sizePtr);\n        this.pdfiumModule.FPDF_CloseDocument(docPtr);\n        this.free(fileAccessPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, "End", file.id);\n        return PdfTaskHelper.reject({\n          code: lastError,\n          message: `FPDF_GetPageSizeByIndexF failed`\n        });\n      }\n      const page = {\n        index,\n        size: {\n          width: this.pdfiumModule.pdfium.getValue(sizePtr, "float"),\n          height: this.pdfiumModule.pdfium.getValue(sizePtr + 4, "float")\n        }\n      };\n      pages.push(page);\n    }\n    this.free(sizePtr);\n    const pdfDoc = {\n      id: file.id,\n      pageCount,\n      pages\n    };\n    this.cache.setDocument(file.id, fileAccessPtr, docPtr);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `OpenDocumentFromLoader`, "End", file.id);\n    return PdfTaskHelper.resolve(pdfDoc);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getMetadata}\n   *\n   * @public\n   */\n  getMetadata(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getMetadata", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetMetadata`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetMetadata`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const metadata = {\n      title: this.readMetaText(ctx.docPtr, "Title"),\n      author: this.readMetaText(ctx.docPtr, "Author"),\n      subject: this.readMetaText(ctx.docPtr, "Subject"),\n      keywords: this.readMetaText(ctx.docPtr, "Keywords"),\n      producer: this.readMetaText(ctx.docPtr, "Producer"),\n      creator: this.readMetaText(ctx.docPtr, "Creator"),\n      creationDate: this.readMetaText(ctx.docPtr, "CreationDate"),\n      modificationDate: this.readMetaText(ctx.docPtr, "ModDate")\n    };\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetMetadata`, "End", doc.id);\n    return PdfTaskHelper.resolve(metadata);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getDocPermissions}\n   *\n   * @public\n   */\n  getDocPermissions(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getDocPermissions", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocPermissions`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocPermissions`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const permissions = this.pdfiumModule.FPDF_GetDocPermissions(ctx.docPtr);\n    return PdfTaskHelper.resolve(permissions);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getDocUserPermissions}\n   *\n   * @public\n   */\n  getDocUserPermissions(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getDocUserPermissions", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocUserPermissions`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getDocUserPermissions`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const permissions = this.pdfiumModule.FPDF_GetDocUserPermissions(ctx.docPtr);\n    return PdfTaskHelper.resolve(permissions);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getSignatures}\n   *\n   * @public\n   */\n  getSignatures(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getSignatures", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetSignatures`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetSignatures`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const signatures = [];\n    const count = this.pdfiumModule.FPDF_GetSignatureCount(ctx.docPtr);\n    for (let i = 0; i < count; i++) {\n      const signatureObjPtr = this.pdfiumModule.FPDF_GetSignatureObject(ctx.docPtr, i);\n      const contents = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n        return this.pdfiumModule.FPDFSignatureObj_GetContents(signatureObjPtr, buffer, bufferSize);\n      });\n      const byteRange = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n        return this.pdfiumModule.FPDFSignatureObj_GetByteRange(signatureObjPtr, buffer, bufferSize) * 4;\n      });\n      const subFilter = readArrayBuffer(this.pdfiumModule.pdfium, (buffer, bufferSize) => {\n        return this.pdfiumModule.FPDFSignatureObj_GetSubFilter(signatureObjPtr, buffer, bufferSize);\n      });\n      const reason = readString(\n        this.pdfiumModule.pdfium,\n        (buffer, bufferLength) => {\n          return this.pdfiumModule.FPDFSignatureObj_GetReason(\n            signatureObjPtr,\n            buffer,\n            bufferLength\n          );\n        },\n        this.pdfiumModule.pdfium.UTF16ToString\n      );\n      const time = readString(\n        this.pdfiumModule.pdfium,\n        (buffer, bufferLength) => {\n          return this.pdfiumModule.FPDFSignatureObj_GetTime(signatureObjPtr, buffer, bufferLength);\n        },\n        this.pdfiumModule.pdfium.UTF8ToString\n      );\n      const docMDP = this.pdfiumModule.FPDFSignatureObj_GetDocMDPPermission(signatureObjPtr);\n      signatures.push({\n        contents,\n        byteRange,\n        subFilter,\n        reason,\n        time,\n        docMDP\n      });\n    }\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetSignatures`, "End", doc.id);\n    return PdfTaskHelper.resolve(signatures);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getBookmarks}\n   *\n   * @public\n   */\n  getBookmarks(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getBookmarks", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetBookmarks`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `getBookmarks`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const bookmarks = this.readPdfBookmarks(ctx.docPtr, 0);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetBookmarks`, "End", doc.id);\n    return PdfTaskHelper.resolve({\n      bookmarks\n    });\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderPage}\n   *\n   * @public\n   */\n  renderPage(doc, page, scaleFactor = 1, rotation = Rotation.Degree0, dpr = 1, options = { withAnnotations: false }, imageType = "image/webp") {\n    const task = new Task();\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      "renderPage",\n      doc,\n      page,\n      scaleFactor,\n      rotation,\n      dpr,\n      options\n    );\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPage`, "Begin", `${doc.id}-${page.index}`);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPage`, "End", `${doc.id}-${page.index}`);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const imageData = this.renderPageRectToImageData(\n      ctx,\n      page,\n      {\n        origin: { x: 0, y: 0 },\n        size: page.size\n      },\n      scaleFactor,\n      rotation,\n      dpr,\n      options\n    );\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPage`, "End", `${doc.id}-${page.index}`);\n    this.imageDataConverter(imageData, imageType).then((blob) => task.resolve(blob));\n    return task;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderPageRect}\n   *\n   * @public\n   */\n  renderPageRect(doc, page, scaleFactor, rotation, dpr, rect, options, imageType = "image/webp") {\n    const task = new Task();\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      "renderPageRect",\n      doc,\n      page,\n      scaleFactor,\n      rotation,\n      dpr,\n      rect,\n      options\n    );\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `RenderPageRect`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `RenderPageRect`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const imageData = this.renderPageRectToImageData(\n      ctx,\n      page,\n      rect,\n      scaleFactor,\n      rotation,\n      dpr,\n      options\n    );\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderPageRect`, "End", `${doc.id}-${page.index}`);\n    this.imageDataConverter(imageData, imageType).then((blob) => task.resolve(blob));\n    return task;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getAllAnnotations}\n   *\n   * @public\n   */\n  getAllAnnotations(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getAllAnnotations-with-progress", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetAllAnnotations", "Begin", doc.id);\n    const task = PdfTaskHelper.create();\n    let cancelled = false;\n    task.wait(ignore, (err) => {\n      if (err.type === "abort") cancelled = true;\n    });\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetAllAnnotations", "End", doc.id);\n      task.reject({ code: PdfErrorCode.DocNotOpen, message: "document does not open" });\n      return task;\n    }\n    const CHUNK_SIZE = 100;\n    const out = {};\n    const processChunk = (startIdx) => {\n      if (cancelled) return;\n      const endIdx = Math.min(startIdx + CHUNK_SIZE, doc.pageCount);\n      for (let pageIdx = startIdx; pageIdx < endIdx && !cancelled; ++pageIdx) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "GetAllAnnotations", "Begin", doc.id, pageIdx);\n        const annots = this.readPageAnnotationsRaw(ctx, doc.pages[pageIdx]);\n        out[pageIdx] = annots;\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "GetAllAnnotations", "End", doc.id, pageIdx);\n        task.progress({ page: pageIdx, annotations: annots });\n      }\n      if (cancelled) return;\n      if (endIdx >= doc.pageCount) {\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetAllAnnotations", "End", doc.id);\n        task.resolve(out);\n        return;\n      }\n      setTimeout(() => processChunk(endIdx), 0);\n    };\n    processChunk(0);\n    return task;\n  }\n  readAllAnnotations(doc, ctx) {\n    const annotationsByPage = {};\n    for (let i = 0; i < doc.pageCount; i++) {\n      const pageAnnotations = this.readPageAnnotations(ctx, doc.pages[i]);\n      annotationsByPage[i] = pageAnnotations;\n    }\n    return annotationsByPage;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getPageAnnotations}\n   *\n   * @public\n   */\n  getPageAnnotations(doc, page) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getPageAnnotations", doc, page);\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `GetPageAnnotations`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `GetPageAnnotations`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const annotations = this.readPageAnnotations(ctx, page);\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `GetPageAnnotations`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `GetPageAnnotations`,\n      `${doc.id}-${page.index}`,\n      annotations\n    );\n    return PdfTaskHelper.resolve(annotations);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.createPageAnnotation}\n   *\n   * @public\n   */\n  createPageAnnotation(doc, page, annotation, context) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "createPageAnnotation", doc, page, annotation);\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `CreatePageAnnotation`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const annotationPtr = this.pdfiumModule.EPDFPage_CreateAnnot(pageCtx.pagePtr, annotation.type);\n    if (!annotationPtr) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      pageCtx.release();\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateAnnot,\n        message: "can not create annotation with specified type"\n      });\n    }\n    if (!this.setAnnotString(annotationPtr, "NM", annotation.id)) {\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n      pageCtx.release();\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotString,\n        message: "can not set the name of the annotation"\n      });\n    }\n    if (!this.setPageAnnoRect(page, pageCtx.pagePtr, annotationPtr, annotation.rect)) {\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotRect,\n        message: "can not set the rect of the annotation"\n      });\n    }\n    let isSucceed = false;\n    switch (annotation.type) {\n      case PdfAnnotationSubtype.INK:\n        isSucceed = this.addInkStroke(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.STAMP:\n        isSucceed = this.addStampContent(\n          ctx.docPtr,\n          page,\n          pageCtx.pagePtr,\n          annotationPtr,\n          annotation,\n          context == null ? void 0 : context.imageData\n        );\n        break;\n      case PdfAnnotationSubtype.TEXT:\n        isSucceed = this.addTextContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.FREETEXT:\n        isSucceed = this.addFreeTextContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.LINE:\n        isSucceed = this.addLineContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.POLYLINE:\n      case PdfAnnotationSubtype.POLYGON:\n        isSucceed = this.addPolyContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.CIRCLE:\n      case PdfAnnotationSubtype.SQUARE:\n        isSucceed = this.addShapeContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n      case PdfAnnotationSubtype.UNDERLINE:\n      case PdfAnnotationSubtype.STRIKEOUT:\n      case PdfAnnotationSubtype.SQUIGGLY:\n      case PdfAnnotationSubtype.HIGHLIGHT:\n        isSucceed = this.addTextMarkupContent(page, pageCtx.pagePtr, annotationPtr, annotation);\n        break;\n    }\n    if (!isSucceed) {\n      this.pdfiumModule.FPDFPage_RemoveAnnot(pageCtx.pagePtr, annotationPtr);\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `CreatePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotContent,\n        message: "can not add content of the annotation"\n      });\n    }\n    if (annotation.blendMode !== void 0) {\n      this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(annotationPtr, annotation.blendMode);\n    } else {\n      this.pdfiumModule.EPDFAnnot_GenerateAppearance(annotationPtr);\n    }\n    this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n    const annotId = this.pdfiumModule.FPDFPage_GetAnnotIndex(pageCtx.pagePtr, annotationPtr);\n    this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `CreatePageAnnotation`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return annotId >= 0 ? PdfTaskHelper.resolve(annotId) : PdfTaskHelper.reject({\n      code: PdfErrorCode.CantCreateAnnot,\n      message: "annotation created but index could not be determined"\n    });\n  }\n  /**\n   * Update an existing page annotation in-place\n   *\n   *  • Locates the annot by page-local index (`annotation.id`)\n   *  • Re-writes its /Rect and type-specific payload\n   *  • Calls FPDFPage_GenerateContent so the new appearance is rendered\n   *\n   * @returns PdfTask<boolean>  –  true on success\n   */\n  updatePageAnnotation(doc, page, annotation) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "updatePageAnnotation", doc, page, annotation);\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      "UpdatePageAnnotation",\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        "UpdatePageAnnotation",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const annotPtr = this.getAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!annotPtr) {\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        "UpdatePageAnnotation",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: "annotation not found" });\n    }\n    if (!this.setPageAnnoRect(page, pageCtx.pagePtr, annotPtr, annotation.rect)) {\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        "UpdatePageAnnotation",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantSetAnnotRect,\n        message: "failed to move annotation"\n      });\n    }\n    let ok = false;\n    switch (annotation.type) {\n      /* ── Ink ─────────────────────────────────────────────────────────────── */\n      case PdfAnnotationSubtype.INK: {\n        if (!this.pdfiumModule.FPDFAnnot_RemoveInkList(annotPtr)) break;\n        ok = this.addInkStroke(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* ── Stamp ───────────────────────────────────────────────────────────── */\n      case PdfAnnotationSubtype.STAMP: {\n        ok = this.addStampContent(ctx.docPtr, page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      case PdfAnnotationSubtype.TEXT: {\n        ok = this.addTextContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* ── Free text ────────────────────────────────────────────────────────── */\n      case PdfAnnotationSubtype.FREETEXT: {\n        ok = this.addFreeTextContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* ── Shape ───────────────────────────────────────────────────────────── */\n      case PdfAnnotationSubtype.CIRCLE:\n      case PdfAnnotationSubtype.SQUARE: {\n        ok = this.addShapeContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* ── Line ─────────────────────────────────────────────────────────────── */\n      case PdfAnnotationSubtype.LINE: {\n        ok = this.addLineContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* ── Polygon / Polyline ───────────────────────────────────────────────── */\n      case PdfAnnotationSubtype.POLYGON:\n      case PdfAnnotationSubtype.POLYLINE: {\n        ok = this.addPolyContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* ── Text-markup family ──────────────────────────────────────────────── */\n      case PdfAnnotationSubtype.HIGHLIGHT:\n      case PdfAnnotationSubtype.UNDERLINE:\n      case PdfAnnotationSubtype.STRIKEOUT:\n      case PdfAnnotationSubtype.SQUIGGLY: {\n        ok = this.addTextMarkupContent(page, pageCtx.pagePtr, annotPtr, annotation);\n        break;\n      }\n      /* ── Unsupported edits – fall through to error ───────────────────────── */\n      default:\n        ok = false;\n    }\n    if (ok) {\n      if (annotation.blendMode !== void 0) {\n        this.pdfiumModule.EPDFAnnot_GenerateAppearanceWithBlend(annotPtr, annotation.blendMode);\n      } else {\n        this.pdfiumModule.EPDFAnnot_GenerateAppearance(annotPtr);\n      }\n      this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n    }\n    this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      "UpdatePageAnnotation",\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return ok ? PdfTaskHelper.resolve(true) : PdfTaskHelper.reject({\n      code: PdfErrorCode.CantSetAnnotContent,\n      message: "failed to update annotation"\n    });\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.removePageAnnotation}\n   *\n   * @public\n   */\n  removePageAnnotation(doc, page, annotation) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "removePageAnnotation", doc, page, annotation);\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `RemovePageAnnotation`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `RemovePageAnnotation`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    let result = false;\n    result = this.removeAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!result) {\n      this.logger.error(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `FPDFPage_RemoveAnnot Failed`,\n        `${doc.id}-${page.index}`\n      );\n    } else {\n      result = this.pdfiumModule.FPDFPage_GenerateContent(pageCtx.pagePtr);\n      if (!result) {\n        this.logger.error(\n          LOG_SOURCE,\n          LOG_CATEGORY,\n          `FPDFPage_GenerateContent Failed`,\n          `${doc.id}-${page.index}`\n        );\n      }\n    }\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `RemovePageAnnotation`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return PdfTaskHelper.resolve(result);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getPageTextRects}\n   *\n   * @public\n   */\n  getPageTextRects(doc, page, scaleFactor, rotation) {\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      "getPageTextRects",\n      doc,\n      page,\n      scaleFactor,\n      rotation\n    );\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `GetPageTextRects`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `GetPageTextRects`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const textPagePtr = this.pdfiumModule.FPDFText_LoadPage(pageCtx.pagePtr);\n    const textRects = this.readPageTextRects(page, pageCtx.docPtr, pageCtx.pagePtr, textPagePtr);\n    this.pdfiumModule.FPDFText_ClosePage(textPagePtr);\n    pageCtx.release();\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `GetPageTextRects`,\n      "End",\n      `${doc.id}-${page.index}`\n    );\n    return PdfTaskHelper.resolve(textRects);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderThumbnail}\n   *\n   * @public\n   */\n  renderThumbnail(doc, page, scaleFactor, rotation, dpr) {\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      "renderThumbnail",\n      doc,\n      page,\n      scaleFactor,\n      rotation,\n      dpr\n    );\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `RenderThumbnail`,\n      "Begin",\n      `${doc.id}-${page.index}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `RenderThumbnail`,\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    scaleFactor = Math.max(scaleFactor, 0.5);\n    const result = this.renderPage(doc, page, scaleFactor, rotation, dpr, {\n      withAnnotations: true\n    });\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `RenderThumbnail`, "End", `${doc.id}-${page.index}`);\n    return result;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getAttachments}\n   *\n   * @public\n   */\n  getAttachments(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getAttachments", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAttachments`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAttachments`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const attachments = [];\n    const count = this.pdfiumModule.FPDFDoc_GetAttachmentCount(ctx.docPtr);\n    for (let i = 0; i < count; i++) {\n      const attachment = this.readPdfAttachment(ctx.docPtr, i);\n      attachments.push(attachment);\n    }\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `GetAttachments`, "End", doc.id);\n    return PdfTaskHelper.resolve(attachments);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.readAttachmentContent}\n   *\n   * @public\n   */\n  readAttachmentContent(doc, attachment) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "readAttachmentContent", doc, attachment);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const attachmentPtr = this.pdfiumModule.FPDFDoc_GetAttachment(ctx.docPtr, attachment.index);\n    const sizePtr = this.malloc(8);\n    if (!this.pdfiumModule.FPDFAttachment_GetFile(attachmentPtr, 0, 0, sizePtr)) {\n      this.free(sizePtr);\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantReadAttachmentSize,\n        message: "can not read attachment size"\n      });\n    }\n    const size = this.pdfiumModule.pdfium.getValue(sizePtr, "i64");\n    const contentPtr = this.malloc(size);\n    if (!this.pdfiumModule.FPDFAttachment_GetFile(attachmentPtr, contentPtr, size, sizePtr)) {\n      this.free(sizePtr);\n      this.free(contentPtr);\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantReadAttachmentContent,\n        message: "can not read attachment content"\n      });\n    }\n    const buffer = new ArrayBuffer(size);\n    const view = new DataView(buffer);\n    for (let i = 0; i < size; i++) {\n      view.setInt8(i, this.pdfiumModule.pdfium.getValue(contentPtr + i, "i8"));\n    }\n    this.free(sizePtr);\n    this.free(contentPtr);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ReadAttachmentContent`, "End", doc.id);\n    return PdfTaskHelper.resolve(buffer);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.setFormFieldValue}\n   *\n   * @public\n   */\n  setFormFieldValue(doc, page, annotation, value) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "SetFormFieldValue", doc, annotation, value);\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `SetFormFieldValue`,\n      "Begin",\n      `${doc.id}-${annotation.id}`\n    );\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "SetFormFieldValue", "document is not opened");\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `SetFormFieldValue`,\n        "End",\n        `${doc.id}-${annotation.id}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const formFillInfoPtr = this.pdfiumModule.PDFiumExt_OpenFormFillInfo();\n    const formHandle = this.pdfiumModule.PDFiumExt_InitFormFillEnvironment(\n      ctx.docPtr,\n      formFillInfoPtr\n    );\n    const pageCtx = ctx.acquirePage(page.index);\n    this.pdfiumModule.FORM_OnAfterLoadPage(pageCtx.pagePtr, formHandle);\n    const annotationPtr = this.getAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!annotationPtr) {\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        "SetFormFieldValue",\n        "End",\n        `${doc.id}-${page.index}`\n      );\n      return PdfTaskHelper.reject({ code: PdfErrorCode.NotFound, message: "annotation not found" });\n    }\n    if (!this.pdfiumModule.FORM_SetFocusedAnnot(formHandle, annotationPtr)) {\n      this.logger.debug(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        "SetFormFieldValue",\n        "failed to set focused annotation"\n      );\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `SetFormFieldValue`,\n        "End",\n        `${doc.id}-${annotation.id}`\n      );\n      this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n      this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n      pageCtx.release();\n      this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n      this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantFocusAnnot,\n        message: "failed to set focused annotation"\n      });\n    }\n    switch (value.kind) {\n      case "text":\n        {\n          if (!this.pdfiumModule.FORM_SelectAllText(formHandle, pageCtx.pagePtr)) {\n            this.logger.debug(\n              LOG_SOURCE,\n              LOG_CATEGORY,\n              "SetFormFieldValue",\n              "failed to select all text"\n            );\n            this.logger.perf(\n              LOG_SOURCE,\n              LOG_CATEGORY,\n              `SetFormFieldValue`,\n              "End",\n              `${doc.id}-${annotation.id}`\n            );\n            this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n            pageCtx.release();\n            this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n            this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n            return PdfTaskHelper.reject({\n              code: PdfErrorCode.CantSelectText,\n              message: "failed to select all text"\n            });\n          }\n          const length = 2 * (value.text.length + 1);\n          const textPtr = this.malloc(length);\n          this.pdfiumModule.pdfium.stringToUTF16(value.text, textPtr, length);\n          this.pdfiumModule.FORM_ReplaceSelection(formHandle, pageCtx.pagePtr, textPtr);\n          this.free(textPtr);\n        }\n        break;\n      case "selection":\n        {\n          if (!this.pdfiumModule.FORM_SetIndexSelected(\n            formHandle,\n            pageCtx.pagePtr,\n            value.index,\n            value.isSelected\n          )) {\n            this.logger.debug(\n              LOG_SOURCE,\n              LOG_CATEGORY,\n              "SetFormFieldValue",\n              "failed to set index selected"\n            );\n            this.logger.perf(\n              LOG_SOURCE,\n              LOG_CATEGORY,\n              `SetFormFieldValue`,\n              "End",\n              `${doc.id}-${annotation.id}`\n            );\n            this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n            pageCtx.release();\n            this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n            this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n            return PdfTaskHelper.reject({\n              code: PdfErrorCode.CantSelectOption,\n              message: "failed to set index selected"\n            });\n          }\n        }\n        break;\n      case "checked":\n        {\n          const kReturn = 13;\n          if (!this.pdfiumModule.FORM_OnChar(formHandle, pageCtx.pagePtr, kReturn, 0)) {\n            this.logger.debug(\n              LOG_SOURCE,\n              LOG_CATEGORY,\n              "SetFormFieldValue",\n              "failed to set field checked"\n            );\n            this.logger.perf(\n              LOG_SOURCE,\n              LOG_CATEGORY,\n              `SetFormFieldValue`,\n              "End",\n              `${doc.id}-${annotation.id}`\n            );\n            this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n            this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n            this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n            pageCtx.release();\n            this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n            this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n            return PdfTaskHelper.reject({\n              code: PdfErrorCode.CantCheckField,\n              message: "failed to set field checked"\n            });\n          }\n        }\n        break;\n    }\n    this.pdfiumModule.FORM_ForceToKillFocus(formHandle);\n    this.pdfiumModule.FPDFPage_CloseAnnot(annotationPtr);\n    this.pdfiumModule.FORM_OnBeforeClosePage(pageCtx.pagePtr, formHandle);\n    pageCtx.release();\n    this.pdfiumModule.PDFiumExt_ExitFormFillEnvironment(formHandle);\n    this.pdfiumModule.PDFiumExt_CloseFormFillInfo(formFillInfoPtr);\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.flattenPage}\n   *\n   * @public\n   */\n  flattenPage(doc, page, flag) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "flattenPage", doc, page, flag);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `flattenPage`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `flattenPage`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const result = this.pdfiumModule.FPDFPage_Flatten(pageCtx.pagePtr, flag);\n    pageCtx.release();\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `flattenPage`, "End", doc.id);\n    return PdfTaskHelper.resolve(result);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.extractPages}\n   *\n   * @public\n   */\n  extractPages(doc, pageIndexes) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "extractPages", doc, pageIndexes);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n    if (!newDocPtr) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateNewDoc,\n        message: "can not create new document"\n      });\n    }\n    const pageIndexesPtr = this.malloc(pageIndexes.length * 4);\n    for (let i = 0; i < pageIndexes.length; i++) {\n      this.pdfiumModule.pdfium.setValue(pageIndexesPtr + i * 4, pageIndexes[i], "i32");\n    }\n    if (!this.pdfiumModule.FPDF_ImportPagesByIndex(\n      newDocPtr,\n      ctx.docPtr,\n      pageIndexesPtr,\n      pageIndexes.length,\n      0\n    )) {\n      this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantImportPages,\n        message: "can not import pages to new document"\n      });\n    }\n    const buffer = this.saveDocument(newDocPtr);\n    this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractPages`, "End", doc.id);\n    return PdfTaskHelper.resolve(buffer);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.extractText}\n   *\n   * @public\n   */\n  extractText(doc, pageIndexes) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "extractText", doc, pageIndexes);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractText`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractText`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const strings = [];\n    for (let i = 0; i < pageIndexes.length; i++) {\n      const pageCtx = ctx.acquirePage(pageIndexes[i]);\n      const textPagePtr = this.pdfiumModule.FPDFText_LoadPage(pageCtx.pagePtr);\n      const charCount = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n      const bufferPtr = this.malloc((charCount + 1) * 2);\n      this.pdfiumModule.FPDFText_GetText(textPagePtr, 0, charCount, bufferPtr);\n      const text2 = this.pdfiumModule.pdfium.UTF16ToString(bufferPtr);\n      this.free(bufferPtr);\n      strings.push(text2);\n      this.pdfiumModule.FPDFText_ClosePage(textPagePtr);\n      pageCtx.release();\n    }\n    const text = strings.join("\\n\\n");\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `ExtractText`, "End", doc.id);\n    return PdfTaskHelper.resolve(text);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.getTextSlices}\n   *\n   * @public\n   */\n  getTextSlices(doc, slices) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getTextSlices", doc, slices);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetTextSlices", "Begin", doc.id);\n    if (slices.length === 0) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.resolve([]);\n    }\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    try {\n      const out = new Array(slices.length);\n      const byPage = /* @__PURE__ */ new Map();\n      slices.forEach((s, i) => {\n        (byPage.get(s.pageIndex) ?? byPage.set(s.pageIndex, []).get(s.pageIndex)).push({\n          slice: s,\n          pos: i\n        });\n      });\n      for (const [pageIdx, list] of byPage) {\n        const pageCtx = ctx.acquirePage(pageIdx);\n        const textPagePtr = pageCtx.getTextPage();\n        for (const { slice, pos } of list) {\n          const bufPtr = this.malloc(2 * (slice.charCount + 1));\n          this.pdfiumModule.FPDFText_GetText(textPagePtr, slice.charIndex, slice.charCount, bufPtr);\n          out[pos] = stripPdfUnwantedMarkers(this.pdfiumModule.pdfium.UTF16ToString(bufPtr));\n          this.free(bufPtr);\n        }\n        pageCtx.release();\n      }\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.resolve(out);\n    } catch (e) {\n      this.logger.error(LOG_SOURCE, LOG_CATEGORY, "getTextSlices error", e);\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "GetTextSlices", "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: String(e)\n      });\n    }\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.merge}\n   *\n   * @public\n   */\n  merge(files) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "merge", files);\n    const fileIds = files.map((file2) => file2.id).join(".");\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, "Begin", fileIds);\n    const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n    if (!newDocPtr) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, "End", fileIds);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateNewDoc,\n        message: "can not create new document"\n      });\n    }\n    const ptrs = [];\n    for (const file2 of files.reverse()) {\n      const array = new Uint8Array(file2.content);\n      const length = array.length;\n      const filePtr = this.malloc(length);\n      this.pdfiumModule.pdfium.HEAPU8.set(array, filePtr);\n      const docPtr = this.pdfiumModule.FPDF_LoadMemDocument(filePtr, length, "");\n      if (!docPtr) {\n        const lastError = this.pdfiumModule.FPDF_GetLastError();\n        this.logger.error(\n          LOG_SOURCE,\n          LOG_CATEGORY,\n          `FPDF_LoadMemDocument failed with ${lastError}`\n        );\n        this.free(filePtr);\n        for (const ptr of ptrs) {\n          this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n          this.free(ptr.filePtr);\n        }\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, "End", fileIds);\n        return PdfTaskHelper.reject({\n          code: lastError,\n          message: `FPDF_LoadMemDocument failed`\n        });\n      }\n      ptrs.push({ filePtr, docPtr });\n      if (!this.pdfiumModule.FPDF_ImportPages(newDocPtr, docPtr, "", 0)) {\n        this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n        for (const ptr of ptrs) {\n          this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n          this.free(ptr.filePtr);\n        }\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, "End", fileIds);\n        return PdfTaskHelper.reject({\n          code: PdfErrorCode.CantImportPages,\n          message: "can not import pages to new document"\n        });\n      }\n    }\n    const buffer = this.saveDocument(newDocPtr);\n    this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n    for (const ptr of ptrs) {\n      this.pdfiumModule.FPDF_CloseDocument(ptr.docPtr);\n      this.free(ptr.filePtr);\n    }\n    const file = {\n      id: `${Math.random()}`,\n      content: buffer\n    };\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `Merge`, "End", fileIds);\n    return PdfTaskHelper.resolve(file);\n  }\n  /**\n   * Merges specific pages from multiple PDF documents in a custom order\n   *\n   * @param mergeConfigs Array of configurations specifying which pages to merge from which documents\n   * @returns A PdfTask that resolves with the merged PDF file\n   * @public\n   */\n  mergePages(mergeConfigs) {\n    const configIds = mergeConfigs.map((config) => `${config.docId}:${config.pageIndices.join(",")}`).join("|");\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "mergePages", mergeConfigs);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, "Begin", configIds);\n    const newDocPtr = this.pdfiumModule.FPDF_CreateNewDocument();\n    if (!newDocPtr) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, "End", configIds);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantCreateNewDoc,\n        message: "Cannot create new document"\n      });\n    }\n    try {\n      for (const config of [...mergeConfigs].reverse()) {\n        const ctx = this.cache.getContext(config.docId);\n        if (!ctx) {\n          this.logger.warn(\n            LOG_SOURCE,\n            LOG_CATEGORY,\n            `Document ${config.docId} is not open, skipping`\n          );\n          continue;\n        }\n        const pageCount = this.pdfiumModule.FPDF_GetPageCount(ctx.docPtr);\n        const validPageIndices = config.pageIndices.filter(\n          (index) => index >= 0 && index < pageCount\n        );\n        if (validPageIndices.length === 0) {\n          continue;\n        }\n        const pageString = validPageIndices.map((index) => index + 1).join(",");\n        try {\n          if (!this.pdfiumModule.FPDF_ImportPages(\n            newDocPtr,\n            ctx.docPtr,\n            pageString,\n            0\n            // Insert at the beginning\n          )) {\n            throw new Error(`Failed to import pages ${pageString} from document ${config.docId}`);\n          }\n        } finally {\n        }\n      }\n      const buffer = this.saveDocument(newDocPtr);\n      const file = {\n        id: `${Math.random()}`,\n        content: buffer\n      };\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, "End", configIds);\n      return PdfTaskHelper.resolve(file);\n    } catch (error) {\n      this.logger.error(LOG_SOURCE, LOG_CATEGORY, "mergePages failed", error);\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `MergePages`, "End", configIds);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.CantImportPages,\n        message: error instanceof Error ? error.message : "Failed to merge pages"\n      });\n    } finally {\n      if (newDocPtr) {\n        this.pdfiumModule.FPDF_CloseDocument(newDocPtr);\n      }\n    }\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.saveAsCopy}\n   *\n   * @public\n   */\n  saveAsCopy(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "saveAsCopy", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SaveAsCopy`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SaveAsCopy`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const buffer = this.saveDocument(ctx.docPtr);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `SaveAsCopy`, "End", doc.id);\n    return PdfTaskHelper.resolve(buffer);\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.closeDocument}\n   *\n   * @public\n   */\n  closeDocument(doc) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "closeDocument", doc);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CloseDocument`, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CloseDocument`, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    ctx.dispose();\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, `CloseDocument`, "End", doc.id);\n    return PdfTaskHelper.resolve(true);\n  }\n  /**\n   * Memory allocation\n   * @param size - size of memory space\n   * @returns pointer to memory space\n   *\n   * @public\n   */\n  malloc(size) {\n    const ptr = this.pdfiumModule.pdfium.wasmExports.malloc(size);\n    for (let i = 0; i < size; i++) {\n      this.pdfiumModule.pdfium.HEAP8[ptr + i] = 0;\n    }\n    return ptr;\n  }\n  /**\n   * Free memory space\n   * @param ptr pointer to memory space\n   *\n   * @public\n   */\n  free(ptr) {\n    this.pdfiumModule.pdfium.wasmExports.free(ptr);\n  }\n  /**\n   * Add text content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to text annotation\n   * @param annotation - text annotation\n   * @returns whether text content is added to annotation\n   *\n   * @private\n   */\n  addTextContent(page, pagePtr, annotationPtr, annotation) {\n    if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.inReplyToId && !this.setInReplyToId(pagePtr, annotationPtr, annotation.inReplyToId)) {\n      return false;\n    }\n    if (!this.setAnnotationIcon(annotationPtr, annotation.icon || PdfAnnotationIcon.Comment)) {\n      return false;\n    }\n    if (!this.setAnnotationFlags(annotationPtr, annotation.flags || ["print", "noZoom", "noRotate"])) {\n      return false;\n    }\n    if (annotation.state && !this.setAnnotString(annotationPtr, "State", annotation.state)) {\n      return false;\n    }\n    if (annotation.stateModel && !this.setAnnotString(annotationPtr, "StateModel", annotation.stateModel)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add free text content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to free text annotation\n   * @param annotation - free text annotation\n   * @returns whether free text content is added to annotation\n   *\n   * @private\n   */\n  addFreeTextContent(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, PdfAnnotationBorderStyle.SOLID, 0)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationTextAlignment(annotationPtr, annotation.textAlign)) {\n      return false;\n    }\n    if (!this.setAnnotationVerticalAlignment(annotationPtr, annotation.verticalAlign)) {\n      return false;\n    }\n    if (!this.setAnnotationDefaultAppearance(\n      annotationPtr,\n      annotation.fontFamily,\n      annotation.fontSize,\n      annotation.fontColor\n    )) {\n      return false;\n    }\n    if (annotation.intent && !this.setAnnotIntent(annotationPtr, annotation.intent)) {\n      return false;\n    }\n    if (!annotation.backgroundColor || annotation.backgroundColor === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.Color)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.backgroundColor ?? "#FFFFFF",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Set the rect of specified annotation\n   * @param page - page info that the annotation is belonged to\n   * @param pagePtr - pointer of page object\n   * @param annotationPtr - pointer to annotation object\n   * @param inkList - ink lists that added to the annotation\n   * @returns whether the ink lists is setted\n   *\n   * @private\n   */\n  addInkStroke(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, PdfAnnotationBorderStyle.SOLID, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n      return false;\n    }\n    if (!this.setInkList(page, annotationPtr, annotation.inkList)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add line content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to line annotation\n   * @param annotation - line annotation\n   * @returns whether line content is added to annotation\n   *\n   * @private\n   */\n  addLineContent(page, pagePtr, annotationPtr, annotation) {\n    var _a, _b;\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n      return false;\n    }\n    if (!this.setLinePoints(\n      page,\n      annotationPtr,\n      annotation.linePoints.start,\n      annotation.linePoints.end\n    )) {\n      return false;\n    }\n    if (!this.setLineEndings(\n      annotationPtr,\n      ((_a = annotation.lineEndings) == null ? void 0 : _a.start) ?? PdfAnnotationLineEnding.None,\n      ((_b = annotation.lineEndings) == null ? void 0 : _b.end) ?? PdfAnnotationLineEnding.None\n    )) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, annotation.strokeStyle, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setBorderDashPattern(annotationPtr, annotation.strokeDashArray ?? [])) {\n      return false;\n    }\n    if (annotation.intent && !this.setAnnotIntent(annotationPtr, annotation.intent)) {\n      return false;\n    }\n    if (!annotation.color || annotation.color === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.InteriorColor)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.InteriorColor\n    )) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.strokeColor ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add polygon or polyline content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to polygon or polyline annotation\n   * @param annotation - polygon or polyline annotation\n   * @returns whether polygon or polyline content is added to annotation\n   *\n   * @private\n   */\n  addPolyContent(page, pagePtr, annotationPtr, annotation) {\n    var _a, _b;\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n      return false;\n    }\n    if (annotation.type === PdfAnnotationSubtype.POLYLINE && !this.setLineEndings(\n      annotationPtr,\n      ((_a = annotation.lineEndings) == null ? void 0 : _a.start) ?? PdfAnnotationLineEnding.None,\n      ((_b = annotation.lineEndings) == null ? void 0 : _b.end) ?? PdfAnnotationLineEnding.None\n    )) {\n      return false;\n    }\n    if (!this.setPdfAnnoVertices(page, annotationPtr, annotation.vertices)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, annotation.strokeStyle, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setBorderDashPattern(annotationPtr, annotation.strokeDashArray ?? [])) {\n      return false;\n    }\n    if (annotation.intent && !this.setAnnotIntent(annotationPtr, annotation.intent)) {\n      return false;\n    }\n    if (!annotation.color || annotation.color === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.InteriorColor)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.InteriorColor\n    )) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.strokeColor ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add shape content to annotation\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to shape annotation\n   * @param annotation - shape annotation\n   * @returns whether shape content is added to annotation\n   *\n   * @private\n   */\n  addShapeContent(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setBorderStyle(annotationPtr, annotation.strokeStyle, annotation.strokeWidth)) {\n      return false;\n    }\n    if (!this.setBorderDashPattern(annotationPtr, annotation.strokeDashArray ?? [])) {\n      return false;\n    }\n    if (!this.setAnnotationFlags(annotationPtr, annotation.flags)) {\n      return false;\n    }\n    if (!annotation.color || annotation.color === "transparent") {\n      if (!this.pdfiumModule.EPDFAnnot_ClearColor(annotationPtr, PdfAnnotationColorType.InteriorColor)) {\n        return false;\n      }\n    } else if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.InteriorColor\n    )) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.strokeColor ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add highlight content to annotation\n   * @param page - page info\n   * @param annotationPtr - pointer to highlight annotation\n   * @param annotation - highlight annotation\n   * @returns whether highlight content is added to annotation\n   *\n   * @private\n   */\n  addTextMarkupContent(page, pagePtr, annotationPtr, annotation) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setPageAnnoRect(page, pagePtr, annotationPtr, annotation.rect)) {\n      return false;\n    }\n    if (!this.syncQuadPointsAnno(page, annotationPtr, annotation.segmentRects)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "T", annotation.author || "")) {\n      return false;\n    }\n    if (!this.setAnnotationOpacity(annotationPtr, annotation.opacity ?? 1)) {\n      return false;\n    }\n    if (!this.setAnnotationColor(\n      annotationPtr,\n      annotation.color ?? "#FFFF00",\n      PdfAnnotationColorType.Color\n    )) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Add contents to stamp annotation\n   * @param docPtr - pointer to pdf document object\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to stamp annotation\n   * @param rect - rect of stamp annotation\n   * @param contents - contents of stamp annotation\n   * @returns whether contents is added to annotation\n   *\n   * @private\n   */\n  addStampContent(docPtr, page, pagePtr, annotationPtr, annotation, imageData) {\n    if (annotation.created && !this.setAnnotationDate(annotationPtr, "CreationDate", annotation.created)) {\n      return false;\n    }\n    if (annotation.modified && !this.setAnnotationDate(annotationPtr, "M", annotation.modified)) {\n      return false;\n    }\n    if (!this.setAnnotString(annotationPtr, "Contents", annotation.contents ?? "")) {\n      return false;\n    }\n    if (imageData) {\n      for (let i = this.pdfiumModule.FPDFAnnot_GetObjectCount(annotationPtr) - 1; i >= 0; i--) {\n        this.pdfiumModule.FPDFAnnot_RemoveObject(annotationPtr, i);\n      }\n      return this.addImageObject(\n        docPtr,\n        page,\n        pagePtr,\n        annotationPtr,\n        annotation.rect.origin,\n        imageData\n      );\n    }\n    return true;\n  }\n  /**\n   * Add image object to annotation\n   * @param docPtr - pointer to pdf document object\n   * @param page - page info\n   * @param pagePtr - pointer to page object\n   * @param annotationPtr - pointer to stamp annotation\n   * @param position - position of image\n   * @param imageData - data of image\n   * @returns whether image is added to annotation\n   *\n   * @private\n   */\n  addImageObject(docPtr, page, pagePtr, annotationPtr, position, imageData) {\n    const bytesPerPixel = 4;\n    const pixelCount = imageData.width * imageData.height;\n    const bitmapBufferPtr = this.malloc(bytesPerPixel * pixelCount);\n    if (!bitmapBufferPtr) {\n      return false;\n    }\n    for (let i = 0; i < pixelCount; i++) {\n      const red = imageData.data[i * bytesPerPixel];\n      const green = imageData.data[i * bytesPerPixel + 1];\n      const blue = imageData.data[i * bytesPerPixel + 2];\n      const alpha = imageData.data[i * bytesPerPixel + 3];\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel, blue, "i8");\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 1, green, "i8");\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 2, red, "i8");\n      this.pdfiumModule.pdfium.setValue(bitmapBufferPtr + i * bytesPerPixel + 3, alpha, "i8");\n    }\n    const format = 4;\n    const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(\n      imageData.width,\n      imageData.height,\n      format,\n      bitmapBufferPtr,\n      0\n    );\n    if (!bitmapPtr) {\n      this.free(bitmapBufferPtr);\n      return false;\n    }\n    const imageObjectPtr = this.pdfiumModule.FPDFPageObj_NewImageObj(docPtr);\n    if (!imageObjectPtr) {\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.free(bitmapBufferPtr);\n      return false;\n    }\n    if (!this.pdfiumModule.FPDFImageObj_SetBitmap(pagePtr, 0, imageObjectPtr, bitmapPtr)) {\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n      this.free(bitmapBufferPtr);\n      return false;\n    }\n    const matrixPtr = this.malloc(6 * 4);\n    this.pdfiumModule.pdfium.setValue(matrixPtr, imageData.width, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 4, 0, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 8, 0, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 12, imageData.height, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 16, 0, "float");\n    this.pdfiumModule.pdfium.setValue(matrixPtr + 20, 0, "float");\n    if (!this.pdfiumModule.FPDFPageObj_SetMatrix(imageObjectPtr, matrixPtr)) {\n      this.free(matrixPtr);\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n      this.free(bitmapBufferPtr);\n      return false;\n    }\n    this.free(matrixPtr);\n    const pagePos = this.convertDevicePointToPagePoint(page, {\n      x: position.x,\n      y: position.y + imageData.height\n      // shift down by the image height\n    });\n    this.pdfiumModule.FPDFPageObj_Transform(imageObjectPtr, 1, 0, 0, 1, pagePos.x, pagePos.y);\n    if (!this.pdfiumModule.FPDFAnnot_AppendObject(annotationPtr, imageObjectPtr)) {\n      this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n      this.pdfiumModule.FPDFPageObj_Destroy(imageObjectPtr);\n      this.free(bitmapBufferPtr);\n      return false;\n    }\n    this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n    this.free(bitmapBufferPtr);\n    return true;\n  }\n  /**\n   * Save document to array buffer\n   * @param docPtr - pointer to pdf document\n   * @returns array buffer contains the pdf content\n   *\n   * @private\n   */\n  saveDocument(docPtr) {\n    const writerPtr = this.pdfiumModule.PDFiumExt_OpenFileWriter();\n    this.pdfiumModule.PDFiumExt_SaveAsCopy(docPtr, writerPtr);\n    const size = this.pdfiumModule.PDFiumExt_GetFileWriterSize(writerPtr);\n    const dataPtr = this.malloc(size);\n    this.pdfiumModule.PDFiumExt_GetFileWriterData(writerPtr, dataPtr, size);\n    const buffer = new ArrayBuffer(size);\n    const view = new DataView(buffer);\n    for (let i = 0; i < size; i++) {\n      view.setInt8(i, this.pdfiumModule.pdfium.getValue(dataPtr + i, "i8"));\n    }\n    this.free(dataPtr);\n    this.pdfiumModule.PDFiumExt_CloseFileWriter(writerPtr);\n    return buffer;\n  }\n  /**\n   * Read metadata from pdf document\n   * @param docPtr - pointer to pdf document\n   * @param key - key of metadata field\n   * @returns metadata value\n   *\n   * @private\n   */\n  readMetaText(docPtr, key) {\n    return readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDF_GetMetaText(docPtr, key, buffer, bufferLength);\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n  }\n  /**\n   * Read bookmarks in the pdf document\n   * @param docPtr - pointer to pdf document\n   * @param rootBookmarkPtr - pointer to root bookmark\n   * @returns bookmarks in the pdf document\n   *\n   * @private\n   */\n  readPdfBookmarks(docPtr, rootBookmarkPtr = 0) {\n    let bookmarkPtr = this.pdfiumModule.FPDFBookmark_GetFirstChild(docPtr, rootBookmarkPtr);\n    const bookmarks = [];\n    while (bookmarkPtr) {\n      const bookmark = this.readPdfBookmark(docPtr, bookmarkPtr);\n      bookmarks.push(bookmark);\n      const nextBookmarkPtr = this.pdfiumModule.FPDFBookmark_GetNextSibling(docPtr, bookmarkPtr);\n      bookmarkPtr = nextBookmarkPtr;\n    }\n    return bookmarks;\n  }\n  /**\n   * Read bookmark in the pdf document\n   * @param docPtr - pointer to pdf document\n   * @param bookmarkPtr - pointer to bookmark object\n   * @returns pdf bookmark object\n   *\n   * @private\n   */\n  readPdfBookmark(docPtr, bookmarkPtr) {\n    const title = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFBookmark_GetTitle(bookmarkPtr, buffer, bufferLength);\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const bookmarks = this.readPdfBookmarks(docPtr, bookmarkPtr);\n    const target = this.readPdfBookmarkTarget(\n      docPtr,\n      () => {\n        return this.pdfiumModule.FPDFBookmark_GetAction(bookmarkPtr);\n      },\n      () => {\n        return this.pdfiumModule.FPDFBookmark_GetDest(docPtr, bookmarkPtr);\n      }\n    );\n    return {\n      title,\n      target,\n      children: bookmarks\n    };\n  }\n  /**\n   * Read text rects in pdf page\n   * @param page - pdf page info\n   * @param docPtr - pointer to pdf document\n   * @param pagePtr - pointer to pdf page\n   * @param textPagePtr - pointer to pdf text page\n   * @returns text rects in the pdf page\n   *\n   * @public\n   */\n  readPageTextRects(page, docPtr, pagePtr, textPagePtr) {\n    const rectsCount = this.pdfiumModule.FPDFText_CountRects(textPagePtr, 0, -1);\n    const textRects = [];\n    for (let i = 0; i < rectsCount; i++) {\n      const topPtr = this.malloc(8);\n      const leftPtr = this.malloc(8);\n      const rightPtr = this.malloc(8);\n      const bottomPtr = this.malloc(8);\n      const isSucceed = this.pdfiumModule.FPDFText_GetRect(\n        textPagePtr,\n        i,\n        leftPtr,\n        topPtr,\n        rightPtr,\n        bottomPtr\n      );\n      if (!isSucceed) {\n        this.free(leftPtr);\n        this.free(topPtr);\n        this.free(rightPtr);\n        this.free(bottomPtr);\n        continue;\n      }\n      const left = this.pdfiumModule.pdfium.getValue(leftPtr, "double");\n      const top = this.pdfiumModule.pdfium.getValue(topPtr, "double");\n      const right = this.pdfiumModule.pdfium.getValue(rightPtr, "double");\n      const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, "double");\n      this.free(leftPtr);\n      this.free(topPtr);\n      this.free(rightPtr);\n      this.free(bottomPtr);\n      const deviceXPtr = this.malloc(4);\n      const deviceYPtr = this.malloc(4);\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        0,\n        left,\n        top,\n        deviceXPtr,\n        deviceYPtr\n      );\n      const x = this.pdfiumModule.pdfium.getValue(deviceXPtr, "i32");\n      const y = this.pdfiumModule.pdfium.getValue(deviceYPtr, "i32");\n      this.free(deviceXPtr);\n      this.free(deviceYPtr);\n      const rect = {\n        origin: {\n          x,\n          y\n        },\n        size: {\n          width: Math.ceil(Math.abs(right - left)),\n          height: Math.ceil(Math.abs(top - bottom))\n        }\n      };\n      const utf16Length = this.pdfiumModule.FPDFText_GetBoundedText(\n        textPagePtr,\n        left,\n        top,\n        right,\n        bottom,\n        0,\n        0\n      );\n      const bytesCount = (utf16Length + 1) * 2;\n      const textBuffer = this.malloc(bytesCount);\n      this.pdfiumModule.FPDFText_GetBoundedText(\n        textPagePtr,\n        left,\n        top,\n        right,\n        bottom,\n        textBuffer,\n        utf16Length\n      );\n      const content = this.pdfiumModule.pdfium.UTF16ToString(textBuffer);\n      this.free(textBuffer);\n      const charIndex = this.pdfiumModule.FPDFText_GetCharIndexAtPos(textPagePtr, left, top, 2, 2);\n      let fontFamily = "";\n      let fontSize = rect.size.height;\n      if (charIndex >= 0) {\n        fontSize = this.pdfiumModule.FPDFText_GetFontSize(textPagePtr, charIndex);\n        const fontNameLength = this.pdfiumModule.FPDFText_GetFontInfo(\n          textPagePtr,\n          charIndex,\n          0,\n          0,\n          0\n        );\n        const bytesCount2 = fontNameLength + 1;\n        const textBufferPtr = this.malloc(bytesCount2);\n        const flagsPtr = this.malloc(4);\n        this.pdfiumModule.FPDFText_GetFontInfo(\n          textPagePtr,\n          charIndex,\n          textBufferPtr,\n          bytesCount2,\n          flagsPtr\n        );\n        fontFamily = this.pdfiumModule.pdfium.UTF8ToString(textBufferPtr);\n        this.free(textBufferPtr);\n        this.free(flagsPtr);\n      }\n      const textRect = {\n        content,\n        rect,\n        font: {\n          family: fontFamily,\n          size: fontSize\n        }\n      };\n      textRects.push(textRect);\n    }\n    return textRects;\n  }\n  /**\n   * Return geometric + logical text layout for one page\n   * (glyph-only implementation, no FPDFText_GetRect).\n   *\n   * @public\n   */\n  getPageGeometry(doc, page) {\n    const label = "getPageGeometry";\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, label, "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, label, "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const textPagePtr = pageCtx.getTextPage();\n    const glyphCount = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n    const glyphs = [];\n    for (let i = 0; i < glyphCount; i++) {\n      const g = this.readGlyphInfo(page, pageCtx.pagePtr, textPagePtr, i);\n      glyphs.push(g);\n    }\n    const runs = this.buildRunsFromGlyphs(glyphs, textPagePtr);\n    pageCtx.release();\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, label, "End", doc.id);\n    return PdfTaskHelper.resolve({ runs });\n  }\n  /**\n   * Group consecutive glyphs that belong to the same CPDF_TextObject\n   * using FPDFText_GetTextObject(), and calculate rotation from glyph positions.\n   */\n  buildRunsFromGlyphs(glyphs, textPagePtr) {\n    const runs = [];\n    let current = null;\n    let curObjPtr = null;\n    let bounds = null;\n    for (let i = 0; i < glyphs.length; i++) {\n      const g = glyphs[i];\n      const objPtr = this.pdfiumModule.FPDFText_GetTextObject(textPagePtr, i);\n      if (objPtr !== curObjPtr) {\n        curObjPtr = objPtr;\n        current = {\n          rect: {\n            x: g.origin.x,\n            y: g.origin.y,\n            width: g.size.width,\n            height: g.size.height\n          },\n          charStart: i,\n          glyphs: []\n        };\n        bounds = {\n          minX: g.origin.x,\n          minY: g.origin.y,\n          maxX: g.origin.x + g.size.width,\n          maxY: g.origin.y + g.size.height\n        };\n        runs.push(current);\n      }\n      current.glyphs.push({\n        x: g.origin.x,\n        y: g.origin.y,\n        width: g.size.width,\n        height: g.size.height,\n        flags: g.isEmpty ? 2 : g.isSpace ? 1 : 0\n      });\n      if (g.isEmpty) {\n        continue;\n      }\n      const right = g.origin.x + g.size.width;\n      const bottom = g.origin.y + g.size.height;\n      bounds.minX = Math.min(bounds.minX, g.origin.x);\n      bounds.minY = Math.min(bounds.minY, g.origin.y);\n      bounds.maxX = Math.max(bounds.maxX, right);\n      bounds.maxY = Math.max(bounds.maxY, bottom);\n      current.rect.x = bounds.minX;\n      current.rect.y = bounds.minY;\n      current.rect.width = bounds.maxX - bounds.minX;\n      current.rect.height = bounds.maxY - bounds.minY;\n    }\n    return runs;\n  }\n  /**\n   * Extract glyph geometry + metadata for `charIndex`\n   *\n   * Returns device–space coordinates:\n   *   x,y  → **top-left** corner (integer-pixels)\n   *   w,h  → width / height (integer-pixels, ≥ 1)\n   *\n   * And two flags:\n   *   isSpace → true if the glyph\'s Unicode code-point is U+0020\n   */\n  readGlyphInfo(page, pagePtr, textPagePtr, charIndex) {\n    const dx1Ptr = this.malloc(4);\n    const dy1Ptr = this.malloc(4);\n    const dx2Ptr = this.malloc(4);\n    const dy2Ptr = this.malloc(4);\n    const rectPtr = this.malloc(16);\n    let x = 0, y = 0, width = 0, height = 0, isSpace = false;\n    if (this.pdfiumModule.FPDFText_GetLooseCharBox(textPagePtr, charIndex, rectPtr)) {\n      const left = this.pdfiumModule.pdfium.getValue(rectPtr, "float");\n      const top = this.pdfiumModule.pdfium.getValue(rectPtr + 4, "float");\n      const right = this.pdfiumModule.pdfium.getValue(rectPtr + 8, "float");\n      const bottom = this.pdfiumModule.pdfium.getValue(rectPtr + 12, "float");\n      if (left === right || top === bottom) {\n        return {\n          origin: { x: 0, y: 0 },\n          size: { width: 0, height: 0 },\n          isEmpty: true\n        };\n      }\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        /*rotate=*/\n        0,\n        left,\n        top,\n        dx1Ptr,\n        dy1Ptr\n      );\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        /*rotate=*/\n        0,\n        right,\n        bottom,\n        dx2Ptr,\n        dy2Ptr\n      );\n      const x1 = this.pdfiumModule.pdfium.getValue(dx1Ptr, "i32");\n      const y1 = this.pdfiumModule.pdfium.getValue(dy1Ptr, "i32");\n      const x2 = this.pdfiumModule.pdfium.getValue(dx2Ptr, "i32");\n      const y2 = this.pdfiumModule.pdfium.getValue(dy2Ptr, "i32");\n      x = Math.min(x1, x2);\n      y = Math.min(y1, y2);\n      width = Math.max(1, Math.abs(x2 - x1));\n      height = Math.max(1, Math.abs(y2 - y1));\n      const uc = this.pdfiumModule.FPDFText_GetUnicode(textPagePtr, charIndex);\n      isSpace = uc === 32;\n    }\n    [rectPtr, dx1Ptr, dy1Ptr, dx2Ptr, dy2Ptr].forEach((p) => this.free(p));\n    return {\n      origin: { x, y },\n      size: { width, height },\n      ...isSpace && { isSpace }\n    };\n  }\n  /**\n   * Geometry-only text extraction\n   * ------------------------------------------\n   * Returns every glyph on the requested page\n   * in the logical order delivered by PDFium.\n   *\n   * The promise resolves to an array of objects:\n   *   {\n   *     idx:     number;            // glyph index on the page (0…n-1)\n   *     origin:  { x: number; y: number };\n   *     size:    { width: number;  height: number };\n   *     angle:   number;            // degrees, counter-clock-wise\n   *     isSpace: boolean;           // true  → U+0020\n   *   }\n   *\n   * No Unicode is included; front-end decides whether to hydrate it.\n   */\n  getPageGlyphs(doc, page) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "getPageGlyphs", doc, page);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "getPageGlyphs", "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "getPageGlyphs", "End", doc.id);\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const textPagePtr = pageCtx.getTextPage();\n    const total = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n    const glyphs = new Array(total);\n    for (let i = 0; i < total; i++) {\n      const g = this.readGlyphInfo(page, pageCtx.pagePtr, textPagePtr, i);\n      if (g.isEmpty) {\n        continue;\n      }\n      glyphs[i] = { ...g };\n    }\n    pageCtx.release();\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "getPageGlyphs", "End", doc.id);\n    return PdfTaskHelper.resolve(glyphs);\n  }\n  readCharBox(page, pagePtr, textPagePtr, charIndex) {\n    const topPtr = this.malloc(8);\n    const leftPtr = this.malloc(8);\n    const bottomPtr = this.malloc(8);\n    const rightPtr = this.malloc(8);\n    let x = 0;\n    let y = 0;\n    let width = 0;\n    let height = 0;\n    if (this.pdfiumModule.FPDFText_GetCharBox(\n      textPagePtr,\n      charIndex,\n      leftPtr,\n      rightPtr,\n      bottomPtr,\n      topPtr\n    )) {\n      const top = this.pdfiumModule.pdfium.getValue(topPtr, "double");\n      const left = this.pdfiumModule.pdfium.getValue(leftPtr, "double");\n      const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, "double");\n      const right = this.pdfiumModule.pdfium.getValue(rightPtr, "double");\n      const deviceXPtr = this.malloc(4);\n      const deviceYPtr = this.malloc(4);\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        0,\n        left,\n        top,\n        deviceXPtr,\n        deviceYPtr\n      );\n      x = this.pdfiumModule.pdfium.getValue(deviceXPtr, "i32");\n      y = this.pdfiumModule.pdfium.getValue(deviceYPtr, "i32");\n      this.free(deviceXPtr);\n      this.free(deviceYPtr);\n      width = Math.ceil(Math.abs(right - left));\n      height = Math.ceil(Math.abs(top - bottom));\n    }\n    this.free(topPtr);\n    this.free(leftPtr);\n    this.free(bottomPtr);\n    this.free(rightPtr);\n    return {\n      origin: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    };\n  }\n  /**\n   * Read page annotations\n   * @param page - page info\n   * @param docPtr - pointer to pdf document\n   * @param pagePtr - pointer to pdf page\n   * @param textPagePtr - pointe to pdf text page\n   * @param scaleFactor - scale factor\n   * @param rotation - rotation angle\n   * @returns annotations on the pdf page\n   *\n   * @private\n   */\n  readPageAnnotations(ctx, page) {\n    return ctx.borrowPage(page.index, (pageCtx) => {\n      const annotationCount = this.pdfiumModule.FPDFPage_GetAnnotCount(pageCtx.pagePtr);\n      const annotations = [];\n      for (let i = 0; i < annotationCount; i++) {\n        pageCtx.withAnnotation(i, (annotPtr) => {\n          const anno = this.readPageAnnotation(ctx.docPtr, page, annotPtr, pageCtx);\n          if (anno) annotations.push(anno);\n        });\n      }\n      return annotations;\n    });\n  }\n  readPageAnnotationsRaw(ctx, page) {\n    const count = this.pdfiumModule.EPDFPage_GetAnnotCountRaw(ctx.docPtr, page.index);\n    if (count <= 0) return [];\n    const out = [];\n    for (let i = 0; i < count; ++i) {\n      const annotPtr = this.pdfiumModule.EPDFPage_GetAnnotRaw(ctx.docPtr, page.index, i);\n      if (!annotPtr) continue;\n      try {\n        const anno = this.readPageAnnotation(ctx.docPtr, page, annotPtr);\n        if (anno) out.push(anno);\n      } finally {\n        this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n      }\n    }\n    return out;\n  }\n  /**\n   * Read pdf annotation from pdf document\n   * @param page  - pdf page infor\n   * @param docPtr - pointer to pdf document object\n   * @param pagePtr - pointer to pdf page object\n   * @param  textPagePtr - pointer to pdf text page object\n   * @param formHandle - form handle\n   * @param index - index of annotation in the pdf page\n   * @param scaleFactor  - factor of scalling\n   * @param rotation  - rotation angle\n   * @returns pdf annotation\n   *\n   * @private\n   */\n  readPageAnnotation(docPtr, page, annotationPtr, pageCtx) {\n    let index = this.getAnnotString(annotationPtr, "NM");\n    if (!index || !isUuidV4(index)) {\n      index = uuidV4();\n      this.setAnnotString(annotationPtr, "NM", index);\n    }\n    const subType = this.pdfiumModule.FPDFAnnot_GetSubtype(\n      annotationPtr\n    );\n    let annotation;\n    switch (subType) {\n      case PdfAnnotationSubtype.TEXT:\n        {\n          annotation = this.readPdfTextAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.FREETEXT:\n        {\n          annotation = this.readPdfFreeTextAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.LINK:\n        {\n          annotation = this.readPdfLinkAnno(page, docPtr, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.WIDGET:\n        if (pageCtx) {\n          return this.readPdfWidgetAnno(page, annotationPtr, pageCtx.getFormHandle(), index);\n        }\n      case PdfAnnotationSubtype.FILEATTACHMENT:\n        {\n          annotation = this.readPdfFileAttachmentAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.INK:\n        {\n          annotation = this.readPdfInkAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.POLYGON:\n        {\n          annotation = this.readPdfPolygonAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.POLYLINE:\n        {\n          annotation = this.readPdfPolylineAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.LINE:\n        {\n          annotation = this.readPdfLineAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.HIGHLIGHT:\n        annotation = this.readPdfHighlightAnno(page, annotationPtr, index);\n        break;\n      case PdfAnnotationSubtype.STAMP:\n        {\n          annotation = this.readPdfStampAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.SQUARE:\n        {\n          annotation = this.readPdfSquareAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.CIRCLE:\n        {\n          annotation = this.readPdfCircleAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.UNDERLINE:\n        {\n          annotation = this.readPdfUnderlineAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.SQUIGGLY:\n        {\n          annotation = this.readPdfSquigglyAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.STRIKEOUT:\n        {\n          annotation = this.readPdfStrikeOutAnno(page, annotationPtr, index);\n        }\n        break;\n      case PdfAnnotationSubtype.CARET:\n        {\n          annotation = this.readPdfCaretAnno(page, annotationPtr, index);\n        }\n        break;\n      default:\n        {\n          annotation = this.readPdfAnno(page, subType, annotationPtr, index);\n        }\n        break;\n    }\n    return annotation;\n  }\n  /**\n   * Return the colour stored directly in the annotation dictionary\'s `/C` entry.\n   *\n   * Most PDFs created by Acrobat, Microsoft Office, LaTeX, etc. include this entry.\n   * When the key is absent (common in macOS Preview, Chrome, Drawboard) the call\n   * fails and the function returns `undefined`.\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @returns An RGBA tuple (0-255 channels) or `undefined` if no `/C` entry exists\n   *\n   * @private\n   */\n  readAnnotationColor(annotationPtr, colorType = PdfAnnotationColorType.Color) {\n    const rPtr = this.malloc(4);\n    const gPtr = this.malloc(4);\n    const bPtr = this.malloc(4);\n    const ok = this.pdfiumModule.EPDFAnnot_GetColor(annotationPtr, colorType, rPtr, gPtr, bPtr);\n    let colour;\n    if (ok) {\n      colour = {\n        red: this.pdfiumModule.pdfium.getValue(rPtr, "i32") & 255,\n        green: this.pdfiumModule.pdfium.getValue(gPtr, "i32") & 255,\n        blue: this.pdfiumModule.pdfium.getValue(bPtr, "i32") & 255\n      };\n    }\n    this.free(rPtr);\n    this.free(gPtr);\n    this.free(bPtr);\n    return colour;\n  }\n  /**\n   * Get the fill/stroke colour annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose colour is being set\n   * @param colorType - which colour to get (0 = fill, 1 = stroke)\n   * @returns WebColor with hex color\n   *\n   * @private\n   */\n  getAnnotationColor(annotationPtr, colorType = PdfAnnotationColorType.Color) {\n    const annotationColor = this.readAnnotationColor(annotationPtr, colorType);\n    return annotationColor ? pdfColorToWebColor(annotationColor) : void 0;\n  }\n  /**\n   * Set the fill/stroke colour for a **Highlight / Underline / StrikeOut / Squiggly** markup annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose colour is being set\n   * @param webAlphaColor - WebAlphaColor with hex color and opacity (0-1)\n   * @param shouldClearAP - whether to clear the /AP entry\n   * @param which - which colour to set (0 = fill, 1 = stroke)\n   * @returns `true` if the operation was successful\n   *\n   * @private\n   */\n  setAnnotationColor(annotationPtr, webColor, colorType = PdfAnnotationColorType.Color) {\n    const pdfColor = webColorToPdfColor(webColor);\n    return this.pdfiumModule.EPDFAnnot_SetColor(\n      annotationPtr,\n      colorType,\n      pdfColor.red & 255,\n      pdfColor.green & 255,\n      pdfColor.blue & 255\n    );\n  }\n  /**\n   * Get the opacity of the annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose opacity is being set\n   * @returns opacity (0-1)\n   *\n   * @private\n   */\n  getAnnotationOpacity(annotationPtr) {\n    const opacityPtr = this.malloc(4);\n    const ok = this.pdfiumModule.EPDFAnnot_GetOpacity(annotationPtr, opacityPtr);\n    const opacity = ok ? this.pdfiumModule.pdfium.getValue(opacityPtr, "i32") : 255;\n    this.free(opacityPtr);\n    return pdfAlphaToWebOpacity(opacity);\n  }\n  /**\n   * Set the opacity of the annotation.\n   *\n   * @param annotationPtr - pointer to the annotation whose opacity is being set\n   * @param opacity - opacity (0-1)\n   * @returns true on success\n   *\n   * @private\n   */\n  setAnnotationOpacity(annotationPtr, opacity) {\n    const pdfOpacity = webOpacityToPdfAlpha(opacity);\n    return this.pdfiumModule.EPDFAnnot_SetOpacity(annotationPtr, pdfOpacity & 255);\n  }\n  /**\n   * Fetch the `/Q` text-alignment value from a **FreeText** annotation.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @returns `PdfTextAlignment`\n   */\n  getAnnotationTextAlignment(annotationPtr) {\n    return this.pdfiumModule.EPDFAnnot_GetTextAlignment(annotationPtr);\n  }\n  /**\n   * Write the `/Q` text-alignment value into a **FreeText** annotation\n   * and clear the existing appearance stream so it can be regenerated.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @param alignment     `PdfTextAlignment`\n   * @returns `true` on success\n   */\n  setAnnotationTextAlignment(annotationPtr, alignment) {\n    return !!this.pdfiumModule.EPDFAnnot_SetTextAlignment(annotationPtr, alignment);\n  }\n  /**\n   * Fetch the `/EPDF:VerticalAlignment` vertical-alignment value from a **FreeText** annotation.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @returns `PdfVerticalAlignment`\n   */\n  getAnnotationVerticalAlignment(annotationPtr) {\n    return this.pdfiumModule.EPDFAnnot_GetVerticalAlignment(annotationPtr);\n  }\n  /**\n   * Write the `/EPDF:VerticalAlignment` vertical-alignment value into a **FreeText** annotation\n   * and clear the existing appearance stream so it can be regenerated.\n   *\n   * @param annotationPtr pointer returned by `FPDFPage_GetAnnot`\n   * @param alignment     `PdfVerticalAlignment`\n   * @returns `true` on success\n   */\n  setAnnotationVerticalAlignment(annotationPtr, alignment) {\n    return !!this.pdfiumModule.EPDFAnnot_SetVerticalAlignment(annotationPtr, alignment);\n  }\n  /**\n   * Return the **default appearance** (font, size, colour) declared in the\n   * `/DA` string of a **FreeText** annotation.\n   *\n   * @param annotationPtr  pointer to `FPDF_ANNOTATION`\n   * @returns `{ font, fontSize, color }` or `undefined` when PDFium returns false\n   *\n   * NOTE – `font` is the raw `FPDF_STANDARD_FONT` enum value that PDFium uses\n   *        (same range as the C API: 0 = Courier, 12 = ZapfDingbats, …).\n   */\n  getAnnotationDefaultAppearance(annotationPtr) {\n    const fontPtr = this.malloc(4);\n    const sizePtr = this.malloc(4);\n    const rPtr = this.malloc(4);\n    const gPtr = this.malloc(4);\n    const bPtr = this.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetDefaultAppearance(\n      annotationPtr,\n      fontPtr,\n      sizePtr,\n      rPtr,\n      gPtr,\n      bPtr\n    );\n    if (!ok) {\n      [fontPtr, sizePtr, rPtr, gPtr, bPtr].forEach((p) => this.free(p));\n      return;\n    }\n    const pdf = this.pdfiumModule.pdfium;\n    const font = pdf.getValue(fontPtr, "i32");\n    const fontSize = pdf.getValue(sizePtr, "float");\n    const red = pdf.getValue(rPtr, "i32") & 255;\n    const green = pdf.getValue(gPtr, "i32") & 255;\n    const blue = pdf.getValue(bPtr, "i32") & 255;\n    [fontPtr, sizePtr, rPtr, gPtr, bPtr].forEach((p) => this.free(p));\n    return {\n      fontFamily: font,\n      fontSize,\n      fontColor: pdfColorToWebColor({ red, green, blue })\n    };\n  }\n  /**\n   * Write a **default appearance** (`/DA`) into a FreeText annotation.\n   *\n   * @param annotationPtr pointer to `FPDF_ANNOTATION`\n   * @param font          `FPDF_STANDARD_FONT` enum value\n   * @param fontSize      size in points (≥ 0)\n   * @param color         CSS-style `#rrggbb` string (alpha ignored)\n   * @returns `true` on success\n   */\n  setAnnotationDefaultAppearance(annotationPtr, font, fontSize, color) {\n    const { red, green, blue } = webColorToPdfColor(color);\n    return !!this.pdfiumModule.EPDFAnnot_SetDefaultAppearance(\n      annotationPtr,\n      font,\n      fontSize,\n      red & 255,\n      green & 255,\n      blue & 255\n    );\n  }\n  /**\n   * Border‐style + width helper\n   *\n   * Tries the new PDFium helper `EPDFAnnot_GetBorderStyle()` (patch series\n   * 9 July 2025).\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, style, width }`\n   *          • `ok`     – `true` when the call succeeded\n   *          • `style`  – `PdfAnnotationBorderStyle` enum\n   *          • `width`  – stroke-width in points (defaults to 0 pt)\n   */\n  getBorderStyle(annotationPtr) {\n    const widthPtr = this.malloc(4);\n    let width = 0;\n    let style = PdfAnnotationBorderStyle.UNKNOWN;\n    let ok = false;\n    style = this.pdfiumModule.EPDFAnnot_GetBorderStyle(annotationPtr, widthPtr);\n    width = this.pdfiumModule.pdfium.getValue(widthPtr, "float");\n    ok = style !== PdfAnnotationBorderStyle.UNKNOWN;\n    this.free(widthPtr);\n    return { ok, style, width };\n  }\n  setBorderStyle(annotationPtr, style, width) {\n    return this.pdfiumModule.EPDFAnnot_SetBorderStyle(annotationPtr, style, width);\n  }\n  /**\n   * Get the icon of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @returns `PdfAnnotationIcon`\n   */\n  getAnnotationIcon(annotationPtr) {\n    return this.pdfiumModule.EPDFAnnot_GetIcon(annotationPtr);\n  }\n  /**\n   * Set the icon of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param icon - `PdfAnnotationIcon`\n   * @returns `true` on success\n   */\n  setAnnotationIcon(annotationPtr, icon) {\n    return this.pdfiumModule.EPDFAnnot_SetIcon(annotationPtr, icon);\n  }\n  /**\n   * Border-effect (“cloudy”) helper\n   *\n   * Calls the new PDFium function `EPDFAnnot_GetBorderEffect()` (July 2025).\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, intensity }`\n   *          • `ok`        – `true` when the annotation *does* have a\n   *                          valid cloudy-border effect\n   *          • `intensity` – radius/intensity value (0 when `ok` is false)\n   */\n  getBorderEffect(annotationPtr) {\n    const intensityPtr = this.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetBorderEffect(annotationPtr, intensityPtr);\n    const intensity = ok ? this.pdfiumModule.pdfium.getValue(intensityPtr, "float") : 0;\n    this.free(intensityPtr);\n    return { ok, intensity };\n  }\n  /**\n   * Rectangle-differences helper ( /RD array on Square / Circle annots )\n   *\n   * Calls `EPDFAnnot_GetRectangleDifferences()` introduced in July 2025.\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, left, top, right, bottom }`\n   *          • `ok`     – `true` when the annotation *has* an /RD entry\n   *          • the four floats are 0 when `ok` is false\n   */\n  getRectangleDifferences(annotationPtr) {\n    const lPtr = this.malloc(4);\n    const tPtr = this.malloc(4);\n    const rPtr = this.malloc(4);\n    const bPtr = this.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetRectangleDifferences(\n      annotationPtr,\n      lPtr,\n      tPtr,\n      rPtr,\n      bPtr\n    );\n    const pdf = this.pdfiumModule.pdfium;\n    const left = pdf.getValue(lPtr, "float");\n    const top = pdf.getValue(tPtr, "float");\n    const right = pdf.getValue(rPtr, "float");\n    const bottom = pdf.getValue(bPtr, "float");\n    this.free(lPtr);\n    this.free(tPtr);\n    this.free(rPtr);\n    this.free(bPtr);\n    return { ok, left, top, right, bottom };\n  }\n  /**\n   * Get the date of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param key - \'M\' for modified date, \'CreationDate\' for creation date\n   * @returns `Date` or `undefined` when PDFium can\'t read the date\n   */\n  getAnnotationDate(annotationPtr, key) {\n    const raw = this.getAnnotString(annotationPtr, key);\n    return raw ? pdfDateToDate(raw) : void 0;\n  }\n  /**\n   * Set the date of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param key - \'M\' for modified date, \'CreationDate\' for creation date\n   * @param date - `Date` to set\n   * @returns `true` on success\n   */\n  setAnnotationDate(annotationPtr, key, date) {\n    const raw = dateToPdfDate(date);\n    return this.setAnnotString(annotationPtr, key, raw);\n  }\n  /**\n   * Dash-pattern helper ( /BS → /D array, dashed borders only )\n   *\n   * Uses the two new PDFium helpers:\n   *   • `EPDFAnnot_GetBorderDashPatternCount`\n   *   • `EPDFAnnot_GetBorderDashPattern`\n   *\n   * @param  annotationPtr  pointer to an `FPDF_ANNOTATION`\n   * @returns `{ ok, pattern }`\n   *          • `ok`       – `true` when the annot is dashed *and* the array\n   *                          was retrieved successfully\n   *          • `pattern`  – numeric array of dash/space lengths (empty when `ok` is false)\n   */\n  getBorderDashPattern(annotationPtr) {\n    const count = this.pdfiumModule.EPDFAnnot_GetBorderDashPatternCount(annotationPtr);\n    if (count === 0) {\n      return { ok: false, pattern: [] };\n    }\n    const arrPtr = this.malloc(4 * count);\n    const okNative = !!this.pdfiumModule.EPDFAnnot_GetBorderDashPattern(\n      annotationPtr,\n      arrPtr,\n      count\n    );\n    const pattern = [];\n    if (okNative) {\n      const pdf = this.pdfiumModule.pdfium;\n      for (let i = 0; i < count; i++) {\n        pattern.push(pdf.getValue(arrPtr + 4 * i, "float"));\n      }\n    }\n    this.free(arrPtr);\n    return { ok: okNative, pattern };\n  }\n  /**\n   * Write the /BS /D dash pattern array for an annotation border.\n   *\n   * @param annotationPtr Pointer to FPDF_ANNOTATION\n   * @param pattern       Array of dash/space lengths in *points* (e.g. [3, 2])\n   *                      Empty array clears the pattern (solid line).\n   * @returns true on success\n   *\n   * @private\n   */\n  setBorderDashPattern(annotationPtr, pattern) {\n    if (!pattern || pattern.length === 0) {\n      return this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(annotationPtr, 0, 0);\n    }\n    const clean = pattern.map((n) => Number.isFinite(n) && n > 0 ? n : 0).filter((n) => n > 0);\n    if (clean.length === 0) {\n      return this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(annotationPtr, 0, 0);\n    }\n    const bytes = 4 * clean.length;\n    const bufPtr = this.malloc(bytes);\n    for (let i = 0; i < clean.length; i++) {\n      this.pdfiumModule.pdfium.setValue(bufPtr + 4 * i, clean[i], "float");\n    }\n    const ok = !!this.pdfiumModule.EPDFAnnot_SetBorderDashPattern(\n      annotationPtr,\n      bufPtr,\n      clean.length\n    );\n    this.free(bufPtr);\n    return ok;\n  }\n  /**\n   * Return the `/LE` array (start/end line-ending styles) for a LINE / POLYLINE annot.\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @returns `{ start, end }` or `undefined` when PDFium can\'t read them\n   *\n   * @private\n   */\n  getLineEndings(annotationPtr) {\n    const startPtr = this.malloc(4);\n    const endPtr = this.malloc(4);\n    const ok = !!this.pdfiumModule.EPDFAnnot_GetLineEndings(annotationPtr, startPtr, endPtr);\n    if (!ok) {\n      this.free(startPtr);\n      this.free(endPtr);\n      return void 0;\n    }\n    const start = this.pdfiumModule.pdfium.getValue(startPtr, "i32");\n    const end = this.pdfiumModule.pdfium.getValue(endPtr, "i32");\n    this.free(startPtr);\n    this.free(endPtr);\n    return { start, end };\n  }\n  /**\n   * Write the `/LE` array (start/end line-ending styles) for a LINE / POLYLINE annot.\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param start - start line ending style\n   * @param end - end line ending style\n   * @returns `true` on success\n   */\n  setLineEndings(annotationPtr, start, end) {\n    return !!this.pdfiumModule.EPDFAnnot_SetLineEndings(annotationPtr, start, end);\n  }\n  /**\n   * Get the start and end points of a LINE / POLYLINE annot.\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param page - logical page info object (`PdfPageObject`)\n   * @returns `{ start, end }` or `undefined` when PDFium can\'t read them\n   */\n  getLinePoints(annotationPtr, page) {\n    const startPointPtr = this.malloc(8);\n    const endPointPtr = this.malloc(8);\n    this.pdfiumModule.FPDFAnnot_GetLine(annotationPtr, startPointPtr, endPointPtr);\n    const startPointX = this.pdfiumModule.pdfium.getValue(startPointPtr, "float");\n    const startPointY = this.pdfiumModule.pdfium.getValue(startPointPtr + 4, "float");\n    const start = this.convertPagePointToDevicePoint(page, {\n      x: startPointX,\n      y: startPointY\n    });\n    const endPointX = this.pdfiumModule.pdfium.getValue(endPointPtr, "float");\n    const endPointY = this.pdfiumModule.pdfium.getValue(endPointPtr + 4, "float");\n    const end = this.convertPagePointToDevicePoint(page, {\n      x: endPointX,\n      y: endPointY\n    });\n    this.free(startPointPtr);\n    this.free(endPointPtr);\n    return { start, end };\n  }\n  /**\n   * Set the two end‑points of a **Line** annotation\n   * by writing a new /L array `[ x1 y1 x2 y2 ]`.\n   * @param page - logical page info object (`PdfPageObject`)\n   * @param annotPtr - pointer to the annotation whose line points are needed\n   * @param start - start point\n   * @param end - end point\n   * @returns true on success\n   */\n  setLinePoints(page, annotPtr, start, end) {\n    const buf = this.malloc(16);\n    const p1 = this.convertDevicePointToPagePoint(page, start);\n    const p2 = this.convertDevicePointToPagePoint(page, end);\n    this.pdfiumModule.pdfium.setValue(buf + 0, p1.x, "float");\n    this.pdfiumModule.pdfium.setValue(buf + 4, p1.y, "float");\n    this.pdfiumModule.pdfium.setValue(buf + 8, p2.x, "float");\n    this.pdfiumModule.pdfium.setValue(buf + 12, p2.y, "float");\n    const ok = this.pdfiumModule.EPDFAnnot_SetLine(annotPtr, buf, buf + 8);\n    this.free(buf);\n    return ok;\n  }\n  /**\n   * Read `/QuadPoints` from any annotation and convert each quadrilateral to\n   * device-space coordinates.\n   *\n   * The four points are returned in natural reading order:\n   *   `p1 → p2` (top edge) and `p4 → p3` (bottom edge).\n   * This preserves the true shape for rotated / skewed text, whereas callers\n   * that only need axis-aligned boxes can collapse each quad themselves.\n   *\n   * @param page          - logical page info object (`PdfPageObject`)\n   * @param annotationPtr - pointer to the annotation whose quads are needed\n   * @returns Array of `Rect` objects (`[]` if the annotation has no quads)\n   *\n   * @private\n   */\n  getQuadPointsAnno(page, annotationPtr) {\n    const quadCount = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(annotationPtr);\n    if (quadCount === 0) return [];\n    const FS_QUADPOINTSF_SIZE = 8 * 4;\n    const quads = [];\n    for (let qi = 0; qi < quadCount; qi++) {\n      const quadPtr = this.malloc(FS_QUADPOINTSF_SIZE);\n      const ok = this.pdfiumModule.FPDFAnnot_GetAttachmentPoints(annotationPtr, qi, quadPtr);\n      if (ok) {\n        const xs = [];\n        const ys = [];\n        for (let i = 0; i < 4; i++) {\n          const base = quadPtr + i * 8;\n          xs.push(this.pdfiumModule.pdfium.getValue(base, "float"));\n          ys.push(this.pdfiumModule.pdfium.getValue(base + 4, "float"));\n        }\n        const p1 = this.convertPagePointToDevicePoint(page, { x: xs[0], y: ys[0] });\n        const p2 = this.convertPagePointToDevicePoint(page, { x: xs[1], y: ys[1] });\n        const p3 = this.convertPagePointToDevicePoint(page, { x: xs[2], y: ys[2] });\n        const p4 = this.convertPagePointToDevicePoint(page, { x: xs[3], y: ys[3] });\n        quads.push({ p1, p2, p3, p4 });\n      }\n      this.free(quadPtr);\n    }\n    return quads.map(quadToRect);\n  }\n  /**\n   * Set the quadrilaterals for a **Highlight / Underline / StrikeOut / Squiggly** markup annotation.\n   *\n   * @param page          - logical page info object (`PdfPageObject`)\n   * @param annotationPtr - pointer to the annotation whose quads are needed\n   * @param rects         - array of `Rect` objects (`[]` if the annotation has no quads)\n   * @returns `true` if the operation was successful\n   *\n   * @private\n   */\n  syncQuadPointsAnno(page, annotPtr, rects) {\n    const FS_QUADPOINTSF_SIZE = 8 * 4;\n    const pdf = this.pdfiumModule.pdfium;\n    const count = this.pdfiumModule.FPDFAnnot_CountAttachmentPoints(annotPtr);\n    const buf = this.malloc(FS_QUADPOINTSF_SIZE);\n    const writeQuad = (r) => {\n      const q = rectToQuad(r);\n      const p1 = this.convertDevicePointToPagePoint(page, q.p1);\n      const p2 = this.convertDevicePointToPagePoint(page, q.p2);\n      const p3 = this.convertDevicePointToPagePoint(page, q.p3);\n      const p4 = this.convertDevicePointToPagePoint(page, q.p4);\n      pdf.setValue(buf + 0, p1.x, "float");\n      pdf.setValue(buf + 4, p1.y, "float");\n      pdf.setValue(buf + 8, p2.x, "float");\n      pdf.setValue(buf + 12, p2.y, "float");\n      pdf.setValue(buf + 16, p4.x, "float");\n      pdf.setValue(buf + 20, p4.y, "float");\n      pdf.setValue(buf + 24, p3.x, "float");\n      pdf.setValue(buf + 28, p3.y, "float");\n    };\n    const min = Math.min(count, rects.length);\n    for (let i = 0; i < min; i++) {\n      writeQuad(rects[i]);\n      if (!this.pdfiumModule.FPDFAnnot_SetAttachmentPoints(annotPtr, i, buf)) {\n        this.free(buf);\n        return false;\n      }\n    }\n    for (let i = count; i < rects.length; i++) {\n      writeQuad(rects[i]);\n      if (!this.pdfiumModule.FPDFAnnot_AppendAttachmentPoints(annotPtr, buf)) {\n        this.free(buf);\n        return false;\n      }\n    }\n    this.free(buf);\n    return true;\n  }\n  /**\n   * Read ink list from annotation\n   * @param page  - logical page info object (`PdfPageObject`)\n   * @param annotationPtr - pointer to the annotation whose ink list is needed\n   * @returns ink list\n   */\n  getInkList(page, annotationPtr) {\n    const inkList = [];\n    const count = this.pdfiumModule.FPDFAnnot_GetInkListCount(annotationPtr);\n    for (let i = 0; i < count; i++) {\n      const points = [];\n      const pointsCount = this.pdfiumModule.FPDFAnnot_GetInkListPath(annotationPtr, i, 0, 0);\n      if (pointsCount > 0) {\n        const pointMemorySize = 8;\n        const pointsPtr = this.malloc(pointsCount * pointMemorySize);\n        this.pdfiumModule.FPDFAnnot_GetInkListPath(annotationPtr, i, pointsPtr, pointsCount);\n        for (let j = 0; j < pointsCount; j++) {\n          const pointX = this.pdfiumModule.pdfium.getValue(pointsPtr + j * 8, "float");\n          const pointY = this.pdfiumModule.pdfium.getValue(pointsPtr + j * 8 + 4, "float");\n          const { x, y } = this.convertPagePointToDevicePoint(page, {\n            x: pointX,\n            y: pointY\n          });\n          points.push({ x, y });\n        }\n        this.free(pointsPtr);\n      }\n      inkList.push({ points });\n    }\n    return inkList;\n  }\n  /**\n   * Add ink list to annotation\n   * @param page  - logical page info object (`PdfPageObject`)\n   * @param annotationPtr - pointer to the annotation whose ink list is needed\n   * @param annotation - annotation object (`PdfInkAnnoObject`)\n   * @returns `true` if the operation was successful\n   */\n  setInkList(page, annotationPtr, inkList) {\n    for (const inkStroke of inkList) {\n      const inkPointsCount = inkStroke.points.length;\n      const inkPointsPtr = this.malloc(inkPointsCount * 8);\n      for (let i = 0; i < inkPointsCount; i++) {\n        const point = inkStroke.points[i];\n        const { x, y } = this.convertDevicePointToPagePoint(page, point);\n        this.pdfiumModule.pdfium.setValue(inkPointsPtr + i * 8, x, "float");\n        this.pdfiumModule.pdfium.setValue(inkPointsPtr + i * 8 + 4, y, "float");\n      }\n      if (this.pdfiumModule.FPDFAnnot_AddInkStroke(annotationPtr, inkPointsPtr, inkPointsCount) === -1) {\n        this.free(inkPointsPtr);\n        return false;\n      }\n      this.free(inkPointsPtr);\n    }\n    return true;\n  }\n  /**\n   * Read pdf text annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf text annotation\n   *\n   * @private\n   */\n  readPdfTextAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const annoRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, annoRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const state = this.getAnnotString(annotationPtr, "State");\n    const stateModel = this.getAnnotString(annotationPtr, "StateModel");\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const inReplyToId = this.getInReplyToId(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const icon = this.getAnnotationIcon(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.TEXT,\n      flags,\n      contents,\n      color: color ?? "#FFFF00",\n      opacity,\n      rect,\n      inReplyToId,\n      author,\n      modified,\n      created,\n      state,\n      stateModel,\n      icon\n    };\n  }\n  /**\n   * Read pdf freetext annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf freetext annotation\n   *\n   * @private\n   */\n  readPdfFreeTextAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const annoRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, annoRect);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const defaultStyle = this.getAnnotString(annotationPtr, "DS");\n    const da = this.getAnnotationDefaultAppearance(annotationPtr);\n    const backgroundColor = this.getAnnotationColor(annotationPtr);\n    const textAlign = this.getAnnotationTextAlignment(annotationPtr);\n    const verticalAlign = this.getAnnotationVerticalAlignment(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const richContent = this.getAnnotRichContent(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.FREETEXT,\n      fontFamily: (da == null ? void 0 : da.fontFamily) ?? PdfStandardFont.Unknown,\n      fontSize: (da == null ? void 0 : da.fontSize) ?? 12,\n      fontColor: (da == null ? void 0 : da.fontColor) ?? "#000000",\n      verticalAlign,\n      backgroundColor,\n      flags,\n      opacity,\n      textAlign,\n      defaultStyle,\n      richContent,\n      contents,\n      author,\n      modified,\n      created,\n      rect\n    };\n  }\n  /**\n   * Read pdf link annotation from pdf document\n   * @param page  - pdf page infor\n   * @param docPtr - pointer to pdf document object\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf link annotation\n   *\n   * @private\n   */\n  readPdfLinkAnno(page, docPtr, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const linkPtr = this.pdfiumModule.FPDFAnnot_GetLink(annotationPtr);\n    if (!linkPtr) {\n      return;\n    }\n    const annoRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, annoRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const target = this.readPdfLinkAnnoTarget(\n      docPtr,\n      () => {\n        return this.pdfiumModule.FPDFLink_GetAction(linkPtr);\n      },\n      () => {\n        return this.pdfiumModule.FPDFLink_GetDest(docPtr, linkPtr);\n      }\n    );\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.LINK,\n      flags,\n      target,\n      rect,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf widget annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param formHandle - form handle\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf widget annotation\n   *\n   * @private\n   */\n  readPdfWidgetAnno(page, annotationPtr, formHandle, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const field = this.readPdfWidgetAnnoField(formHandle, annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.WIDGET,\n      flags,\n      rect,\n      field,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf file attachment annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf file attachment annotation\n   *\n   * @private\n   */\n  readPdfFileAttachmentAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.FILEATTACHMENT,\n      flags,\n      rect,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf ink annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf ink annotation\n   *\n   * @private\n   */\n  readPdfInkAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const { width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    const inkList = this.getInkList(page, annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const intent = this.getAnnotIntent(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.INK,\n      ...intent && { intent },\n      contents,\n      blendMode,\n      flags,\n      color: color ?? "#FF0000",\n      opacity,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      rect,\n      inkList,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf polygon annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf polygon annotation\n   *\n   * @private\n   */\n  readPdfPolygonAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const vertices = this.readPdfAnnoVertices(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    if (vertices.length > 1) {\n      const first = vertices[0];\n      const last = vertices[vertices.length - 1];\n      if (first.x === last.x && first.y === last.y) {\n        vertices.pop();\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.POLYGON,\n      contents,\n      flags,\n      strokeColor: strokeColor ?? "#FF0000",\n      color: interiorColor ?? "transparent",\n      opacity,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      strokeStyle,\n      strokeDashArray,\n      rect,\n      vertices,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf polyline annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf polyline annotation\n   *\n   * @private\n   */\n  readPdfPolylineAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const vertices = this.readPdfAnnoVertices(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    const lineEndings = this.getLineEndings(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.POLYLINE,\n      contents,\n      flags,\n      strokeColor: strokeColor ?? "#FF0000",\n      color: interiorColor ?? "transparent",\n      opacity,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      strokeStyle,\n      strokeDashArray,\n      lineEndings,\n      rect,\n      vertices,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf line annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf line annotation\n   *\n   * @private\n   */\n  readPdfLineAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const linePoints = this.getLinePoints(annotationPtr, page);\n    const lineEndings = this.getLineEndings(annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.LINE,\n      flags,\n      rect,\n      contents,\n      strokeWidth: strokeWidth === 0 ? 1 : strokeWidth,\n      strokeStyle,\n      strokeDashArray,\n      strokeColor: strokeColor ?? "#FF0000",\n      color: interiorColor ?? "transparent",\n      opacity,\n      linePoints: linePoints || { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } },\n      lineEndings: lineEndings || {\n        start: PdfAnnotationLineEnding.None,\n        end: PdfAnnotationLineEnding.None\n      },\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf highlight annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf highlight annotation\n   *\n   * @private\n   */\n  readPdfHighlightAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.HIGHLIGHT,\n      rect,\n      flags,\n      contents,\n      segmentRects,\n      color: color ?? "#FFFF00",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf underline annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf underline annotation\n   *\n   * @private\n   */\n  readPdfUnderlineAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.UNDERLINE,\n      rect,\n      flags,\n      contents,\n      segmentRects,\n      color: color ?? "#FF0000",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read strikeout annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf strikeout annotation\n   *\n   * @private\n   */\n  readPdfStrikeOutAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.STRIKEOUT,\n      flags,\n      rect,\n      contents,\n      segmentRects,\n      color: color ?? "#FF0000",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf squiggly annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf squiggly annotation\n   *\n   * @private\n   */\n  readPdfSquigglyAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const segmentRects = this.getQuadPointsAnno(page, annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const color = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    const blendMode = this.pdfiumModule.EPDFAnnot_GetBlendMode(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      blendMode,\n      type: PdfAnnotationSubtype.SQUIGGLY,\n      rect,\n      flags,\n      contents,\n      segmentRects,\n      color: color ?? "#FF0000",\n      opacity,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf caret annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf caret annotation\n   *\n   * @private\n   */\n  readPdfCaretAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.CARET,\n      rect,\n      flags,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Read pdf stamp annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf stamp annotation\n   *\n   * @private\n   */\n  readPdfStampAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.STAMP,\n      contents,\n      rect,\n      author,\n      modified,\n      created,\n      flags\n    };\n  }\n  /**\n   * Read pdf object in pdf page\n   * @param pageObjectPtr  - pointer to pdf object in page\n   * @returns pdf object in page\n   *\n   * @private\n   */\n  readPdfPageObject(pageObjectPtr) {\n    const type = this.pdfiumModule.FPDFPageObj_GetType(pageObjectPtr);\n    switch (type) {\n      case PdfPageObjectType.PATH:\n        return this.readPathObject(pageObjectPtr);\n      case PdfPageObjectType.IMAGE:\n        return this.readImageObject(pageObjectPtr);\n      case PdfPageObjectType.FORM:\n        return this.readFormObject(pageObjectPtr);\n    }\n  }\n  /**\n   * Read pdf path object\n   * @param pathObjectPtr  - pointer to pdf path object in page\n   * @returns pdf path object\n   *\n   * @private\n   */\n  readPathObject(pathObjectPtr) {\n    const segmentCount = this.pdfiumModule.FPDFPath_CountSegments(pathObjectPtr);\n    const leftPtr = this.malloc(4);\n    const bottomPtr = this.malloc(4);\n    const rightPtr = this.malloc(4);\n    const topPtr = this.malloc(4);\n    this.pdfiumModule.FPDFPageObj_GetBounds(pathObjectPtr, leftPtr, bottomPtr, rightPtr, topPtr);\n    const left = this.pdfiumModule.pdfium.getValue(leftPtr, "float");\n    const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, "float");\n    const right = this.pdfiumModule.pdfium.getValue(rightPtr, "float");\n    const top = this.pdfiumModule.pdfium.getValue(topPtr, "float");\n    const bounds = { left, bottom, right, top };\n    this.free(leftPtr);\n    this.free(bottomPtr);\n    this.free(rightPtr);\n    this.free(topPtr);\n    const segments = [];\n    for (let i = 0; i < segmentCount; i++) {\n      const segment = this.readPdfSegment(pathObjectPtr, i);\n      segments.push(segment);\n    }\n    const matrix = this.readPdfPageObjectTransformMatrix(pathObjectPtr);\n    return {\n      type: PdfPageObjectType.PATH,\n      bounds,\n      segments,\n      matrix\n    };\n  }\n  /**\n   * Read segment of pdf path object\n   * @param annotationObjectPtr - pointer to pdf path object\n   * @param segmentIndex - index of segment\n   * @returns pdf segment in pdf path\n   *\n   * @private\n   */\n  readPdfSegment(annotationObjectPtr, segmentIndex) {\n    const segmentPtr = this.pdfiumModule.FPDFPath_GetPathSegment(annotationObjectPtr, segmentIndex);\n    const segmentType = this.pdfiumModule.FPDFPathSegment_GetType(segmentPtr);\n    const isClosed = this.pdfiumModule.FPDFPathSegment_GetClose(segmentPtr);\n    const pointXPtr = this.malloc(4);\n    const pointYPtr = this.malloc(4);\n    this.pdfiumModule.FPDFPathSegment_GetPoint(segmentPtr, pointXPtr, pointYPtr);\n    const pointX = this.pdfiumModule.pdfium.getValue(pointXPtr, "float");\n    const pointY = this.pdfiumModule.pdfium.getValue(pointYPtr, "float");\n    this.free(pointXPtr);\n    this.free(pointYPtr);\n    return {\n      type: segmentType,\n      point: { x: pointX, y: pointY },\n      isClosed\n    };\n  }\n  /**\n   * Read pdf image object from pdf document\n   * @param pageObjectPtr  - pointer to pdf image object in page\n   * @returns pdf image object\n   *\n   * @private\n   */\n  readImageObject(imageObjectPtr) {\n    const bitmapPtr = this.pdfiumModule.FPDFImageObj_GetBitmap(imageObjectPtr);\n    const bitmapBufferPtr = this.pdfiumModule.FPDFBitmap_GetBuffer(bitmapPtr);\n    const bitmapWidth = this.pdfiumModule.FPDFBitmap_GetWidth(bitmapPtr);\n    const bitmapHeight = this.pdfiumModule.FPDFBitmap_GetHeight(bitmapPtr);\n    const format = this.pdfiumModule.FPDFBitmap_GetFormat(bitmapPtr);\n    const pixelCount = bitmapWidth * bitmapHeight;\n    const bytesPerPixel = 4;\n    const array = new Uint8ClampedArray(pixelCount * bytesPerPixel);\n    for (let i = 0; i < pixelCount; i++) {\n      switch (format) {\n        case 2:\n          {\n            const blue = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3, "i8");\n            const green = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3 + 1, "i8");\n            const red = this.pdfiumModule.pdfium.getValue(bitmapBufferPtr + i * 3 + 2, "i8");\n            array[i * bytesPerPixel] = red;\n            array[i * bytesPerPixel + 1] = green;\n            array[i * bytesPerPixel + 2] = blue;\n            array[i * bytesPerPixel + 3] = 100;\n          }\n          break;\n      }\n    }\n    const imageData = new ImageData(array, bitmapWidth, bitmapHeight);\n    const matrix = this.readPdfPageObjectTransformMatrix(imageObjectPtr);\n    return {\n      type: PdfPageObjectType.IMAGE,\n      imageData,\n      matrix\n    };\n  }\n  /**\n   * Read form object from pdf document\n   * @param formObjectPtr  - pointer to pdf form object in page\n   * @returns pdf form object\n   *\n   * @private\n   */\n  readFormObject(formObjectPtr) {\n    const objectCount = this.pdfiumModule.FPDFFormObj_CountObjects(formObjectPtr);\n    const objects = [];\n    for (let i = 0; i < objectCount; i++) {\n      const pageObjectPtr = this.pdfiumModule.FPDFFormObj_GetObject(formObjectPtr, i);\n      const pageObj = this.readPdfPageObject(pageObjectPtr);\n      if (pageObj) {\n        objects.push(pageObj);\n      }\n    }\n    const matrix = this.readPdfPageObjectTransformMatrix(formObjectPtr);\n    return {\n      type: PdfPageObjectType.FORM,\n      objects,\n      matrix\n    };\n  }\n  /**\n   * Read pdf object in pdf page\n   * @param pageObjectPtr  - pointer to pdf object in page\n   * @returns pdf object in page\n   *\n   * @private\n   */\n  readPdfPageObjectTransformMatrix(pageObjectPtr) {\n    const matrixPtr = this.malloc(4 * 6);\n    if (this.pdfiumModule.FPDFPageObj_GetMatrix(pageObjectPtr, matrixPtr)) {\n      const a = this.pdfiumModule.pdfium.getValue(matrixPtr, "float");\n      const b = this.pdfiumModule.pdfium.getValue(matrixPtr + 4, "float");\n      const c = this.pdfiumModule.pdfium.getValue(matrixPtr + 8, "float");\n      const d = this.pdfiumModule.pdfium.getValue(matrixPtr + 12, "float");\n      const e = this.pdfiumModule.pdfium.getValue(matrixPtr + 16, "float");\n      const f = this.pdfiumModule.pdfium.getValue(matrixPtr + 20, "float");\n      this.free(matrixPtr);\n      return { a, b, c, d, e, f };\n    }\n    this.free(matrixPtr);\n    return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };\n  }\n  /**\n   * Read contents of a stamp annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns contents of the stamp annotation\n   *\n   * @private\n   */\n  readStampAnnotationContents(annotationPtr) {\n    const contents = [];\n    const objectCount = this.pdfiumModule.FPDFAnnot_GetObjectCount(annotationPtr);\n    for (let i = 0; i < objectCount; i++) {\n      const annotationObjectPtr = this.pdfiumModule.FPDFAnnot_GetObject(annotationPtr, i);\n      const pageObj = this.readPdfPageObject(annotationObjectPtr);\n      if (pageObj) {\n        contents.push(pageObj);\n      }\n    }\n    return contents;\n  }\n  /**\n   * Return the stroke-width declared in the annotation’s /Border or /BS entry.\n   * Falls back to 1 pt when nothing is defined.\n   *\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns stroke-width\n   *\n   * @private\n   */\n  getStrokeWidth(annotationPtr) {\n    const hPtr = this.malloc(4);\n    const vPtr = this.malloc(4);\n    const wPtr = this.malloc(4);\n    const ok = this.pdfiumModule.FPDFAnnot_GetBorder(annotationPtr, hPtr, vPtr, wPtr);\n    const width = ok ? this.pdfiumModule.pdfium.getValue(wPtr, "float") : 1;\n    this.free(hPtr);\n    this.free(vPtr);\n    this.free(wPtr);\n    return width;\n  }\n  /**\n   * Fetches the `/F` flag bit-field from an annotation.\n   *\n   * @param annotationPtr pointer to an `FPDF_ANNOTATION`\n   * @returns `{ raw, flags }`\n   *          • `raw`   – the 32-bit integer returned by PDFium\n   *          • `flags` – object with individual booleans\n   */\n  getAnnotationFlags(annotationPtr) {\n    const rawFlags = this.pdfiumModule.FPDFAnnot_GetFlags(annotationPtr);\n    return flagsToNames(rawFlags);\n  }\n  setAnnotationFlags(annotationPtr, flags) {\n    const rawFlags = namesToFlags(flags);\n    return this.pdfiumModule.FPDFAnnot_SetFlags(annotationPtr, rawFlags);\n  }\n  /**\n   * Read circle annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf circle annotation\n   *\n   * @private\n   */\n  readPdfCircleAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.CIRCLE,\n      flags,\n      color: interiorColor ?? "transparent",\n      opacity,\n      contents,\n      strokeWidth,\n      strokeColor: strokeColor ?? "#FF0000",\n      strokeStyle,\n      rect,\n      author,\n      modified,\n      created,\n      ...strokeDashArray !== void 0 && { strokeDashArray }\n    };\n  }\n  /**\n   * Read square annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf square annotation\n   *\n   * @private\n   */\n  readPdfSquareAnno(page, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const flags = this.getAnnotationFlags(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const contents = this.getAnnotString(annotationPtr, "Contents") || "";\n    const interiorColor = this.getAnnotationColor(\n      annotationPtr,\n      PdfAnnotationColorType.InteriorColor\n    );\n    const strokeColor = this.getAnnotationColor(annotationPtr);\n    const opacity = this.getAnnotationOpacity(annotationPtr);\n    let { style: strokeStyle, width: strokeWidth } = this.getBorderStyle(annotationPtr);\n    let strokeDashArray;\n    if (strokeStyle === PdfAnnotationBorderStyle.DASHED) {\n      const { ok, pattern } = this.getBorderDashPattern(annotationPtr);\n      if (ok) {\n        strokeDashArray = pattern;\n      }\n    }\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      type: PdfAnnotationSubtype.SQUARE,\n      flags,\n      color: interiorColor ?? "transparent",\n      opacity,\n      contents,\n      strokeColor: strokeColor ?? "#FF0000",\n      strokeWidth,\n      strokeStyle,\n      rect,\n      author,\n      modified,\n      created,\n      ...strokeDashArray !== void 0 && { strokeDashArray }\n    };\n  }\n  /**\n   * Read basic info of unsupported pdf annotation\n   * @param page  - pdf page infor\n   * @param type - type of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @param index  - index of annotation in the pdf page\n   * @returns pdf annotation\n   *\n   * @private\n   */\n  readPdfAnno(page, type, annotationPtr, index) {\n    const custom = this.getAnnotCustom(annotationPtr);\n    const pageRect = this.readPageAnnoRect(annotationPtr);\n    const rect = this.convertPageRectToDeviceRect(page, pageRect);\n    const author = this.getAnnotString(annotationPtr, "T");\n    const modified = this.getAnnotationDate(annotationPtr, "M");\n    const created = this.getAnnotationDate(annotationPtr, "CreationDate");\n    const flags = this.getAnnotationFlags(annotationPtr);\n    return {\n      pageIndex: page.index,\n      custom,\n      id: index,\n      flags,\n      type,\n      rect,\n      author,\n      modified,\n      created\n    };\n  }\n  /**\n   * Resolve `/IRT` → parent-annotation index on the same page.\n   *\n   * @param pagePtr        - pointer to FPDF_PAGE\n   * @param annotationPtr  - pointer to FPDF_ANNOTATION\n   * @returns index (`0…count-1`) or `undefined` when the annotation is *not* a reply\n   *\n   * @private\n   */\n  getInReplyToId(annotationPtr) {\n    const parentPtr = this.pdfiumModule.FPDFAnnot_GetLinkedAnnot(annotationPtr, "IRT");\n    if (!parentPtr) return;\n    return this.getAnnotString(parentPtr, "NM");\n  }\n  /**\n   * Set the in reply to id of the annotation\n   *\n   * @param annotationPtr - pointer to an `FPDF_ANNOTATION`\n   * @param id - the id of the parent annotation\n   * @returns `true` on success\n   */\n  setInReplyToId(pagePtr, annotationPtr, id) {\n    const parentPtr = this.getAnnotationByName(pagePtr, id);\n    if (!parentPtr) return false;\n    return this.pdfiumModule.EPDFAnnot_SetLinkedAnnot(annotationPtr, "IRT", parentPtr);\n  }\n  /**\n   * Fetch a string value (`/T`, `/M`, `/State`, …) from an annotation.\n   *\n   * @returns decoded UTF-8 string or `undefined` when the key is absent\n   *\n   * @private\n   */\n  getAnnotString(annotationPtr, key) {\n    const len = this.pdfiumModule.FPDFAnnot_GetStringValue(annotationPtr, key, 0, 0);\n    if (len === 0) return;\n    const bytes = (len + 1) * 2;\n    const ptr = this.malloc(bytes);\n    this.pdfiumModule.FPDFAnnot_GetStringValue(annotationPtr, key, ptr, bytes);\n    const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n    this.free(ptr);\n    return value || void 0;\n  }\n  /**\n   * Get custom data of the annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns custom data of the annotation\n   *\n   * @private\n   */\n  getAnnotCustom(annotationPtr) {\n    const custom = this.getAnnotString(annotationPtr, "EPDFCustom");\n    if (!custom) return;\n    try {\n      return JSON.parse(custom);\n    } catch (error) {\n      console.warn("Failed to parse annotation custom data as JSON:", error);\n      console.warn("Invalid JSON string:", custom);\n      return void 0;\n    }\n  }\n  /**\n   * Sets custom data for an annotation by safely stringifying and storing JSON\n   * @private\n   */\n  setAnnotCustom(annotationPtr, data) {\n    if (data === void 0 || data === null) {\n      return this.setAnnotString(annotationPtr, "EPDFCustom", "");\n    }\n    try {\n      const jsonString = JSON.stringify(data);\n      return this.setAnnotString(annotationPtr, "EPDFCustom", jsonString);\n    } catch (error) {\n      console.warn("Failed to stringify annotation custom data as JSON:", error);\n      console.warn("Invalid data object:", data);\n      return false;\n    }\n  }\n  /**\n   * Fetches the /IT (Intent) name from an annotation as a UTF-8 JS string.\n   *\n   * Mirrors getAnnotString(): calls EPDFAnnot_GetIntent twice (length probe + copy).\n   * Returns `undefined` if no intent present.\n   */\n  getAnnotIntent(annotationPtr) {\n    const len = this.pdfiumModule.EPDFAnnot_GetIntent(annotationPtr, 0, 0);\n    if (len === 0) return;\n    const codeUnits = len + 1;\n    const bytes = codeUnits * 2;\n    const ptr = this.malloc(bytes);\n    this.pdfiumModule.EPDFAnnot_GetIntent(annotationPtr, ptr, bytes);\n    const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n    this.free(ptr);\n    return value && value !== "undefined" ? value : void 0;\n  }\n  /**\n   * Write the `/IT` (Intent) name into an annotation dictionary.\n   *\n   * Mirrors EPDFAnnot_SetIntent in PDFium (expects a UTF‑8 FPDF_BYTESTRING).\n   *\n   * @param annotationPtr Pointer returned by FPDFPage_GetAnnot\n   * @param intent        Name without leading slash, e.g. `"PolygonCloud"`\n   *                      A leading “/” will be stripped for convenience.\n   * @returns             true on success, false otherwise\n   */\n  setAnnotIntent(annotationPtr, intent) {\n    return this.pdfiumModule.EPDFAnnot_SetIntent(annotationPtr, intent);\n  }\n  /**\n   * Returns the rich‑content string stored in the annotation’s `/RC` entry.\n   *\n   * Works like `getAnnotIntent()`: first probe for length, then copy.\n   * `undefined` when the annotation has no rich content.\n   */\n  getAnnotRichContent(annotationPtr) {\n    const len = this.pdfiumModule.EPDFAnnot_GetRichContent(annotationPtr, 0, 0);\n    if (len === 0) return;\n    const codeUnits = len + 1;\n    const bytes = codeUnits * 2;\n    const ptr = this.malloc(bytes);\n    this.pdfiumModule.EPDFAnnot_GetRichContent(annotationPtr, ptr, bytes);\n    const value = this.pdfiumModule.pdfium.UTF16ToString(ptr);\n    this.free(ptr);\n    return value || void 0;\n  }\n  /**\n   * Get annotation by name\n   * @param pagePtr - pointer to pdf page object\n   * @param name - name of annotation\n   * @returns pointer to pdf annotation\n   *\n   * @private\n   */\n  getAnnotationByName(pagePtr, name) {\n    const bytes = 2 * (name.length + 1);\n    const ptr = this.malloc(bytes);\n    this.pdfiumModule.pdfium.stringToUTF16(name, ptr, bytes);\n    const ok = this.pdfiumModule.EPDFPage_GetAnnotByName(pagePtr, ptr);\n    this.free(ptr);\n    return ok;\n  }\n  /**\n   * Remove annotation by name\n   * @param pagePtr - pointer to pdf page object\n   * @param name - name of annotation\n   * @returns true on success\n   *\n   * @private\n   */\n  removeAnnotationByName(pagePtr, name) {\n    const bytes = 2 * (name.length + 1);\n    const ptr = this.malloc(bytes);\n    this.pdfiumModule.pdfium.stringToUTF16(name, ptr, bytes);\n    const ok = this.pdfiumModule.EPDFPage_RemoveAnnotByName(pagePtr, ptr);\n    this.free(ptr);\n    return ok;\n  }\n  /**\n   * Set a string value (`/T`, `/M`, `/State`, …) to an annotation.\n   *\n   * @returns `true` if the operation was successful\n   *\n   * @private\n   */\n  setAnnotString(annotationPtr, key, value) {\n    const bytes = 2 * (value.length + 1);\n    const ptr = this.malloc(bytes);\n    this.pdfiumModule.pdfium.stringToUTF16(value, ptr, bytes);\n    const ok = this.pdfiumModule.FPDFAnnot_SetStringValue(annotationPtr, key, ptr);\n    this.free(ptr);\n    return ok;\n  }\n  /**\n   * Read vertices of pdf annotation\n   * @param page  - pdf page infor\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns vertices of pdf annotation\n   *\n   * @private\n   */\n  readPdfAnnoVertices(page, annotationPtr) {\n    const vertices = [];\n    const count = this.pdfiumModule.FPDFAnnot_GetVertices(annotationPtr, 0, 0);\n    const pointMemorySize = 8;\n    const pointsPtr = this.malloc(count * pointMemorySize);\n    this.pdfiumModule.FPDFAnnot_GetVertices(annotationPtr, pointsPtr, count);\n    for (let i = 0; i < count; i++) {\n      const pointX = this.pdfiumModule.pdfium.getValue(pointsPtr + i * pointMemorySize, "float");\n      const pointY = this.pdfiumModule.pdfium.getValue(\n        pointsPtr + i * pointMemorySize + 4,\n        "float"\n      );\n      const { x, y } = this.convertPagePointToDevicePoint(page, {\n        x: pointX,\n        y: pointY\n      });\n      const last = vertices[vertices.length - 1];\n      if (!last || last.x !== x || last.y !== y) {\n        vertices.push({ x, y });\n      }\n    }\n    this.free(pointsPtr);\n    return vertices;\n  }\n  /**\n   * Sync the vertices of a polygon or polyline annotation.\n   *\n   * @param page  - pdf page infor\n   * @param annotPtr - pointer to pdf annotation\n   * @param vertices - the vertices to be set\n   * @returns true on success\n   *\n   * @private\n   */\n  setPdfAnnoVertices(page, annotPtr, vertices) {\n    const pdf = this.pdfiumModule.pdfium;\n    const FS_POINTF_SIZE = 8;\n    const buf = this.malloc(FS_POINTF_SIZE * vertices.length);\n    vertices.forEach((v, i) => {\n      const pagePt = this.convertDevicePointToPagePoint(page, v);\n      pdf.setValue(buf + i * FS_POINTF_SIZE + 0, pagePt.x, "float");\n      pdf.setValue(buf + i * FS_POINTF_SIZE + 4, pagePt.y, "float");\n    });\n    const ok = this.pdfiumModule.EPDFAnnot_SetVertices(annotPtr, buf, vertices.length);\n    this.free(buf);\n    return ok;\n  }\n  /**\n   * Read the target of pdf bookmark\n   * @param docPtr - pointer to pdf document object\n   * @param getActionPtr - callback function to retrive the pointer of action\n   * @param getDestinationPtr - callback function to retrive the pointer of destination\n   * @returns target of pdf bookmark\n   *\n   * @private\n   */\n  readPdfBookmarkTarget(docPtr, getActionPtr, getDestinationPtr) {\n    const actionPtr = getActionPtr();\n    if (actionPtr) {\n      const action = this.readPdfAction(docPtr, actionPtr);\n      return {\n        type: "action",\n        action\n      };\n    } else {\n      const destinationPtr = getDestinationPtr();\n      if (destinationPtr) {\n        const destination = this.readPdfDestination(docPtr, destinationPtr);\n        return {\n          type: "destination",\n          destination\n        };\n      }\n    }\n  }\n  /**\n   * Read field of pdf widget annotation\n   * @param formHandle - form handle\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns field of pdf widget annotation\n   *\n   * @private\n   */\n  readPdfWidgetAnnoField(formHandle, annotationPtr) {\n    const flag = this.pdfiumModule.FPDFAnnot_GetFormFieldFlags(\n      formHandle,\n      annotationPtr\n    );\n    const type = this.pdfiumModule.FPDFAnnot_GetFormFieldType(\n      formHandle,\n      annotationPtr\n    );\n    const name = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAnnot_GetFormFieldName(\n          formHandle,\n          annotationPtr,\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const alternateName = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAnnot_GetFormFieldAlternateName(\n          formHandle,\n          annotationPtr,\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const value = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAnnot_GetFormFieldValue(\n          formHandle,\n          annotationPtr,\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const options = [];\n    if (type === PDF_FORM_FIELD_TYPE.COMBOBOX || type === PDF_FORM_FIELD_TYPE.LISTBOX) {\n      const count = this.pdfiumModule.FPDFAnnot_GetOptionCount(formHandle, annotationPtr);\n      for (let i = 0; i < count; i++) {\n        const label = readString(\n          this.pdfiumModule.pdfium,\n          (buffer, bufferLength) => {\n            return this.pdfiumModule.FPDFAnnot_GetOptionLabel(\n              formHandle,\n              annotationPtr,\n              i,\n              buffer,\n              bufferLength\n            );\n          },\n          this.pdfiumModule.pdfium.UTF16ToString\n        );\n        const isSelected = this.pdfiumModule.FPDFAnnot_IsOptionSelected(\n          formHandle,\n          annotationPtr,\n          i\n        );\n        options.push({\n          label,\n          isSelected\n        });\n      }\n    }\n    let isChecked = false;\n    if (type === PDF_FORM_FIELD_TYPE.CHECKBOX || type === PDF_FORM_FIELD_TYPE.RADIOBUTTON) {\n      isChecked = this.pdfiumModule.FPDFAnnot_IsChecked(formHandle, annotationPtr);\n    }\n    return {\n      flag,\n      type,\n      name,\n      alternateName,\n      value,\n      isChecked,\n      options\n    };\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.renderAnnotation}\n   *\n   * @public\n   */\n  renderAnnotation(doc, page, annotation, scaleFactor, rotation, dpr = 1, mode = AppearanceMode.Normal, imageType = "image/webp") {\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      "renderAnnotation",\n      doc,\n      page,\n      annotation,\n      scaleFactor,\n      rotation,\n      dpr,\n      mode,\n      imageType\n    );\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `RenderAnnotation`,\n      "Begin",\n      `${doc.id}-${page.index}-${annotation.id}`\n    );\n    const task = new Task();\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `RenderAnnotation`,\n        "End",\n        `${doc.id}-${page.index}-${annotation.id}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.DocNotOpen,\n        message: "document does not open"\n      });\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    const annotPtr = this.getAnnotationByName(pageCtx.pagePtr, annotation.id);\n    if (!annotPtr) {\n      pageCtx.release();\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `RenderAnnotation`,\n        "End",\n        `${doc.id}-${page.index}-${annotation.id}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.NotFound,\n        message: "annotation not found"\n      });\n    }\n    const finalScale = scaleFactor * dpr;\n    const annotRect = annotation.rect;\n    const bitmapRect = toIntRect(transformRect(page.size, annotRect, rotation, finalScale));\n    const format = 4;\n    const bytesPerPixel = 4;\n    const bitmapHeapLength = bitmapRect.size.width * bitmapRect.size.height * bytesPerPixel;\n    const bitmapHeapPtr = this.malloc(bitmapHeapLength);\n    const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(\n      bitmapRect.size.width,\n      bitmapRect.size.height,\n      format,\n      bitmapHeapPtr,\n      bitmapRect.size.width * bytesPerPixel\n    );\n    this.pdfiumModule.FPDFBitmap_FillRect(\n      bitmapPtr,\n      0,\n      0,\n      bitmapRect.size.width,\n      bitmapRect.size.height,\n      0\n    );\n    const matrix = makeMatrix(annotation.rect, rotation, finalScale);\n    const matrixSize = 6 * 4;\n    const matrixPtr = this.malloc(matrixSize);\n    const matrixView = new Float32Array(this.pdfiumModule.pdfium.HEAPF32.buffer, matrixPtr, 6);\n    matrixView.set([matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f]);\n    const FLAGS = 16;\n    const ok = !!this.pdfiumModule.EPDF_RenderAnnotBitmap(\n      bitmapPtr,\n      pageCtx.pagePtr,\n      annotPtr,\n      mode,\n      matrixPtr,\n      FLAGS\n    );\n    this.free(matrixPtr);\n    this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n    this.pdfiumModule.FPDFPage_CloseAnnot(annotPtr);\n    pageCtx.release();\n    if (!ok) {\n      this.free(bitmapHeapPtr);\n      this.logger.perf(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `RenderAnnotation`,\n        "End",\n        `${doc.id}-${page.index}-${annotation.id}`\n      );\n      return PdfTaskHelper.reject({\n        code: PdfErrorCode.Unknown,\n        message: "EPDF_RenderAnnotBitmap failed"\n      });\n    }\n    const data = this.pdfiumModule.pdfium.HEAPU8.subarray(\n      bitmapHeapPtr,\n      bitmapHeapPtr + bitmapHeapLength\n    );\n    const imageData = {\n      data: new Uint8ClampedArray(data),\n      width: bitmapRect.size.width,\n      height: bitmapRect.size.height\n    };\n    this.free(bitmapHeapPtr);\n    this.logger.perf(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `RenderAnnotation`,\n      "End",\n      `${doc.id}-${page.index}-${annotation.id}`\n    );\n    this.imageDataConverter(imageData, imageType).then((blob) => task.resolve(blob)).catch((err) => task.reject({ code: PdfErrorCode.Unknown, message: String(err) }));\n    return task;\n  }\n  /**\n   * render rectangle of pdf page to image\n   * @param docPtr - pointer to pdf document object\n   * @param page  - pdf page infor\n   * @param rect - rectangle info\n   * @param scaleFactor  - factor of scalling\n   * @param rotation  - rotation angle\n   * @param options - render options\n   * @returns image data\n   *\n   * @private\n   */\n  renderPageRectToImageData(ctx, page, rect, scaleFactor, rotation, dpr, options) {\n    const format = 4;\n    const bytesPerPixel = 4;\n    const rectSize = toIntRect(transformRect(page.size, rect, rotation, scaleFactor * dpr));\n    const pageSize = toIntSize(transformSize(page.size, rotation, scaleFactor * dpr));\n    const bitmapHeapLength = rectSize.size.width * rectSize.size.height * bytesPerPixel;\n    const bitmapHeapPtr = this.malloc(bitmapHeapLength);\n    const bitmapPtr = this.pdfiumModule.FPDFBitmap_CreateEx(\n      rectSize.size.width,\n      rectSize.size.height,\n      format,\n      bitmapHeapPtr,\n      rectSize.size.width * bytesPerPixel\n    );\n    this.pdfiumModule.FPDFBitmap_FillRect(\n      bitmapPtr,\n      0,\n      0,\n      rectSize.size.width,\n      rectSize.size.height,\n      4294967295\n    );\n    let flags = 16;\n    if (options == null ? void 0 : options.withAnnotations) {\n      flags = flags | 1;\n    }\n    const pageCtx = ctx.acquirePage(page.index);\n    this.pdfiumModule.FPDF_RenderPageBitmap(\n      bitmapPtr,\n      pageCtx.pagePtr,\n      -rectSize.origin.x,\n      -rectSize.origin.y,\n      pageSize.width,\n      pageSize.height,\n      rotation,\n      flags\n    );\n    this.pdfiumModule.FPDFBitmap_Destroy(bitmapPtr);\n    pageCtx.release();\n    const data = this.pdfiumModule.pdfium.HEAPU8.subarray(\n      bitmapHeapPtr,\n      bitmapHeapPtr + bitmapHeapLength\n    );\n    const imageData = {\n      data: new Uint8ClampedArray(data),\n      width: rectSize.size.width,\n      height: rectSize.size.height\n    };\n    this.free(bitmapHeapPtr);\n    return imageData;\n  }\n  /**\n   * Read the target of pdf link annotation\n   * @param docPtr - pointer to pdf document object\n   * @param getActionPtr - callback function to retrive the pointer of action\n   * @param getDestinationPtr - callback function to retrive the pointer of destination\n   * @returns target of link\n   *\n   * @private\n   */\n  readPdfLinkAnnoTarget(docPtr, getActionPtr, getDestinationPtr) {\n    const destinationPtr = getDestinationPtr();\n    if (destinationPtr) {\n      const destination = this.readPdfDestination(docPtr, destinationPtr);\n      return {\n        type: "destination",\n        destination\n      };\n    } else {\n      const actionPtr = getActionPtr();\n      if (actionPtr) {\n        const action = this.readPdfAction(docPtr, actionPtr);\n        return {\n          type: "action",\n          action\n        };\n      }\n    }\n  }\n  /**\n   * Read pdf action from pdf document\n   * @param docPtr - pointer to pdf document object\n   * @param actionPtr - pointer to pdf action object\n   * @returns pdf action object\n   *\n   * @private\n   */\n  readPdfAction(docPtr, actionPtr) {\n    const actionType = this.pdfiumModule.FPDFAction_GetType(actionPtr);\n    let action;\n    switch (actionType) {\n      case PdfActionType.Unsupported:\n        action = {\n          type: PdfActionType.Unsupported\n        };\n        break;\n      case PdfActionType.Goto:\n        {\n          const destinationPtr = this.pdfiumModule.FPDFAction_GetDest(docPtr, actionPtr);\n          if (destinationPtr) {\n            const destination = this.readPdfDestination(docPtr, destinationPtr);\n            action = {\n              type: PdfActionType.Goto,\n              destination\n            };\n          } else {\n            action = {\n              type: PdfActionType.Unsupported\n            };\n          }\n        }\n        break;\n      case PdfActionType.RemoteGoto:\n        {\n          action = {\n            type: PdfActionType.Unsupported\n          };\n        }\n        break;\n      case PdfActionType.URI:\n        {\n          const uri = readString(\n            this.pdfiumModule.pdfium,\n            (buffer, bufferLength) => {\n              return this.pdfiumModule.FPDFAction_GetURIPath(\n                docPtr,\n                actionPtr,\n                buffer,\n                bufferLength\n              );\n            },\n            this.pdfiumModule.pdfium.UTF8ToString\n          );\n          action = {\n            type: PdfActionType.URI,\n            uri\n          };\n        }\n        break;\n      case PdfActionType.LaunchAppOrOpenFile:\n        {\n          const path = readString(\n            this.pdfiumModule.pdfium,\n            (buffer, bufferLength) => {\n              return this.pdfiumModule.FPDFAction_GetFilePath(actionPtr, buffer, bufferLength);\n            },\n            this.pdfiumModule.pdfium.UTF8ToString\n          );\n          action = {\n            type: PdfActionType.LaunchAppOrOpenFile,\n            path\n          };\n        }\n        break;\n    }\n    return action;\n  }\n  /**\n   * Read pdf destination object\n   * @param docPtr - pointer to pdf document object\n   * @param destinationPtr - pointer to pdf destination\n   * @returns pdf destination object\n   *\n   * @private\n   */\n  readPdfDestination(docPtr, destinationPtr) {\n    const pageIndex = this.pdfiumModule.FPDFDest_GetDestPageIndex(docPtr, destinationPtr);\n    const maxParmamsCount = 4;\n    const paramsCountPtr = this.malloc(maxParmamsCount);\n    const paramsPtr = this.malloc(maxParmamsCount * 4);\n    const zoomMode = this.pdfiumModule.FPDFDest_GetView(\n      destinationPtr,\n      paramsCountPtr,\n      paramsPtr\n    );\n    const paramsCount = this.pdfiumModule.pdfium.getValue(paramsCountPtr, "i32");\n    const view = [];\n    for (let i = 0; i < paramsCount; i++) {\n      const paramPtr = paramsPtr + i * 4;\n      view.push(this.pdfiumModule.pdfium.getValue(paramPtr, "float"));\n    }\n    this.free(paramsCountPtr);\n    this.free(paramsPtr);\n    if (zoomMode === PdfZoomMode.XYZ) {\n      const hasXPtr = this.malloc(1);\n      const hasYPtr = this.malloc(1);\n      const hasZPtr = this.malloc(1);\n      const xPtr = this.malloc(4);\n      const yPtr = this.malloc(4);\n      const zPtr = this.malloc(4);\n      const isSucceed = this.pdfiumModule.FPDFDest_GetLocationInPage(\n        destinationPtr,\n        hasXPtr,\n        hasYPtr,\n        hasZPtr,\n        xPtr,\n        yPtr,\n        zPtr\n      );\n      if (isSucceed) {\n        const hasX = this.pdfiumModule.pdfium.getValue(hasXPtr, "i8");\n        const hasY = this.pdfiumModule.pdfium.getValue(hasYPtr, "i8");\n        const hasZ = this.pdfiumModule.pdfium.getValue(hasZPtr, "i8");\n        const x = hasX ? this.pdfiumModule.pdfium.getValue(xPtr, "float") : 0;\n        const y = hasY ? this.pdfiumModule.pdfium.getValue(yPtr, "float") : 0;\n        const zoom = hasZ ? this.pdfiumModule.pdfium.getValue(zPtr, "float") : 0;\n        this.free(hasXPtr);\n        this.free(hasYPtr);\n        this.free(hasZPtr);\n        this.free(xPtr);\n        this.free(yPtr);\n        this.free(zPtr);\n        return {\n          pageIndex,\n          zoom: {\n            mode: zoomMode,\n            params: {\n              x,\n              y,\n              zoom\n            }\n          },\n          view\n        };\n      }\n      this.free(hasXPtr);\n      this.free(hasYPtr);\n      this.free(hasZPtr);\n      this.free(xPtr);\n      this.free(yPtr);\n      this.free(zPtr);\n      return {\n        pageIndex,\n        zoom: {\n          mode: zoomMode,\n          params: {\n            x: 0,\n            y: 0,\n            zoom: 0\n          }\n        },\n        view\n      };\n    }\n    return {\n      pageIndex,\n      zoom: {\n        mode: zoomMode\n      },\n      view\n    };\n  }\n  /**\n   * Read attachmet from pdf document\n   * @param docPtr - pointer to pdf document object\n   * @param index - index of attachment\n   * @returns attachment content\n   *\n   * @private\n   */\n  readPdfAttachment(docPtr, index) {\n    const attachmentPtr = this.pdfiumModule.FPDFDoc_GetAttachment(docPtr, index);\n    const name = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAttachment_GetName(attachmentPtr, buffer, bufferLength);\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const creationDate = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAttachment_GetStringValue(\n          attachmentPtr,\n          "CreationDate",\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    const checksum = readString(\n      this.pdfiumModule.pdfium,\n      (buffer, bufferLength) => {\n        return this.pdfiumModule.FPDFAttachment_GetStringValue(\n          attachmentPtr,\n          "Checksum",\n          buffer,\n          bufferLength\n        );\n      },\n      this.pdfiumModule.pdfium.UTF16ToString\n    );\n    return {\n      index,\n      name,\n      creationDate,\n      checksum\n    };\n  }\n  /**\n   * Convert coordinate of point from device coordinate to page coordinate\n   * @param page  - pdf page infor\n   * @param position - position of point\n   * @returns converted position\n   *\n   * @private\n   */\n  convertDevicePointToPagePoint(page, position) {\n    const x = position.x;\n    const y = page.size.height - position.y;\n    return { x, y };\n  }\n  /**\n   * Convert coordinate of point from page coordinate to device coordinate\n   * @param page  - pdf page infor\n   * @param position - position of point\n   * @returns converted position\n   *\n   * @private\n   */\n  convertPagePointToDevicePoint(page, position) {\n    const x = position.x;\n    const y = page.size.height - position.y;\n    return { x, y };\n  }\n  /**\n   * Convert coordinate of rectangle from page coordinate to device coordinate\n   * @param page  - pdf page infor\n   * @param pagePtr - pointer to pdf page object\n   * @param pageRect - rectangle that needs to be converted\n   * @returns converted rectangle\n   *\n   * @private\n   */\n  convertPageRectToDeviceRect(page, pageRect) {\n    const { x, y } = this.convertPagePointToDevicePoint(page, {\n      x: pageRect.left,\n      y: pageRect.top\n    });\n    const rect = {\n      origin: {\n        x,\n        y\n      },\n      size: {\n        width: Math.abs(pageRect.right - pageRect.left),\n        height: Math.abs(pageRect.top - pageRect.bottom)\n      }\n    };\n    return rect;\n  }\n  /**\n   * Read the appearance stream of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @param mode - appearance mode\n   * @returns appearance stream\n   *\n   * @private\n   */\n  readPageAnnoAppearanceStreams(annotationPtr) {\n    return {\n      normal: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Normal),\n      rollover: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Rollover),\n      down: this.readPageAnnoAppearanceStream(annotationPtr, AppearanceMode.Down)\n    };\n  }\n  /**\n   * Read the appearance stream of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @param mode - appearance mode\n   * @returns appearance stream\n   *\n   * @private\n   */\n  readPageAnnoAppearanceStream(annotationPtr, mode = AppearanceMode.Normal) {\n    const utf16Length = this.pdfiumModule.FPDFAnnot_GetAP(annotationPtr, mode, 0, 0);\n    const bytesCount = (utf16Length + 1) * 2;\n    const bufferPtr = this.malloc(bytesCount);\n    this.pdfiumModule.FPDFAnnot_GetAP(annotationPtr, mode, bufferPtr, bytesCount);\n    const ap = this.pdfiumModule.pdfium.UTF16ToString(bufferPtr);\n    this.free(bufferPtr);\n    return ap;\n  }\n  /**\n   * Set the rect of specified annotation\n   * @param page - page info that the annotation is belonged to\n   * @param pagePtr - pointer of page object\n   * @param annotationPtr - pointer to annotation object\n   * @param rect - target rectangle\n   * @returns whether the rect is setted\n   *\n   * @private\n   */\n  setPageAnnoRect(page, pagePtr, annotationPtr, rect) {\n    const pageXPtr = this.malloc(8);\n    const pageYPtr = this.malloc(8);\n    if (!this.pdfiumModule.FPDF_DeviceToPage(\n      pagePtr,\n      0,\n      0,\n      page.size.width,\n      page.size.height,\n      0,\n      rect.origin.x,\n      rect.origin.y,\n      pageXPtr,\n      pageYPtr\n    )) {\n      this.free(pageXPtr);\n      this.free(pageYPtr);\n      return false;\n    }\n    const pageX = this.pdfiumModule.pdfium.getValue(pageXPtr, "double");\n    const pageY = this.pdfiumModule.pdfium.getValue(pageYPtr, "double");\n    this.free(pageXPtr);\n    this.free(pageYPtr);\n    const pageRectPtr = this.malloc(4 * 4);\n    this.pdfiumModule.pdfium.setValue(pageRectPtr, pageX, "float");\n    this.pdfiumModule.pdfium.setValue(pageRectPtr + 4, pageY, "float");\n    this.pdfiumModule.pdfium.setValue(pageRectPtr + 8, pageX + rect.size.width, "float");\n    this.pdfiumModule.pdfium.setValue(pageRectPtr + 12, pageY - rect.size.height, "float");\n    if (!this.pdfiumModule.FPDFAnnot_SetRect(annotationPtr, pageRectPtr)) {\n      this.free(pageRectPtr);\n      return false;\n    }\n    this.free(pageRectPtr);\n    return true;\n  }\n  /**\n   * Read the rectangle of annotation\n   * @param annotationPtr - pointer to pdf annotation\n   * @returns rectangle of annotation\n   *\n   * @private\n   */\n  readPageAnnoRect(annotationPtr) {\n    const pageRectPtr = this.malloc(4 * 4);\n    const pageRect = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    if (this.pdfiumModule.FPDFAnnot_GetRect(annotationPtr, pageRectPtr)) {\n      pageRect.left = this.pdfiumModule.pdfium.getValue(pageRectPtr, "float");\n      pageRect.top = this.pdfiumModule.pdfium.getValue(pageRectPtr + 4, "float");\n      pageRect.right = this.pdfiumModule.pdfium.getValue(pageRectPtr + 8, "float");\n      pageRect.bottom = this.pdfiumModule.pdfium.getValue(pageRectPtr + 12, "float");\n    }\n    this.free(pageRectPtr);\n    return pageRect;\n  }\n  /**\n   * Get highlight rects for a specific character range (for search highlighting)\n   * @param page - pdf page info\n   * @param pagePtr - pointer to pdf page\n   * @param textPagePtr - pointer to pdf text page\n   * @param startIndex - starting character index\n   * @param charCount - number of characters in the range\n   * @returns array of rectangles for highlighting the specified character range\n   *\n   * @private\n   */\n  getHighlightRects(page, pagePtr, textPagePtr, startIndex, charCount) {\n    const rectsCount = this.pdfiumModule.FPDFText_CountRects(textPagePtr, startIndex, charCount);\n    const highlightRects = [];\n    for (let i = 0; i < rectsCount; i++) {\n      const topPtr = this.malloc(8);\n      const leftPtr = this.malloc(8);\n      const rightPtr = this.malloc(8);\n      const bottomPtr = this.malloc(8);\n      const isSucceed = this.pdfiumModule.FPDFText_GetRect(\n        textPagePtr,\n        i,\n        leftPtr,\n        topPtr,\n        rightPtr,\n        bottomPtr\n      );\n      if (!isSucceed) {\n        this.free(leftPtr);\n        this.free(topPtr);\n        this.free(rightPtr);\n        this.free(bottomPtr);\n        continue;\n      }\n      const left = this.pdfiumModule.pdfium.getValue(leftPtr, "double");\n      const top = this.pdfiumModule.pdfium.getValue(topPtr, "double");\n      const right = this.pdfiumModule.pdfium.getValue(rightPtr, "double");\n      const bottom = this.pdfiumModule.pdfium.getValue(bottomPtr, "double");\n      this.free(leftPtr);\n      this.free(topPtr);\n      this.free(rightPtr);\n      this.free(bottomPtr);\n      const deviceXPtr = this.malloc(4);\n      const deviceYPtr = this.malloc(4);\n      this.pdfiumModule.FPDF_PageToDevice(\n        pagePtr,\n        0,\n        0,\n        page.size.width,\n        page.size.height,\n        0,\n        left,\n        top,\n        deviceXPtr,\n        deviceYPtr\n      );\n      const x = this.pdfiumModule.pdfium.getValue(deviceXPtr, "i32");\n      const y = this.pdfiumModule.pdfium.getValue(deviceYPtr, "i32");\n      this.free(deviceXPtr);\n      this.free(deviceYPtr);\n      const width = Math.ceil(Math.abs(right - left));\n      const height = Math.ceil(Math.abs(top - bottom));\n      highlightRects.push({\n        origin: { x, y },\n        size: { width, height }\n      });\n    }\n    return highlightRects;\n  }\n  /**\n   * {@inheritDoc @embedpdf/models!PdfEngine.searchAllPages}\n   *\n   * Runs inside the worker.\n   * Emits per-page progress: { page, results }\n   *\n   * @public\n   */\n  searchAllPages(doc, keyword, flags = []) {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, "searchAllPages", doc, keyword, flags);\n    this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "SearchAllPages", "Begin", doc.id);\n    const ctx = this.cache.getContext(doc.id);\n    if (!ctx) {\n      this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "SearchAllPages", "End", doc.id);\n      return PdfTaskHelper.resolve({\n        results: [],\n        total: 0\n      });\n    }\n    const length = 2 * (keyword.length + 1);\n    const keywordPtr = this.malloc(length);\n    this.pdfiumModule.pdfium.stringToUTF16(keyword, keywordPtr, length);\n    const flag = flags.reduce((acc, f) => acc | f, MatchFlag.None);\n    const task = PdfTaskHelper.create();\n    let cancelled = false;\n    task.wait(\n      () => {\n      },\n      (err) => {\n        if (err.type === "abort") cancelled = true;\n      }\n    );\n    const CHUNK_SIZE = 100;\n    const allResults = [];\n    const processChunk = (startIdx) => {\n      if (cancelled) return;\n      const endIdx = Math.min(startIdx + CHUNK_SIZE, doc.pageCount);\n      try {\n        for (let pageIndex = startIdx; pageIndex < endIdx && !cancelled; pageIndex++) {\n          const pageResults = this.searchAllInPage(ctx, doc.pages[pageIndex], keywordPtr, flag);\n          allResults.push(...pageResults);\n          task.progress({ page: pageIndex, results: pageResults });\n        }\n      } catch (e) {\n        if (!cancelled) {\n          this.free(keywordPtr);\n          this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "SearchAllPages", "End", doc.id);\n          task.reject({\n            code: PdfErrorCode.Unknown,\n            message: `Error searching document: ${e}`\n          });\n        }\n        return;\n      }\n      if (cancelled) return;\n      if (endIdx >= doc.pageCount) {\n        this.free(keywordPtr);\n        this.logger.perf(LOG_SOURCE, LOG_CATEGORY, "SearchAllPages", "End", doc.id);\n        task.resolve({ results: allResults, total: allResults.length });\n        return;\n      }\n      setTimeout(() => processChunk(endIdx), 0);\n    };\n    setTimeout(() => processChunk(0), 0);\n    task.wait(\n      () => {\n      },\n      (err) => {\n        if (err.type === "abort") {\n          try {\n            this.free(keywordPtr);\n          } catch {\n          }\n        }\n      }\n    );\n    return task;\n  }\n  /**\n   * Extract word-aligned context for a search hit.\n   *\n   * @param fullText      full UTF-16 page text (fetch this once per page!)\n   * @param start         index of 1st char that matched\n   * @param count         number of chars in the match\n   * @param windowChars   minimum context chars to keep left & right\n   */\n  buildContext(fullText, start, count, windowChars = 30) {\n    const WORD_BREAK = /[\\s\\u00A0.,;:!?()\\[\\]{}<>/\\\\\\-"\'`"”\\u2013\\u2014]/;\n    const findWordStart = (index) => {\n      while (index > 0 && !WORD_BREAK.test(fullText[index - 1])) index--;\n      return index;\n    };\n    const findWordEnd = (index) => {\n      while (index < fullText.length && !WORD_BREAK.test(fullText[index])) index++;\n      return index;\n    };\n    let left = start;\n    while (left > 0 && WORD_BREAK.test(fullText[left - 1])) left--;\n    let collected = 0;\n    while (left > 0 && collected < windowChars) {\n      left--;\n      if (!WORD_BREAK.test(fullText[left])) collected++;\n    }\n    left = findWordStart(left);\n    let right = start + count;\n    while (right < fullText.length && WORD_BREAK.test(fullText[right])) right++;\n    collected = 0;\n    while (right < fullText.length && collected < windowChars) {\n      if (!WORD_BREAK.test(fullText[right])) collected++;\n      right++;\n    }\n    right = findWordEnd(right);\n    const before = fullText.slice(left, start).replace(/\\s+/g, " ").trimStart();\n    const match = fullText.slice(start, start + count);\n    const after = fullText.slice(start + count, right).replace(/\\s+/g, " ").trimEnd();\n    return {\n      before: this.tidy(before),\n      match: this.tidy(match),\n      after: this.tidy(after),\n      truncatedLeft: left > 0,\n      truncatedRight: right < fullText.length\n    };\n  }\n  /**\n   * Tidy the text to remove any non-printable characters and whitespace\n   * @param s - text to tidy\n   * @returns tidied text\n   *\n   * @private\n   */\n  tidy(s) {\n    return s.replace(/-\\uFFFE\\s*/g, "").replace(/[\\uFFFE\\u00AD\\u200B\\u2060\\uFEFF]/g, "").replace(/\\s+/g, " ");\n  }\n  /**\n   * Search for all occurrences of a keyword on a single page\n   * This method efficiently loads the page only once and finds all matches\n   *\n   * @param docPtr - pointer to pdf document\n   * @param page - pdf page object\n   * @param pageIndex - index of the page\n   * @param keywordPtr - pointer to the search keyword\n   * @param flag - search flags\n   * @returns array of search results on this page\n   *\n   * @private\n   */\n  searchAllInPage(ctx, page, keywordPtr, flag) {\n    return ctx.borrowPage(page.index, (pageCtx) => {\n      const textPagePtr = pageCtx.getTextPage();\n      const total = this.pdfiumModule.FPDFText_CountChars(textPagePtr);\n      const bufPtr = this.malloc(2 * (total + 1));\n      this.pdfiumModule.FPDFText_GetText(textPagePtr, 0, total, bufPtr);\n      const fullText = this.pdfiumModule.pdfium.UTF16ToString(bufPtr);\n      this.free(bufPtr);\n      const pageResults = [];\n      const searchHandle = this.pdfiumModule.FPDFText_FindStart(\n        textPagePtr,\n        keywordPtr,\n        flag,\n        0\n        // Start from the beginning of the page\n      );\n      while (this.pdfiumModule.FPDFText_FindNext(searchHandle)) {\n        const charIndex = this.pdfiumModule.FPDFText_GetSchResultIndex(searchHandle);\n        const charCount = this.pdfiumModule.FPDFText_GetSchCount(searchHandle);\n        const rects = this.getHighlightRects(\n          page,\n          pageCtx.pagePtr,\n          textPagePtr,\n          charIndex,\n          charCount\n        );\n        const context = this.buildContext(fullText, charIndex, charCount);\n        pageResults.push({\n          pageIndex: page.index,\n          charIndex,\n          charCount,\n          rects,\n          context\n        });\n      }\n      this.pdfiumModule.FPDFText_FindClose(searchHandle);\n      return pageResults;\n    });\n  }\n}\nclass PdfiumEngineRunner extends EngineRunner {\n  /**\n   * Create an instance of PdfiumEngineRunner\n   * @param wasmBinary - wasm binary that contains the pdfium wasm file\n   */\n  constructor(wasmBinary) {\n    super();\n    this.wasmBinary = wasmBinary;\n  }\n  /**\n   * Initialize runner\n   */\n  async prepare() {\n    const wasmBinary = this.wasmBinary;\n    const wasmModule = await init({ wasmBinary });\n    this.engine = new PdfiumEngine(wasmModule);\n    this.ready();\n  }\n}\nlet runner = null;\nself.onmessage = async (event) => {\n  const { type, wasmUrl } = event.data;\n  if (type === "wasmInit" && wasmUrl && !runner) {\n    try {\n      const response = await fetch(wasmUrl);\n      const wasmBinary = await response.arrayBuffer();\n      runner = new PdfiumEngineRunner(wasmBinary);\n      await runner.prepare();\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      self.postMessage({ type: "wasmError", error: message });\n    }\n  }\n};\n'],{type:"application/javascript"})),{type:"module"});return t.postMessage({type:"wasmInit",wasmUrl:n}),new d(t,e)}export{u as createPdfiumEngine};
