\documentclass[aspectratio=169, lualatex, handout]{beamer}
\makeatletter\def\input@path{{theme/}}\makeatother\usetheme{cipher}

\title{Applied Cryptography - 2.8: Zero-Knowledge Proofs}
\author{Nadim Kobeissi}
\subject{TODO}
\keywords{TODO}
\institute{American University of Beirut}
\instituteimage{images/aub_white.png}
\date{\today}
\coversubtitle{CMPS 297AD/396AI\\Fall 2025}
\coverpartname{Part 2: Real-World Cryptography}
\covertopicname{2.8: Zero-Knowledge Proofs}
\coverwebsite{https://appliedcryptography.page}

\begin{document}
\begin{frame}[plain]
	\titlepage
\end{frame}

\incompleteslideswarning

\section{Introduction}

\begin{frame}{Zero-knowledge proofs: magic, but real}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{Imagine this scenario:}
			\begin{itemize}
				\item I claim to know the password to a secret vault
				\item You need to verify I really know it
				\item But I don't want to tell you the password!
			\end{itemize}
			\textbf{Seems impossible?}
			\begin{itemize}
				\item How can I prove knowledge without revealing it?
				\item This is the magic of zero-knowledge proofs
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{block}{Zero-knowledge property}
				A proof that reveals \textbf{nothing} except the truth of the statement being proven
			\end{block}
			\vspace{0.5em}
			\begin{alertblock}{The paradox}
				Convince you completely while teaching you nothing
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{What makes zero-knowledge proofs special?}
	\textbf{Traditional proof:}
	\begin{itemize}
		\item ``Here's my password: \texttt{hunter2}''
		\item You learn the secret itself
		\item You could now impersonate me
	\end{itemize}
	\textbf{Zero-Knowledge proof:}
	\begin{itemize}
		\item ``I'll convince you I know the password''
		\item You learn \textit{only} that I know it
		\item You gain no ability to prove it yourself
		\item You can't replay my proof to others
	\end{itemize}
\end{frame}

\begin{frame}{The three zero-knowledge properties}
	\begin{block}{1. Completeness}
		If the statement is true, an honest prover can convince an honest verifier
	\end{block}
	\begin{block}{2. Soundness}
		If the statement is false, no cheating prover can convince an honest verifier (except with negligible probability)
	\end{block}
	\begin{block}{3. Zero-Knowledge}
		The verifier learns nothing beyond the validity of the statement
	\end{block}
	\vspace{0.25em}
	\begin{center}
		\textbf{These three properties together create the ``magic''}
	\end{center}
\end{frame}

\begin{frame}{Example: Proving Knowledge of a Private Key}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{The Setup:}
			\begin{itemize}
				\item Public key: $A = g^{a}$
				\item I claim to know $a$
				\item But revealing $a$ would compromise security
			\end{itemize}
			\textbf{Zero-Knowledge Solution:}
			\begin{enumerate}
				\item Interactive protocol
				\item Multiple rounds of challenges
				\item Statistically convincing
				\item Reveals nothing about $a$
			\end{enumerate}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{alertblock}{Can't prove to others}
				After our interaction:
				\begin{itemize}
					\item You're 100\% convinced I know $a$
					\item You've learned nothing about $a$
					\item You can't prove to others that I know it
				\end{itemize}
			\end{alertblock}
			\vspace{0.5em}
			\begin{exampleblock}{No ``trace'' or ``evidence''}
				The interaction leaves no transferable evidence
			\end{exampleblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Schnorr Identification Protocol}
	\vspace{-1.5cm}
	\begin{center}\resizebox{0.8\textwidth}{!}{
			\begin{msc}{}
				\setmscvalues{small}
				\drawframe{none}
				\setlength{\instdist}{8cm}
				\setlength{\instwidth}{2cm}
				\declinst{prover}{}{Prover}
				\declinst{verifier}{}{Verifier}
				\action*{$\begin{array}{l}
							\text{Knows generator}~g         \\
							\text{Knows prime}~n             \\
							\text{Knows secret}~a            \\
							y \twoheadleftarrow \mathbb{Z}_n \\
							Y = g^y
						\end{array}$}{prover}
				\action*{$\begin{array}{l}
							\text{Knows generator}~g                 \\
							\text{Knows prime}~n                     \\
							\text{Knows prover's public key}~A = g^a \\
						\end{array}$}{verifier}
				\nextlevel[7]
				\mess{$Y$}{prover}{verifier}
				\nextlevel[1]
				\action*{$c \twoheadleftarrow \mathbb{Z}_n$}{verifier}
				\nextlevel[2]
				\mess{$c$}{verifier}{prover}
				\nextlevel[1]
				\action*{$r = (y + ca) \bmod n$}{prover}
				\nextlevel[2]
				\mess{$r$}{prover}{verifier}
				\nextlevel[1]
				\action*{$g^r \overset{?}{\equiv} Y \cdot A^c$}{verifier}
				\nextlevel[2]
			\end{msc}
		}\end{center}
\end{frame}

\begin{frame}{Schnorr Identification Protocol}
	\begin{columns}[c]
		\begin{column}{0.6\textwidth}
			\begin{itemize}
				\item \textbf{Interactive proof:} Multiple rounds of communication
				\item \textbf{Commitment phase:} Prover commits to random $Y = g^y$
				\item \textbf{Challenge phase:} Verifier sends random challenge $c$
				\item \textbf{Response phase:} Prover computes $r = y + ca$
				\item \textbf{Verification:} Check if $g^r = Y \cdot A^c$
				\item \textbf{Zero-knowledge property:} $r$ reveals nothing about $a$ due to random masking by $y$
				\item \textbf{Soundness:} Without knowing $a$, prover can't answer random challenges correctly
			\end{itemize}
		\end{column}
		\begin{column}{0.4\textwidth}
			\vspace{-1.5cm}
			\begin{center}\resizebox{1\textwidth}{!}{
					\begin{msc}{}
						\setmscvalues{small}
						\drawframe{none}
						\setlength{\instdist}{8cm}
						\setlength{\instwidth}{2cm}
						\declinst{prover}{}{Prover}
						\declinst{verifier}{}{Verifier}
						\action*{$\begin{array}{l}
									\text{Knows generator}~g         \\
									\text{Knows prime}~n             \\
									\text{Knows secret}~a            \\
									y \twoheadleftarrow \mathbb{Z}_n \\
									Y = g^y
								\end{array}$}{prover}
						\action*{$\begin{array}{l}
									\text{Knows generator}~g                 \\
									\text{Knows prime}~n                     \\
									\text{Knows prover's public key}~A = g^a \\
								\end{array}$}{verifier}
						\nextlevel[7]
						\mess{$Y$}{prover}{verifier}
						\nextlevel[1]
						\action*{$c \twoheadleftarrow \mathbb{Z}_n$}{verifier}
						\nextlevel[2]
						\mess{$c$}{verifier}{prover}
						\nextlevel[1]
						\action*{$r = (y + ca) \bmod n$}{prover}
						\nextlevel[2]
						\mess{$r$}{prover}{verifier}
						\nextlevel[1]
						\action*{$g^r \overset{?}{\equiv} Y \cdot A^c$}{verifier}
						\nextlevel[2]
					\end{msc}
				}\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{The verifier learned literally nothing new}
	\begin{columns}[c]
		\begin{column}{0.55\textwidth}
			\begin{itemize}
				\item After the protocol, you're convinced I know the secret
				\item But you can't convince anyone else!
				\item Why? The transcript looks identical to \textbf{something you could have generated alone}
				\item \textbf{The simulation argument:}
				      \begin{itemize}
					      \item You could have picked $r$ and $c$ randomly
					      \item Then computed $Y = g^r / A^c$
					      \item This produces a valid-looking transcript!
					      \item No way to distinguish from real interaction
				      \end{itemize}
			\end{itemize}
		\end{column}
		\begin{column}{0.45\textwidth}
			\resizebox{0.8\textwidth}{!}{%
				\begin{minipage}{\textwidth}
					\begin{alertblock}{Self-generated transcripts}
						For any challenge $c$ and response $r$:
						\begin{itemize}
							\item Set $Y = g^r / A^c$
							\item Now $(Y, c, r)$ is a valid transcript
							\item Indistinguishable from real protocol
							\item Real interaction: Prover knows secret
							\item Simulated transcript: No secret needed
							\item Both look exactly the same!
							\item This is what makes it ``zero-knowledge''
						\end{itemize}
					\end{alertblock}
				\end{minipage}%
			}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{In other words\ldots}
	\begin{center}
		\sslinked{
			\sslibrary{}{schnorr-real}{
				\sslibrarysubroutine{schnorr.transcript}{a}{
					$A := g^a$ \\
					$y \twoheadleftarrow \mathbb{Z}_n$ \\
					$Y := g^y$ \\
					$c \twoheadleftarrow \mathbb{Z}_n$ \\
					$r := (y + ca) \bmod n$ \\
					return $(A, Y, c, r)$
				}{1}
			}{1}
		}{\interchangeable}{
			\sslibrary{}{schnorr-fake}{
				\sslibrarysubroutine{schnorr.transcript}{a}{
					$A := g^a$ \\
					$c \twoheadleftarrow \mathbb{Z}_n$ \\
					$r \twoheadleftarrow \mathbb{Z}_n$ \\
					$Y := g^r \cdot (A^c)^{-1}$ \\
					return $(A, Y, c, r)$
				}{1}
			}{1}
		}
	\end{center}
\end{frame}

\begin{frame}{Quick reminder: What does $x^{-1}$ mean?}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{In modular arithmetic:}
			\begin{itemize}
				\item $x^{-1}$ is the \textbf{modular inverse} of $x$
				\item It's the number that, when multiplied by $x$, gives 1
				\item $x \cdot x^{-1} \equiv 1 \pmod{n}$
			\end{itemize}
			\textbf{Example:}
			\begin{itemize}
				\item If $x = 3$ and $n = 7$
				\item Then $x^{-1} = 5$ because $3 \cdot 5 = 15 \equiv 1 \pmod{7}$
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{In group elements:}
			\begin{itemize}
				\item If $A = g^a$, then $A^{-1} = g^{-a}$
				\item $A \cdot A^{-1} = g^a \cdot g^{-a} = g^{a-a} = g^0 = 1$
				\item It's the element that ``cancels out'' $A$
			\end{itemize}
			\begin{alertblock}{Key property}
				$(A^c)^{-1} = A^{-c}$ \\
				This is why we can rewrite expressions!
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Proof of indistinguishability}{Step 1}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}[<+->]
				\item We can rearrange things so that $c$ is chosen first.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{center}
				\sslibrary{}{schnorr-real}{
					\sslibrarysubroutine{schnorr.transcript}{a}{
						$A := g^a$ \\
						$c \twoheadleftarrow \mathbb{Z}_n$ \\
						\hl{$y \twoheadleftarrow \mathbb{Z}_n$} \\
						$r := (y + ca) \bmod n$ \\
						\hl{$Y := g^y$} \\
						return $(A, Y, c, r)$
					}{1}
				}{1}
			\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Proof of indistinguishability}{Step 2}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}[<+->]
				\item $r$ is essentially a OTP encryption of plaintext $ca$ under key $y$, using a variant of OTP with addition $\bmod\ n$.
				\item We can achieve the same distribution by choosing $r$ uniformly and solving for $y$.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{center}
				\sslibrary{}{schnorr-real}{
					\sslibrarysubroutine{schnorr.transcript}{a}{
						$A := g^a$ \\
						$c \twoheadleftarrow \mathbb{Z}_n$ \\
						\hl{$r \twoheadleftarrow \mathbb{Z}_n$} \\
						\hl{$y := (r - ca) \bmod n$} \\
						$Y := g^y$ \\
						return $(A, Y, c, r)$
					}{1}
				}{1}
			\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Proof of indistinguishability}{Step 3}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}[<+->]
				\item $Y$ is computed as
				      \begin{align*}
					      Y & = g^y                       \\
					        & = g^{r-ca}                  \\
					        & = g^{r} \cdot (g^{ca})^{-1} \\
					        & = g^{r} \cdot (A^{c})^{-1}
				      \end{align*}
				\item By rewriting $Y$ in this way, the private exponent $a$ is no longer needed.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{center}
				\sslibrary{}{schnorr-fake}{
					\sslibrarysubroutine{schnorr.transcript}{a}{
						$A := g^a$ \\
						$c \twoheadleftarrow \mathbb{Z}_n$ \\
						$r \twoheadleftarrow \mathbb{Z}_n$ \\
						$y := (r - ca) \bmod n$ \\
						\hl{$Y := g^r \cdot (A^c)^{-1}$} \\
						return $(A, Y, c, r)$
					}{1}
				}{1}
			\end{center}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Understanding the exponent manipulation}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{Why does $g^{r-ca} = g^r \cdot (g^{ca})^{-1}$?}
			\begin{itemize}
				\item Recall the exponent rule: $g^{x-y} = \frac{g^x}{g^y}$
				\item In group notation, division is multiplication by inverse
				\item So $\frac{g^x}{g^y} = g^x \cdot (g^y)^{-1}$
			\end{itemize}
			\textbf{Step by step:}
			\begin{enumerate}
				\item $g^{r-ca} = \frac{g^r}{g^{ca}}$ (exponent rule)
				\item $\frac{g^r}{g^{ca}} = g^r \cdot (g^{ca})^{-1}$ (division = multiply by inverse)
			\end{enumerate}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{exampleblock}{Concrete example}
				Let's use regular numbers to see why:
				\begin{itemize}
					\item If $g = 2$, $r = 7$, $ca = 3$
					\item $2^{7-3} = 2^4 = 16$
					\item $2^7 \cdot (2^3)^{-1} = 128 \cdot \frac{1}{8} = 16$ \mycheckmark
				\end{itemize}
			\end{exampleblock}
			\vspace{0.5em}
			\begin{alertblock}{Observe how\ldots}
				This manipulation lets us separate the secret exponent $a$ from the computation!
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{In other words\ldots}
	\begin{center}
		\sslinked{
			\sslibrary{}{schnorr-real}{
				\sslibrarysubroutine{schnorr.transcript}{a}{
					$A := g^a$ \\
					$y \twoheadleftarrow \mathbb{Z}_n$ \\
					$Y := g^y$ \\
					$c \twoheadleftarrow \mathbb{Z}_n$ \\
					$r := (y + ca) \bmod n$ \\
					return $(A, Y, c, r)$
				}{1}
			}{1}
		}{\interchangeable}{
			\sslibrary{}{schnorr-fake}{
				\sslibrarysubroutine{schnorr.transcript}{a}{
					$A := g^a$ \\
					$c \twoheadleftarrow \mathbb{Z}_n$ \\
					$r \twoheadleftarrow \mathbb{Z}_n$ \\
					$Y := g^r \cdot (A^c)^{-1}$ \\
					return $(A, Y, c, r)$
				}{1}
			}{1}
		}
	\end{center}
\end{frame}

\begin{frame}{A parable}
	\begin{center}
		\vfill
		\large
		\textit{\rmfamily ``King Richard decides to hold an archery competition to identify the best archer in the land. He constructs a long wooden wall, with many targets painted on it. During the competition, he is stunned as Robin Hood stands 100 meters away from the wall and fires one arrow into the center of each of the targets. Of course, Robin Hood is declared the winner.''}
		\vfill
	\end{center}
\end{frame}

\begin{frame}{A parable}
	\begin{center}
		\vfill
		\large
		\textit{\rmfamily ``Later that day, the Sheriff of Nottingham arrives at the King's castle. The King describes Robin Hood's exceptional performance, pointing to the arrows still in the targets. The Sheriff is not impressed. “Robin Hood is a fraud and a liar. Those arrows prove nothing,” he says. He takes his own bow and fires a series of arrows into blank parts of the wall. He finds a bucket of paint and paints a target around each of his arrows. ``See,'' he says again, ``arrows in targets prove nothing!''''}
		\vfill
	\end{center}
\end{frame}

\begin{frame}{Another parable}
	\begin{center}
		\vfill
		\large
		\textit{\rmfamily ``Alice, whose public key is $A = g^a$, contacts Bob and uses Schnorr's protocol to prove that she knows the secret key $a$. Bob is convinced that he is talking to Alice, and he writes down everything he sees: $(A, Y, c, r)$.''}
		\vfill
	\end{center}
\end{frame}

\begin{frame}{Another parable}
	\begin{center}
		\vfill
		\large
		\textit{\rmfamily ``Later that day, Charlie arrives at Bob's house. Bob mentions that he talked to Alice earlier in the day, and he shows Charlie the accepting transcript $(A,Y,c,r)$. ``That proves nothing,'' says Charlie, and he proceeds to generate his own accepting transcript $(A,Y',c',r')$, even though he doesn't know $a$.''}
		\vfill
	\end{center}
\end{frame}

\section{Sigma Protocols}

\begin{frame}{ZK can scale to entire systems}{Reminder}
	\begin{columns}[c]
		\begin{column}{0.6\textwidth}
			\begin{itemize}[<+->]
				\item As seen previously, you can build entire \textbf{zero-knowledge protocols}, not just primitives that prove knowledge of certain numbers.
				\item ``Zero-knowledge virtual machines'' where you can execute
				      an entire program that runs as a zero-knowledge proof.
				\item ZKP battleship game: server proves to the players that its
				      output to their battleship guesses is correct, without revealing any
				      additional information (e.g. ship location).
			\end{itemize}
		\end{column}
		\begin{column}{0.4\textwidth}
			\imagewithcaption{battleship.jpg}{Battleship board game. Source: Hasbro}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Beyond authentication: the power of zero-knowledge}
	\begin{center}
		\textbf{Zero-knowledge is not limited to proving identity!}
	\end{center}
	\vspace{0.25em}
	\begin{columns}[c]
		\begin{column}{0.6\textwidth}
			\begin{itemize}
				\item \textbf{Can prove statements like:}
				      \begin{itemize}
					      \item \textit{``I know a solution to this Sudoku puzzle''}
					      \item \textit{``This encrypted value is in range [0, 100]''} (range proofs)
					      \item \textit{``I performed this computation correctly''}
					      \item \ldots without revealing any information!
				      \end{itemize}
			\end{itemize}
		\end{column}
		\begin{column}{0.4\textwidth}
			\begin{itemize}
				\item \textbf{Applications:}
				      \begin{itemize}
					      \item Private transactions (Zcash)
					      \item Anonymous credentials
					      \item Secure voting systems
					      \item Privacy-preserving audits
				      \end{itemize}
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\subsection{Sigma Protocols: High-Level Overview}

\begin{frame}{From Schnorr to Sigma, a general framework}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{Schnorr was just the beginning!}
			\begin{itemize}
				\item Schnorr proves: ``I know $a$ such that $g^a = A$''
				\item What if we want to prove other statements?
				\item Enter \textbf{Sigma protocols}: a general framework
			\end{itemize}
			\vspace{0.5em}
			\textbf{The pattern:}
			\begin{itemize}
				\item Public instance: $X$
				\item Private witness: $W$
				\item Relation: $R(X, W) = \text{true}$
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{exampleblock}{Examples of relations}
				\begin{itemize}
					\item ``I know $a$ such that $g^a = X$''
					\item ``I know $(r, s)$ such that $g^r h^s = X$''
					\item ``I know a factorization of $X$''
					\item ``I know a graph coloring for $X$''
				\end{itemize}
			\end{exampleblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Sigma protocol structure}
	\vspace{-1.5cm}
	\begin{center}\resizebox{0.8\textwidth}{!}{
			\begin{msc}{}
				\setmscvalues{small}
				\drawframe{none}
				\setlength{\instdist}{8cm}
				\setlength{\instwidth}{2cm}
				\declinst{prover}{}{Prover}
				\declinst{verifier}{}{Verifier}
				\action*{$\begin{array}{l}
							\text{Knows instance}~X                \\
							\text{Knows witness}~W                 \\
							\text{Such that}~R(X, W) = \text{true} \\
						\end{array}$}{prover}
				\action*{$\begin{array}{l}
							\text{Knows instance}~X \\
						\end{array}$}{verifier}
				\nextlevel[4]
				\action*{$(Y, \sigma) \leftarrow \text{Commit}(X, W)$}{prover}
				\nextlevel[2]
				\mess{$Y$ (commitment)}{prover}{verifier}
				\nextlevel[1]
				\action*{$c \twoheadleftarrow \mathcal{C}$}{verifier}
				\nextlevel[2]
				\mess{$c$ (challenge)}{verifier}{prover}
				\nextlevel[1]
				\action*{$r \leftarrow \text{Respond}(\sigma, c)$}{prover}
				\nextlevel[2]
				\mess{$r$ (response)}{prover}{verifier}
				\nextlevel[1]
				\action*{$\text{Check}(X, Y, c, r) \overset{?}{=} \text{true}$}{verifier}
				\nextlevel[2]
			\end{msc}
		}\end{center}
\end{frame}

\begin{frame}{Why ``Sigma''? The shape of the protocol}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{center}
				\huge
				\begin{tikzpicture}
					\node (P1) at (0,0) {Prover};
					\node (V1) at (4,0) {Verifier};
					\node (P2) at (0,-2) {};
					\node (V2) at (4,-2) {};
					\node (P3) at (0,-4) {};
					\node (V3) at (4,-4) {};

					\draw[->, thick] (P1) -- node[above] {$Y$} (V1);
					\draw[->, thick] (V2) -- node[above] {$c$} (P2);
					\draw[->, thick] (P3) -- node[above] {$r$} (V3);

					\draw[red, ultra thick] (0.5,-0.5) -- (3.5,-0.5) -- (0.5,-2) -- (3.5,-3.5);
				\end{tikzpicture}
			\end{center}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{The Greek letter $\Sigma$ (Sigma)}
			\begin{itemize}
				\item Three message flows
				\item Alternating direction
				\item Forms a ``zigzag'' pattern
				\item Hence: Sigma protocols!
			\end{itemize}
			\begin{alertblock}{Always this pattern}
				\begin{enumerate}
					\item Prover $\rightarrow$ Verifier: Commitment
					\item Verifier $\rightarrow$ Prover: Challenge
					\item Prover $\rightarrow$ Verifier: Response
				\end{enumerate}
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Formal definition of Sigma protocols}
	\begin{block}{Definition: Sigma Protocol}
		A sigma protocol consists of the following parameters:
		\begin{itemize}
			\item \textbf{Commit}: A randomized algorithm that takes instance $X$ and witness $W$ as input, outputs commitment $Y$ and state $\sigma$
			\item $\mathcal{C}$: A set of verifier challenges
			\item \textbf{Respond}: A deterministic algorithm that takes state $\sigma$ and challenge $c \in \mathcal{C}$ as input, outputs response $r$
			\item \textbf{Check}: A deterministic algorithm that takes transcript $(X, Y, c, r)$ as input, outputs true/false
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{Example: Schnorr as Sigma protocols}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{Instance and Witness:}
			\begin{itemize}
				\item Instance: $X = A = g^a$
				\item Witness: $W = a$
				\item Relation: $g^W = X$
			\end{itemize}
			\textbf{The Algorithms:}
			\begin{itemize}
				\item \textbf{Commit}$(A, a)$:
				      \begin{itemize}
					      \item $y \twoheadleftarrow \mathbb{Z}_n$
					      \item $Y = g^y$
					      \item Return $(Y, \sigma = y)$
				      \end{itemize}
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{itemize}
				\item $\mathcal{C} = \mathbb{Z}_n$ (all possible challenges)
				\item \textbf{Respond}$(\sigma = y, c)$:
				      \begin{itemize}
					      \item Return $r = y + ca \bmod n$
				      \end{itemize}
				\item \textbf{Check}$(A, Y, c, r)$:
				      \begin{itemize}
					      \item Return $(g^r = Y \cdot A^c)$
				      \end{itemize}
			\end{itemize}
			\begin{exampleblock}{Fits the framework!}
				Schnorr is just one example of a Sigma protocol
			\end{exampleblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Example: proving knowledge of a representation}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{The problem:}
			\begin{itemize}
				\item Given: $X = g^a h^b$
				\item Prove: ``I know $(a, b)$''
				\item Without revealing $(a, b)$!
			\end{itemize}
			\textbf{Why is this useful?}
			\begin{itemize}
				\item Pedersen commitments
				\item Mix networks
				\item Electronic voting
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{The Sigma protocol:}
			\begin{itemize}
				\item \textbf{Commit}:
				      \begin{itemize}
					      \item Pick random $r, s$
					      \item $Y = g^r h^s$
					      \item State: $\sigma = (r, s)$
				      \end{itemize}
				\item \textbf{Respond}:
				      \begin{itemize}
					      \item $u = r + ca$
					      \item $v = s + cb$
					      \item Return $(u, v)$
				      \end{itemize}
				\item \textbf{Check}:
				      \begin{itemize}
					      \item $g^u h^v \overset{?}{=} Y \cdot X^c$
				      \end{itemize}
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{The power of Sigma protocols}
	\begin{center}
		\textbf{Sigma protocols can prove almost any statement!}
	\end{center}
	\vspace{0.5em}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{Graph Problems:}
			\begin{itemize}
				\item ``I know a 3-coloring of this graph''
				\item ``I know a Hamiltonian cycle''
				\item ``I know an isomorphism between graphs''
			\end{itemize}
			\textbf{Number Theory:}
			\begin{itemize}
				\item ``I know the square root of $X$ mod $N$''
				\item ``I know the factorization of $N$''
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Cryptographic Statements:}
			\begin{itemize}
				\item ``This ciphertext encrypts 0 or 1''
				\item ``These ciphertexts encrypt the same value''
				\item ``I shuffled these ciphertexts correctly''
			\end{itemize}
			\begin{alertblock}{Universal result}
				Any NP statement has a Sigma protocol!
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\subsection{Formal Properties of Sigma Protocols}

\begin{frame}{The three essential properties}
	\begin{center}
		\textbf{What makes a Sigma protocol actually work?}
	\end{center}
	\vspace{0.5em}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{Mathematical guarantees:}
			\begin{enumerate}
				\item \textbf{Completeness:} Honest provers always succeed
				\item \textbf{Soundness:} Dishonest provers always fail
				\item \textbf{Zero-Knowledge:} Nothing leaks about the witness
			\end{enumerate}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{alertblock}{In proof language}
				\begin{itemize}
					\item Completeness: Every true thing has a valid proof
					\item Soundness: Only true things have valid proofs
					\item Zero-Knowledge: Proofs reveal nothing extra
				\end{itemize}
			\end{alertblock}
		\end{column}
	\end{columns}
	\vspace{0.5em}
	\begin{center}
		\textbf{All three are essential for a useful protocol!}
	\end{center}
\end{frame}

\begin{frame}{Completeness: honest provers always win}
	\begin{block}{Definition: Completeness}
		A Sigma protocol is \textbf{complete} if:
		\begin{itemize}
			\item For any instance $X$ and witness $W$ where $P(X,W) = \text{true}$
			\item When the prover follows the protocol honestly
			\item The verifier \textit{always} accepts
		\end{itemize}
	\end{block}
	\vspace{0.5em}
	\textbf{In other words:}
	\begin{itemize}
		\item If you actually know the secret, you can always prove it
		\item No ``false negatives'' - legitimate users never get rejected
		\item The protocol doesn't accidentally lock out honest participants
	\end{itemize}
\end{frame}

\begin{frame}{Example: Schnorr's completeness}
	\begin{center}
		\textbf{Why does Schnorr always work for honest provers?}
	\end{center}
	\vspace{0.5em}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{The honest execution:}
			\begin{itemize}
				\item Prover knows $a$ where $A = g^a$
				\item Sends $Y = g^y$ for random $y$
				\item Receives challenge $c$
				\item Responds with $r = y + ca$
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Verification always succeeds:}
			\begin{align*}
				g^r & = g^{y + ca}                   \\
				    & = g^y \cdot g^{ca}             \\
				    & = Y \cdot (g^a)^c              \\
				    & = Y \cdot A^c \quad \checkmark
			\end{align*}
		\end{column}
	\end{columns}
	\vspace{0.5em}
	\begin{exampleblock}{Perfect completeness}
		Honest prover succeeds with probability 1
	\end{exampleblock}
\end{frame}

\begin{frame}{Special soundness: cheaters get caught}{Unique to Sigma protocols}
	\begin{columns}[c]
		\begin{column}{0.6\textwidth}
			\textbf{The challenge for cheaters:}
			\begin{itemize}
				\item Prover doesn't know the witness
				\item Must commit to $Y$ before seeing challenge
				\item Can't predict what challenge will be
				\item Must be ready for \textit{any} challenge!
			\end{itemize}
			\vspace{0.5em}
			\textbf{The extraction principle:}
			\begin{itemize}
				\item If you can answer two different challenges\ldots
				\item \ldots for the same commitment $Y$\ldots
				\item \ldots then you must know the witness!
			\end{itemize}
		\end{column}
		\begin{column}{0.4\textwidth}
			\begin{alertblock}{Key insight}
				Being able to handle multiple challenges proves knowledge
			\end{alertblock}
			\vspace{0.5em}
			\begin{exampleblock}{Why ``special''?}
				This specific form of soundness is unique to Sigma protocols
			\end{exampleblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Special soundness: formal definition}
	\begin{block}{Definition: Special Soundness}
		A Sigma protocol has \textbf{special soundness} if there exists an efficient algorithm \textbf{Extract} such that:
		\begin{itemize}
			\item Given two accepting transcripts: $(X, Y, c, r)$ and $(X, Y, c', r')$
			\item With same instance $X$ and commitment $Y$
			\item But different challenges $c \neq c'$
			\item \textbf{Extract}$(X, Y, c, r, c', r')$ outputs witness $W$
			\item Such that $P(X, W) = \text{true}$
		\end{itemize}
	\end{block}
	\vspace{0.5em}
	\textbf{Interpretation:} If you can answer two different challenges for the same commitment, you must know the secret!
\end{frame}

\begin{frame}{Example: extracting from Schnorr}
	\begin{center}
		\textbf{Given two accepting transcripts with same $Y$ but different challenges:}
	\end{center}
	\vspace{0.5em}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{Transcript 1:}
			\begin{itemize}
				\item Commitment: $Y$
				\item Challenge: $c$
				\item Response: $r$
				\item Valid: $g^r = Y \cdot A^c$
			\end{itemize}
			\textbf{Transcript 2:}
			\begin{itemize}
				\item Commitment: $Y$ (same!)
				\item Challenge: $c'$
				\item Response: $r'$
				\item Valid: $g^{r'} = Y \cdot A^{c'}$
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Extract the secret:}
			\begin{align*}
				g^r                & = Y \cdot A^c                \\
				g^{r'}             & = Y \cdot A^{c'}             \\
				\frac{g^r}{g^{r'}} & = \frac{A^c}{A^{c'}}         \\
				g^{r-r'}           & = A^{c-c'}                   \\
				g^{r-r'}           & = g^{a(c-c')}                \\
				r-r'               & = a(c-c') \pmod{n}           \\
				a                  & = \frac{r-r'}{c-c'} \pmod{n}
			\end{align*}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Why extraction implies soundness}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{The contrapositive argument:}
			\begin{itemize}
				\item If prover doesn't know witness\ldots
				\item Then can't produce two valid responses
				\item So can succeed for at most one challenge
				\item But challenge is random!
				\item Probability of guessing right: $\frac{1}{|\mathcal{C}|}$
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{alertblock}{Soundness guarantee}
				Cheating probability $\leq \frac{1}{\text{number of challenges}}$
			\end{alertblock}
			\vspace{0.5em}
			\begin{exampleblock}{For Schnorr}
				$|\mathcal{C}| = n$ (prime order)\\
				Cheating probability $\approx \frac{1}{2^{256}}$\\
				Essentially impossible!
			\end{exampleblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Zero-knowledge: the formal definition}
	\begin{block}{Definition: Zero-Knowledge}
		A Sigma protocol is \textbf{zero-knowledge} if:
		\begin{itemize}
			\item There exists a simulator algorithm that can generate convincing transcripts
			\item Without knowing the witness!
			\item These simulated transcripts are indistinguishable from real ones
		\end{itemize}
	\end{block}
	\vspace{0.5em}
	\textbf{In other words:}
	\begin{itemize}
		\item If fake transcripts look identical to real ones\ldots
		\item And fake transcripts contain no information about the witness\ldots
		\item Then real transcripts must not leak information either!
		\item We saw this earlier when we proved $\lib{}{schnorr-real} \equiv \lib{}{schnorr-fake}$.
	\end{itemize}
\end{frame}

\begin{frame}{Honest-verifier zero-knowledge}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{A subtlety:}
			\begin{itemize}
				\item Sigma protocols are ``honest-verifier'' ZK
				\item Assumes verifier follows the protocol
				\item Chooses challenges randomly
				\item Doesn't try to be clever
			\end{itemize}
			\vspace{0.5em}
			\textbf{What about cheating verifiers?}
			\begin{itemize}
				\item Might choose challenges adaptively
				\item Could try to extract information
				\item Harder to protect against!
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{exampleblock}{Good news}
				For most applications, honest-verifier ZK is sufficient
			\end{exampleblock}
			\vspace{0.5em}
			\begin{alertblock}{Later: Fiat-Shamir}
				We'll see how to make protocols secure against any verifier by removing interaction entirely!
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Putting it all together}
	\begin{center}
		\textbf{A Sigma protocol is useful when it has all three properties:}
	\end{center}
	\vspace{0.5em}
	\begin{columns}[c]
		\begin{column}{0.33\textwidth}
			\begin{block}{Completeness}
				\begin{itemize}
					\item Honest users succeed
					\item No false rejections
					\item Protocol is usable
				\end{itemize}
			\end{block}
		\end{column}
		\begin{column}{0.33\textwidth}
			\begin{block}{Special Soundness}
				\begin{itemize}
					\item Cheaters get caught
					\item Can extract witness
					\item Protocol is secure
				\end{itemize}
			\end{block}
		\end{column}
		\begin{column}{0.33\textwidth}
			\begin{block}{Zero-Knowledge}
				\begin{itemize}
					\item No information leaks
					\item Privacy preserved
					\item Protocol is private
				\end{itemize}
			\end{block}
		\end{column}
	\end{columns}
	\vspace{1em}
	\begin{center}
		\textbf{Together, these properties create the ``magic'' of zero-knowledge proofs!}
	\end{center}
\end{frame}

\section{Proving AND, OR}

\begin{frame}{Combining proofs: AND and OR}
	\begin{center}
		\textbf{What if we need to prove more complex statements?}
	\end{center}
	\vspace{0.5em}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{OR statements:}
			\begin{itemize}
				\item ``I know the private key for $A_1$ OR $A_2$''
				\item ``This vote encrypts YES or NO''
				\item Prove one of several conditions
				\item Without revealing which one!
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{AND statements:}
			\begin{itemize}
				\item ``I know $a$ AND $b$ such that\ldots''
				\item ``These discrete logs are equal''
				\item Prove multiple conditions hold
				\item All must be satisfied
			\end{itemize}
		\end{column}
	\end{columns}
	\vspace{0.5em}
	\begin{alertblock}{The challenge}
		How to combine Sigma protocols while preserving zero-knowledge?
	\end{alertblock}
\end{frame}

\subsection{OR Proofs}

\begin{frame}{Example use cases for OR proofs}
	\begin{columns}[c]
		\begin{column}{0.6\textwidth}
			\textbf{1. Anonymous authentication:}
			\begin{itemize}
				\item Public keys: $A_1, A_2$ (authorized users)
				\item Alice proves she knows one private key
				\item Doesn't reveal which user she is!
			\end{itemize}
			\textbf{2. Electronic voting:}
			\begin{itemize}
				\item Encrypted vote: $C = \text{Enc}(\text{vote})$
				\item Prove: $\text{Dec}(SK, C) \in \{\text{yes}, \text{no}\}$
				\item Ensures valid vote without revealing it
			\end{itemize}
		\end{column}
		\begin{column}{0.4\textwidth}
			\begin{exampleblock}{Key property}
				OR proofs hide \textit{which} condition is satisfied
			\end{exampleblock}
			\begin{alertblock}{Privacy guarantee}
				Verifier learns that at least one condition holds, but not which one
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{The Robin Hood analogy}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}
				\item \textit{Robin Hood has two bows:}
				      \begin{itemize}
					      \item One bow shoots accurately
					      \item One bow is erratic
					      \item King wants proof Robin can shoot well
					      \item But Robin doesn't want to reveal which bow works!
				      \end{itemize}
			\end{itemize}
			\begin{itemize}
				\item \textit{The challenge:}
				      \begin{itemize}
					      \item King draws one target
					      \item Robin must fire both bows
					      \item Arrows must be equidistant from target
				      \end{itemize}
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{itemize}
				\item \textit{Robin's strategy:}
				      \begin{enumerate}
					      \item Fire the erratic bow first (lands randomly)
					      \item Calculate where to place second arrow
					      \item Use accurate bow to hit that exact spot
					      \item Target appears centered between arrows!
				      \end{enumerate}
				\item \textbf{Control over one arrow is enough to satisfy the constraint}
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{OR proofs: the construction}
	\textbf{Given:} Sigma protocols $\Sigma_0$ for condition $P_0$ and $\Sigma_1$ for condition $P_1$\\
	\textbf{Goal:} Prove ``I know $W$ such that $P_0(X,W)$ OR $P_1(X,W)$''
	\vspace{0.5em}
	\begin{block}{The protocol}
		\begin{enumerate}
			\item \textbf{Commit:} Prover sends $(Y_0, Y_1)$ - commitments for both protocols
			\item \textbf{Challenge:} Verifier sends single challenge $C$
			\item \textbf{Constraint:} Prover must provide $(C_0, R_0)$ and $(C_1, R_1)$ such that:
			      \begin{itemize}
				      \item $C_0 + C_1 = C$ (challenges sum to verifier's challenge)
				      \item Both transcripts $(Y_0, C_0, R_0)$ and $(Y_1, C_1, R_1)$ are valid
			      \end{itemize}
		\end{enumerate}
	\end{block}
\end{frame}

\begin{frame}{OR proofs: how it works}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{If prover knows witness for $P_0$:}
			\begin{enumerate}
				\item Generate real $Y_0$ using witness
				\item Simulate fake transcript for $\Sigma_1$:
				      \begin{itemize}
					      \item Choose random $C_1, R_1$
					      \item Compute $Y_1$ backwards
				      \end{itemize}
				\item Receive challenge $C$ from verifier
				\item Set $C_0 = C - C_1$
				\item Use witness to compute real $R_0$
			\end{enumerate}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{Why it's zero-knowledge:}
			\begin{itemize}
				\item One transcript is real
				\item One transcript is simulated
				\item Verifier can't tell which is which!
				\item Distribution looks identical regardless of which witness we have
			\end{itemize}
			\vspace{0.5em}
			\begin{alertblock}{The trick}
				Prover controls one challenge completely, must adapt to the other
			\end{alertblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{OR proof protocol diagram}
	\vspace{-1.5cm}
	\begin{center}\resizebox{0.8\textwidth}{!}{
			\begin{msc}{}
				\setmscvalues{small}
				\drawframe{none}
				\setlength{\instdist}{8cm}
				\setlength{\instwidth}{5cm}
				\declinst{prover}{}{Prover (knows $W$ for $P_b$)}
				\declinst{verifier}{}{Verifier}
				\action*{$\begin{array}{l}
							\text{Generate real commitment for } \Sigma_b            \\
							\text{Simulate fake transcript for } \Sigma_{1-b}        \\
							(Y_{1-b}, C_{1-b}, R_{1-b}) \leftarrow \text{Simulate}() \\
						\end{array}$}{prover}
				\nextlevel[5]
				\mess{$(Y_0, Y_1)$}{prover}{verifier}
				\nextlevel[1]
				\action*{$C \twoheadleftarrow \mathcal{C}$}{verifier}
				\nextlevel[2]
				\mess{$C$}{verifier}{prover}
				\nextlevel[1]
				\action*{$\begin{array}{l}
							C_b := C - C_{1-b} \\
							R_b \leftarrow \text{Respond using witness}
						\end{array}$}{prover}
				\nextlevel[4]
				\mess{$(C_0, R_0, C_1, R_1)$}{prover}{verifier}
				\nextlevel[1]
				\action*{$\begin{array}{l}
							\text{Check: } C_0 + C_1 \overset{?}{=} C            \\
							\text{Check: } \Sigma_0.\text{Verify}(Y_0, C_0, R_0) \\
							\text{Check: } \Sigma_1.\text{Verify}(Y_1, C_1, R_1)
						\end{array}$}{verifier}
				\nextlevel[4]
			\end{msc}
		}\end{center}
\end{frame}

\begin{frame}{Example: proving knowledge of one private key}
	\textbf{Setup:} Public keys $A_0 = g^{a_0}$ and $A_1 = g^{a_1}$\\
	\textbf{Alice knows $a_0$ (but not $a_1$) and wants to prove she knows one of them:}
	\begin{enumerate}
		\item \textbf{Commit phase:}
		      \begin{itemize}
			      \item Real: Pick $y_0 \leftarrow \mathbb{Z}_n$, compute $Y_0 = g^{y_0}$
			      \item Fake: Pick $C_1, R_1 \leftarrow \mathbb{Z}_n$, compute $Y_1 = g^{R_1} \cdot A_1^{-C_1}$
			      \item Send $(Y_0, Y_1)$
		      \end{itemize}
		\item \textbf{Challenge:} Receive $C$ from verifier
		\item \textbf{Response phase:}
		      \begin{itemize}
			      \item Compute $C_0 = C - C_1$
			      \item Compute $R_0 = y_0 + C_0 \cdot a_0$
			      \item Send $(C_0, R_0, C_1, R_1)$
		      \end{itemize}
	\end{enumerate}
	\textbf{Verification:} Check $C_0 + C_1 = C$ and both Schnorr transcripts valid
\end{frame}

\subsection{AND Proofs}

\begin{frame}{AND proofs: proving multiple conditions}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\textbf{The problem:}
			\begin{itemize}
				\item Prove multiple conditions simultaneously
				\item All must be true
				\item Example: ``I know $a$ such that $g_1^a = A_1$ AND $g_2^a = A_2$ AND $g_3^a = A_3$''
			\end{itemize}
			\textbf{Naive approach:}
			\begin{itemize}
				\item Run protocols separately?
				\item Problem: different challenges
				\item Loses zero-knowledge!
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\textbf{The solution:}
			\begin{itemize}
				\item Use the \textit{same} challenge for all
				\item Commit to all statements
				\item Receive one challenge
				\item Respond to all with same challenge
			\end{itemize}
			\vspace{0.5em}
			\begin{exampleblock}{Key insight}
				Reusing the challenge maintains both soundness and zero-knowledge
			\end{exampleblock}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{AND proof construction}
	\textbf{Given:} Sigma protocols $\Sigma_1, \Sigma_2, \ldots, \Sigma_k$ for conditions $P_1, P_2, \ldots, P_k$\\
	\textbf{Goal:} Prove ``I know $W$ such that $P_1(X,W)$ AND $P_2(X,W)$ AND \ldots AND $P_k(X,W)$''
	\vspace{0.5em}
	\begin{block}{The protocol}
		\begin{enumerate}
			\item \textbf{Commit:} Run commit phase for all protocols
			      \begin{itemize}
				      \item $(Y_i, \sigma_i) \leftarrow \Sigma_i.\text{Commit}(X_i, W_i)$ for all $i$
				      \item Send $(Y_1, Y_2, \ldots, Y_k)$
			      \end{itemize}
			\item \textbf{Challenge:} Receive single $C$ from verifier
			\item \textbf{Respond:} Use same $C$ for all protocols
			      \begin{itemize}
				      \item $R_i \leftarrow \Sigma_i.\text{Respond}(\sigma_i, C)$ for all $i$
				      \item Send $(R_1, R_2, \ldots, R_k)$
			      \end{itemize}
			\item \textbf{Verify:} Check all transcripts $(Y_i, C, R_i)$ are valid
		\end{enumerate}
	\end{block}
\end{frame}

\begin{frame}{Example: proving equality of discrete logs}
	\textbf{Setup:} Given $(g_1, g_2, g_3, A_1, A_2, A_3)$ where $A_i = g_i^a$ for same $a$\\
	\textbf{Protocol to prove knowledge of $a$:}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{enumerate}
				\item \textbf{Commit:}
				      \begin{itemize}
					      \item Pick $y \leftarrow \mathbb{Z}_n$
					      \item Compute $Y_1 = g_1^y$
					      \item Compute $Y_2 = g_2^y$
					      \item Compute $Y_3 = g_3^y$
					      \item Send $(Y_1, Y_2, Y_3)$
				      \end{itemize}
				\item \textbf{Challenge:} Receive $C$
			\end{enumerate}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{enumerate}
				\setcounter{enumi}{2}
				\item \textbf{Respond:}
				      \begin{itemize}
					      \item Compute $R = y + C \cdot a$
					      \item Send $R$
				      \end{itemize}
				\item \textbf{Verify:}
				      \begin{itemize}
					      \item Check $g_1^R = Y_1 \cdot A_1^C$
					      \item Check $g_2^R = Y_2 \cdot A_2^C$
					      \item Check $g_3^R = Y_3 \cdot A_3^C$
				      \end{itemize}
			\end{enumerate}
		\end{column}
	\end{columns}
	\vspace{0.5em}
	\begin{alertblock}{Single response proves all!}
		One value $R$ satisfies all three equations iff all discrete logs are equal
	\end{alertblock}
\end{frame}

\begin{frame}{Combining AND and OR}
	\begin{center}
		\textbf{We can build complex logical statements!}
	\end{center}
	\vspace{0.5em}
	\textbf{Example:} ``I know the private key for ($A_1$ OR $A_2$) AND ($B_1$ OR $B_2$)''
	\begin{itemize}
		\item Meaning: I'm one of users $\{A_1, A_2\}$ AND one of users $\{B_1, B_2\}$
		\item Four possible combinations, but verifier learns nothing about which!
	\end{itemize}
	\vspace{0.5em}
	\textbf{Construction approach:}
	\begin{enumerate}
		\item Build OR protocols for each clause
		\item Combine them using AND construction
		\item Result: Single protocol proving the entire statement
	\end{enumerate}
\end{frame}

\section{Non-Interactive Zero-Knowledge Proofs}

\section{Zero-Knowledge Virtual Machines}

\section{Zero-Knowledge Proofs in the Real World}

\incompleteslideswarning

\begin{frame}[plain]
	\titlepage
\end{frame}
\end{document}
