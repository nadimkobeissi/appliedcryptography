\documentclass[aspectratio=169, lualatex, handout]{beamer}
\makeatletter\def\input@path{{theme/}}\makeatother\usetheme{cipher}

\title{Applied Cryptography - 1.2: The Provable Security Mindset}
\author{Nadim Kobeissi}
\subject{Introduction to the One-Time Pad cipher and the provable security mindset in cryptography, covering XOR operations, security proofs, adversary models, and limitations of formal security analysis.}
\keywords{one-time pad, OTP, provable security, XOR, encryption, security proofs, Kerckhoff's principle, cryptographic oracles, adversary models}
\institute{American University of Beirut}
\instituteimage{images/aub-white.png}
\date{\today}
\coversubtitle{CMPS 297AD/396AI\\Fall 2025}
\coverpartname{Part 1: Provable Security}
\covertopicname{1.2: The Provable Security Mindset}
\coverwebsite{https://appliedcryptography.page}

\begin{document}
\begin{frame}[plain]
	\titlepage
\end{frame}

\section{Math Review}

\begin{frame}{Logs \& Exponents}
	\begin{itemize}[<+->]
		\item Key identities to remember:
		      \begin{align*}
			      (x^a)(x^b) & = x^{a+b}             \\
			      (x^a)^b    & = x^{ab}              \\
			      \log_x(ab) & = \log_x a + \log_x b \\
			      a \log_x b & = \log_x(b^a)
		      \end{align*}
		\item \alert{Never write $(x^a)(x^b) = x^{ab}$!}
	\end{itemize}
\end{frame}

\begin{frame}{Modular Arithmetic}{Key definitions}
	\begin{itemize}[<+->]
		\item \textbf{Integers}: $\mathbb{Z} = \{\ldots, -2, -1, 0, 1, 2, \ldots\}$
		\item \textbf{Natural numbers}: $\mathbb{N} = \{0, 1, 2, \ldots\}$
		\item \textbf{Divides}: $n | x$ means $x = kn$ for some integer $k$
		\item \textbf{Example}: $7 | 84$ because $84 = 12 \cdot 7$
	\end{itemize}
\end{frame}

\begin{frame}{The Modulo Operation}
	\begin{itemize}[<+->]
		\item $a \bmod n$ gives the remainder when dividing $a$ by $n$
		\item Result is always in $\{0, 1, \ldots, n-1\}$
		\item \textbf{Even for negative numbers!}
		      \begin{align*}
			      21 \bmod 7  & = 0                        \\
			      20 \bmod 7  & = 6                        \\
			      -20 \bmod 7 & = 1 \quad \text{(not -6!)}
		      \end{align*}
		\item Think: ``$a$ is $(a \bmod n)$ more than a multiple of $n$''
	\end{itemize}
\end{frame}

\begin{frame}{Understanding Modulo with clocks}
	\begin{columns}[c]
		\column{0.5\textwidth}{
			\begin{itemize}[<+->]
				\item Clock arithmetic is modulo 12
				\item 15:00 = 3:00 PM because $15 \bmod 12 = 3$
				\item 7 hours after 9:00?
				      \begin{itemize}[<+->]
					      \item $(9 + 7) \bmod 12 = 16 \bmod 12 = 4$
				      \end{itemize}
				\item 5 hours before 2:00?
				      \begin{itemize}[<+->]
					      \item $(2 - 5) \bmod 12 = -3 \bmod 12 = 9$
				      \end{itemize}
				\item Wrapping around: when we go past 12, we start over from 1
			\end{itemize}
		}
		\column{0.5\textwidth}{
			\begin{center}
				\begin{tikzpicture}[scale=1.2]
					\draw[thick] (0,0) circle (2cm);
					\foreach \hour in {1,2,...,12} {
							\pgfmathsetmacro{\angle}{90 - \hour * 30}
							\draw[thick] (\angle:1.8cm) -- (\angle:2cm);
							\node at (\angle:1.5cm) {\hour};
						}
					\draw[thick, ->, red] (0,0) -- (0:1.2cm);
					\draw[thick, ->, blue] (0,0) -- (90:1.6cm);
					\fill (0,0) circle (2pt);
					\node[below] at (0,-2.5cm) {\small Example: 15:00 = 3:00pm};
				\end{tikzpicture}
			\end{center}
		}
	\end{columns}
\end{frame}

\begin{frame}{Binary Strings}
	\begin{itemize}[<+->]
		\item $\bits^n$ = set of $n$-bit binary strings
		\item $\bits^*$ = set of all finite-length binary strings
		\item $|x|$ = length of string $x$
		\item $\bit{0}^n$ = string of $n$ zeros, $\bit{1}^n$ = string of $n$ ones
	\end{itemize}
\end{frame}

\begin{frame}{XOR (Exclusive OR) operation}
	\begin{columns}[c]
		\column{0.6\textwidth}{
			\begin{table}
				\centering
				\begin{tabular}{|c|c|c|}
					\hline
					\textbf{A} & \textbf{B} & \textbf{A $\oplus$ B} \\
					\hline
					\bit{0}    & \bit{0}    & \bit{0}               \\
					\hline
					\bit{0}    & \bit{1}    & \bit{1}               \\
					\hline
					\bit{1}    & \bit{0}    & \bit{1}               \\
					\hline
					\bit{1}    & \bit{1}    & \bit{0}               \\
					\hline
				\end{tabular}
				\caption{Truth table for XOR operation}
			\end{table}
			\begin{itemize}
				\item XOR returns 1 when inputs differ
				\item XOR returns 0 when inputs are the same
				\item Key property: $x \oplus x = 0$ and $x \oplus 0 = x$
				\item Self-inverse: $(M \oplus K) \oplus K = M$
			\end{itemize}
		}
		\column{0.4\textwidth}{
			\begin{center}
				\begin{tikzpicture}[scale=0.8]
					\draw[thick] (0,0) circle (1.5);
					\draw[thick] (1,0) circle (1.5);
					\node at (0,-2) {A};
					\node at (1,-2) {B};
					\begin{scope}
						\clip (0,0) circle (1.5);
						\clip (1,0) circle (1.5);
						\fill[cyan!30] (-1.5,-1.5) rectangle (2.5,1.5);
					\end{scope}
					\draw[thick] (0,0) circle (1.5);
					\draw[thick] (1,0) circle (1.5);
					\node at (0.5,0) {$A \oplus B$};
				\end{tikzpicture}
			\end{center}
		}
	\end{columns}
\end{frame}

\begin{frame}{Probability basics}
	\begin{itemize}[<+->]
		\item \textbf{Distribution}: assigns probability to each outcome
		\item For each outcome $x$: $0 \leq \Pr[x] \leq 1$
		\item Sum of all probabilities = 1
		\item \textbf{Uniform distribution}: $\Pr[x] = \frac{1}{|\mathcal{X}|}$ for all $x \in \mathcal{X}$
		\item Basic fact: $\Pr[A] = 1 - \Pr[\neg A]$
	\end{itemize}
\end{frame}

\begin{frame}{Notation in pseudocode}
	\begin{itemize}[<+->]
		\item $x \twoheadleftarrow \mathcal{D}$: sample $x$ from distribution $\mathcal{D}$
		\item $x \twoheadleftarrow \mathcal{X}$: sample $x$ uniformly from set $\mathcal{X}$
		\item $x \coloneq y$: assign value of $y$ to variable $x$
		\item $x \stackrel{?}{=} y$: check if $x$ equals $y$ (returns true/false)
	\end{itemize}
\end{frame}

\section{The Provable Security Mindset}

\begin{frame}{How it's made}
	\bigimagewithcaption{fischer-theory.png}{Fischer et al., The Challenges of Bringing Cryptography from Research Papers to Products: Results from an Interview Study with Experts, USENIX Security 2024}
\end{frame}

\begin{frame}{Thinking about secrecy}
	\bigimagewithcaption{naive-enc.pdf}{Source: The Joy of Cryptography}
\end{frame}

\begin{frame}{Thinking about secrecy}
	\begin{columns}[c]
		\column{0.5\textwidth}{
			\begin{itemize}[<+->]
				\item Keep the whole design secret?
				\item \textbf{``Advantages''}:
				      \begin{itemize}[<+->]
					      \item Attacker doesn't know how our cipher (or system, more generally,) works.
				      \end{itemize}
				\item \textbf{Disadvantages}:
				      \begin{itemize}[<+->]
					      \item Figuring out how the thing works might mean a break.
					      \item Can't expose cipher to scrutiny.
					      \item Everyone needs to invent a cipher.
				      \end{itemize}
			\end{itemize}
		}
		\column{0.5\textwidth}{
			\imagewithcaption{naive-enc.pdf}{Source: The Joy of Cryptography}
		}
	\end{columns}
\end{frame}

\begin{frame}{Kerckhoff's principle}
	\begin{itemize}[<+->]
		\item \textit{``A cryptosystem should be secure even if everything about the system, except the key, is public knowledge.''} â€” Auguste Kerckhoffs, 1883
		\item \textbf{Why it matters}:
		      \begin{itemize}[<+->]
			      \item No ``security through obscurity''
			      \item The key is the only secret: the rest can be audited, tested, trusted
			      \item Encourages open standards and peer review
			      \item If your system's security depends on nobody knowing how it works, it's not secure.
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Thinking about secrecy}
	\bigimagewithcaption{keyed-enc.pdf}{\textbf{Concentrate all the need for secrecy in the key!}}
\end{frame}

\begin{frame}{Thinking about secrecy}
	\begin{columns}[c]
		\column{0.5\textwidth}{
			\begin{itemize}[<+->]
				\item Cipher can be scrutinized, used by anyone.
				\item Design can be shown to hold so long as the key is secret.
				\item This is how virtually all cryptography is designed today.
			\end{itemize}
		}
		\column{0.5\textwidth}{
			\imagewithcaption{keyed-enc.pdf}{Source: The Joy of Cryptography}
		}
	\end{columns}
\end{frame}

\begin{frame}{One-time pad}{First look at a symmetric cipher}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\sssubroutine{Enc}{K, M}{
				$C \coloneq K \oplus M$ \\
				return $C$
			}{2}
		\end{column}
		\begin{column}{0.5\textwidth}
			\sssubroutine{Dec}{K, C}{
				$M \coloneq K \oplus C$ \\
				return $M$
			}{2}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{XOR (Exclusive OR) operation}
	\begin{columns}[c]
		\column{0.6\textwidth}{
			\begin{table}
				\centering
				\begin{tabular}{|c|c|c|}
					\hline
					\textbf{A} & \textbf{B} & \textbf{A $\oplus$ B} \\
					\hline
					\bit{0}    & \bit{0}    & \bit{0}               \\
					\hline
					\bit{0}    & \bit{1}    & \bit{1}               \\
					\hline
					\bit{1}    & \bit{0}    & \bit{1}               \\
					\hline
					\bit{1}    & \bit{1}    & \bit{0}               \\
					\hline
				\end{tabular}
				\caption{Truth table for XOR operation}
			\end{table}
			\begin{itemize}
				\item XOR returns 1 when inputs differ
				\item XOR returns 0 when inputs are the same
				\item Key property: $x \oplus x = 0$ and $x \oplus 0 = x$
				\item Self-inverse: $(M \oplus K) \oplus K = M$
			\end{itemize}
		}
		\column{0.4\textwidth}{
			\begin{center}
				\begin{tikzpicture}[scale=0.8]
					\draw[thick] (0,0) circle (1.5);
					\draw[thick] (1,0) circle (1.5);
					\node at (0,-2) {A};
					\node at (1,-2) {B};
					\begin{scope}
						\clip (0,0) circle (1.5);
						\clip (1,0) circle (1.5);
						\fill[cyan!30] (-1.5,-1.5) rectangle (2.5,1.5);
					\end{scope}
					\draw[thick] (0,0) circle (1.5);
					\draw[thick] (1,0) circle (1.5);
					\node at (0.5,0) {$A \oplus B$};
				\end{tikzpicture}
			\end{center}
		}
	\end{columns}
\end{frame}

\begin{frame}{One-time pad}{First look at a symmetric cipher}
	\bigimagewithcaption{xor-enc.png}{(We're encoding the message and key as bits)}
\end{frame}

\begin{frame}{One-time pad}{First look at a symmetric cipher}
	\bigimagewithcaption{xor-dec.png}{(We're encoding the message and key as bits)}
\end{frame}

\begin{frame}{Key derivation}{Uniform distribution}
	\begin{itemize}[<+->]
		\item How to derive $K$?
		\item $K$ is ideally random.
		\item True randomness isn't practical, so $K$ is in practice pseudo-random.
		\item We need a pseudo-random uniform distribution:
		\item If $\mathcal{S}$ is a set of $m$ items, then the uniform distribution over $\mathcal{S}$ assigns probability $\frac{1}{m}$ to each item $x \in \mathcal{S}$
		\item In practice, this just means we need the bits to be random, unpredictable, uniformly distributed in terms of probability
		\item Sampling a $K$ from a pseudo-random uniform distribution is written as $K \twoheadleftarrow \bits^n$
	\end{itemize}
\end{frame}

\begin{frame}{Adversary's access to oracle}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}[<+->]
				\item ``Victim'' chooses their key.
				      \begin{itemize}
					      \item Fresh key for each message (each key used only once)
					      \item This means output will differ even if same plaintext is input twice by adversary
				      \end{itemize}
				\item Adversary chooses the message and receives the ciphertext.
				\item We say that \textbf{the adversary has access to an encryption oracle}.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\imagewithcaption{attacker-interface.pdf}{Source: The Joy of Cryptography}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Adversary's access to oracle}
	\begin{center}
		\begin{tikzpicture}[
				box/.style={rectangle, draw, minimum height=2.5cm, align=left, fill=white},
				dashed box/.style={rectangle, draw, dashed, minimum width=2.5cm, minimum height=2.5cm, align=center, fill=white},
				>=Stealth,
			]
			\node[dashed box] (adversary) {$adversary$};
			\node[box, right=2cm of adversary](attack){
				$\underline{\func{attack}{M}}$: \hfill \quad \quad \textcolor{gray}{\scriptsize \textit{// adversary chooses $M$}} \\
				\quad $K \twoheadleftarrow \bits^{n}$ \hfill \quad \quad \textcolor{gray}{\scriptsize \textit{// victim samples $K$}} \\
				\quad $C \coloneq \textsf{Enc}(K, M)$ \hfill \quad \quad \textcolor{gray}{\scriptsize \textit{// victim encrypts}} \\
				\quad return $C$ \hfill \quad \quad \textcolor{gray}{\scriptsize \textit{// adversary sees $C$}}
			};
			\draw[->] (adversary) -- node[above] {$M$} (attack);
			\draw[<-] ([yshift=-0.5cm]adversary.east) -- node[below] {$C$} ([yshift=-0.5cm]attack.west);
		\end{tikzpicture}
	\end{center}
\end{frame}

\begin{frame}{Adversary's access to oracle}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}[<+->]
				\item Adversary can query oracle an unbounded number of times.
				\item Two queries with same $M$ return different $(C, C')$, since victim uses different $K$.
				\item $K$ is always chosen correctly (pseudo-random uniform sampling)
				\item ``Randomized oracle''
				\item Attacker cannot see $K$.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\imagewithcaption{attacker-interface.pdf}{Source: The Joy of Cryptography}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Adversary's access to oracle}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}
				\item When we prove security, we prove what is or isn't possible by the attacker calling \textsc{Attack}$(M)$.
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\imagewithcaption{attacker-interface.pdf}{Source: The Joy of Cryptography}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\begin{center}
		\Large\textit{``If I use OTP according to the attack scenario (I sample keys uniformly and use each key to encrypt just one ciphertext), then no matter how the plaintexts are chosen, and no matter how the ciphertext is subsequently used, I can enjoy a certain security guarantee.''}
	\end{center}
\end{frame}

\begin{frame}{One-time pad}{Correctness proof}
	\begin{itemize}[<+->]
		\item $\forall(n > 0,\; K \in \bits^{n},\; M \in \bits^{n}),\; \textsf{Dec}(K, \textsf{Enc}(K, M)) = M$
		\item For all positive $n$, any key of $n$ bits and message of $n$ bits will decrypt back to the same plaintext if encrypted into a ciphertext.
		\item \textbf{Proof}:
		      \begin{align*}
			      \textsf{Dec}(K, \textsf{Enc}(K, M)) & = \textsf{Dec}(K, K \oplus M) \\
			                                          & = K \oplus (K \oplus M)       \\
			                                          & = (K \oplus K) \oplus M       \\
			                                          & = 0^n \oplus M                \\
			                                          & = M \quad \qed
		      \end{align*}
	\end{itemize}
\end{frame}

\begin{frame}{One-time pad}{How do we prove security?}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}[<+->]
				\item \textbf{Generally}: a cipher is secure if the adversary can't distinguish the output of calls to $ATTACK$ from random junk.
				\item \textbf{Formally}: For all positive integers $n$ and all choices of plaintext $M \in \{\bit{0}, \bit{1}\}^n$, the output of the following subroutine is uniformly distributed:
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\sssubroutine{Attack}{M}{
				$K \twoheadleftarrow \bits^{n}$ \\
				$C \coloneq K \oplus M$ \\
				return $C$
			}{1.5}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{One-time pad}{How do we prove security?}
	\begin{columns}[c]
		\begin{column}{0.7\textwidth}
			\begin{itemize}[<+->]
				\item If the key is random, the output will be uniformly distributed!
				\item Suppose $M = \bit{01}$:
				      \begin{itemize}[<+->]
					      \item $K = \bit{00}$ is chosen with probability $1/4$:\\$C = K \oplus M = \bit{00} \oplus \bit{01} = \bit{01}$.
					      \item $K = \bit{01}$ is chosen with probability $1/4$:\\$C = K \oplus M = \bit{01} \oplus \bit{01} = \bit{00}$.
					      \item $K = \bit{10}$ is chosen with probability $1/4$:\\$C = K \oplus M = \bit{10} \oplus \bit{01} = \bit{11}$.
					      \item $K = \bit{11}$ is chosen with probability $1/4$:\\$C = K \oplus M = \bit{11} \oplus \bit{01} = \bit{10}$.
				      \end{itemize}
			\end{itemize}
		\end{column}
		\begin{column}{0.3\textwidth}
			\sssubroutine{Attack}{M}{
				$K \twoheadleftarrow \bits^{n}$ \\
				$C \coloneq K \oplus M$ \\
				return $C$
			}{1.5}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{One-time pad}{How do we prove security?}
	\begin{columns}[c]
		\begin{column}{0.7\textwidth}
			\begin{itemize}[<+->]
				\item What if this is true only for $M = \bit{01}$?
				\item Fine, let's pick any $M, C \in \bits^n$.
				\item What is \prob{\textsc{Attack}$(M) = C$}?
				\item Answer: Exactly when $C = \textsf{Enc}(K, M) = K \oplus M$.
				\item \ldots which occurs for exactly one $K$.
				\item Since $K$ is chosen uniformly from $\bits^n$, the probability of choosing that $K$ is $\frac{1}{2^n}. \quad \qed$
			\end{itemize}
		\end{column}
		\begin{column}{0.3\textwidth}
			\sssubroutine{Attack}{M}{
				$K \twoheadleftarrow \bits^{n}$ \\
				$C \coloneq K \oplus M$ \\
				return $C$
			}{1.5}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{One-time pad}{From the adversary's perspective\ldots}
	\begin{columns}[c]
		\begin{column}{0.35\textwidth}
			\sssubroutine{Attack}{M}{
				$K \twoheadleftarrow \bits^{n}$ \\
				$C \coloneq K \oplus M$ \\
				return $C$
			}{1.5}
		\end{column}
		\begin{column}{0.3\textwidth}
			\begin{center}
				{\huge{$\approxeq$}} \\[1em]
				{\scriptsize\textit{(indistinguishable \\ from)}}
			\end{center}
		\end{column}
		\begin{column}{0.35\textwidth}
			\sssubroutine{Junk}{M}{
				$C \twoheadleftarrow \bits^{n}$ \\
				return $C$
			}{2}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\begin{center}
		\huge \textit{``Real or random?''}
	\end{center}
\end{frame}

\begin{frame}{Limitations of security proofs}{Part 1}
	\begin{itemize}[<+->]
		\item Rigor and the real world famously don't mix.
		\item Security proofs are good for rigor but address very little regarding real-world concerns:
		      \begin{itemize}[<+->]
			      \item How can Alice \& Bob obtain a secret key, which only they know?
			      \item How can they keep $K$ secret?
			      \item How can a computer sample from the uniform distribution?
			      \item How can Alice ensure that $C$ is sent reliably to Bob?
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Limitations of security proofs}{Part 2}
	\begin{itemize}[<+->]
		\item More questions proofs don't address:
		      \begin{itemize}[<+->]
			      \item How can Alice hide the fact that she is talking to Bob (rather than hide only the content)?
			      \item How can Alice be sure that she is communicating with Bob, not an impostor?
			      \item How can we incentivize Alice and Bob to use encryption?
			      \item Should the government be allowed to obtain a warrant to read encrypted communications?
		      \end{itemize}
		\item Security proofs are about specific properties within specific models.
		\item Real-world security depends on many factors beyond what our models capture.
		\item Having a security proof is necessary but not sufficient for real-world security.
	\end{itemize}
\end{frame}

\begin{frame}{The value of security proofs}
	\begin{itemize}[<+->]
		\item Despite limitations, security proofs provide important benefits:
		      \begin{itemize}[<+->]
			      \item \textbf{Precise guarantees}: Clearly define what security properties are achieved.
			      \item \textbf{Confidence}: When properly structured, proofs ensure no obvious attacks exist.
			      \item \textbf{Foundation for composition}: Proven components can be securely combined.
			      \item \textbf{Precise terminology}: Forces us to clearly define our terms and assumptions.
		      \end{itemize}
		\item Security proofs help identify the \textit{boundaries} of security:
		      \begin{itemize}[<+->]
			      \item What assumptions are necessary?
			      \item What threats are addressed vs. unaddressed?
			      \item What conditions must hold for security to be maintained?
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{The provable security mindset}
	\begin{itemize}[<+->]
		\item Building systems with provable security in mind:
		      \begin{itemize}[<+->]
			      \item Start with clear security goals and adversary model.
			      \item Design systems whose security can be formally analyzed.
			      \item Identify and document necessary assumptions.
			      \item Distinguish between proven properties and conjectures.
		      \end{itemize}
		\item Good practical security requires both:
		      \begin{itemize}[<+->]
			      \item Rigorous proofs for core mechanisms.
			      \item Practical engineering to address real-world constraints.
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{OTP: security assumptions \& constraints}{Part 1}
	\begin{itemize}[<+->]
		\item Our security proofs rely on specific assumptions about the adversary:
		      \begin{itemize}[<+->]
			      \item \textbf{Key reuse}: Keys are never intentionally reused (though may repeat by chance).
			      \item \textbf{Observation only}: Adversary passively observes ciphertext but doesn't tamper with it
			      \item \textbf{Message independence}: Choice of message $M$ is independent of key $K$.
			      \item \textbf{Key secrecy}: Adversary learns nothing about the key.
			      \item \textbf{No sampling influence}: Adversary cannot influence how the key is sampled.
		      \end{itemize}
		\item These constraints are \textit{necessary} for the security proofs to hold!
	\end{itemize}
\end{frame}

\begin{frame}{OTP: security assumptions \& constraints}{Part 2}
	\begin{itemize}[<+->]
		\item Side-channel attacks violate our model:
		      \begin{itemize}[<+->]
			      \item We assume adversary cannot coerce victim to run a different algorithm.
			      \item Cannot observe execution details:
			            \begin{itemize}[<+->]
				            \item CPU timing information (clock cycles).
				            \item Memory access patterns.
				            \item Cache hits/misses.
				            \item Power consumption during encryption.
			            \end{itemize}
		      \end{itemize}
		\item Real-world security requires considering these additional attack vectors.
		\item Our security proofs address a \textit{specific threat model} that may not capture all real-world threats.
	\end{itemize}
\end{frame}

\begin{frame}{One-time pad}{What's so special about XOR?}
	\begin{columns}[c]
		\begin{column}{0.7\textwidth}
			\begin{itemize}[<+->]
				\item Let's replace $\oplus$ with $\land$. What would happen?
				\item Output no longer uniform!
			\end{itemize}
			\begin{table}
				\centering
				\begin{tabular}{|c|c|c|}
					\hline
					\textbf{A} & \textbf{B} & \textbf{A $\land$ B} \\
					\hline
					\bit{0}    & \bit{0}    & \bit{0}              \\
					\hline
					\bit{0}    & \bit{1}    & \bit{0}              \\
					\hline
					\bit{1}    & \bit{0}    & \bit{0}              \\
					\hline
					\bit{1}    & \bit{1}    & \bit{1}              \\
					\hline
				\end{tabular}
				\caption{Truth table for AND operation}
			\end{table}
		\end{column}
		\begin{column}{0.3\textwidth}
			\sssubroutine{Attack}{M}{
				$K \twoheadleftarrow \bits^{n}$ \\
				$C \coloneq K \land M$ \\
				return $C$
			}{1.5}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{One-time pad}{What about $\pmod{n}$?}
	\begin{columns}[c]
		\begin{column}{0.5\textwidth}
			\begin{itemize}[<+->]
				\item Let's replace $\oplus$ with $\pmod{n}$. What would happen?
				\item Still good!
				\item Can you prove correctness and security?
			\end{itemize}
		\end{column}
		\begin{column}{0.5\textwidth}
			\sssubroutine{Attack}{M}{
				$K \twoheadleftarrow \mathbb{Z}_{n}$ \\
				$C \coloneq (K + M)\ \pmod{n}$ \\
				return $C$
			}{1.5}
		\end{column}
	\end{columns}
\end{frame}

\section{Breaking One-Time Pads}

\begin{frame}{Two-time pads}{What happens when we reuse a key?}
	\begin{columns}[c]
		\column{1\textwidth}{
			\begin{itemize}[<+->]
				\item Alice sends two messages with the same key:
				\item $C_1 = M_1 \oplus K$
				\item $C_2 = M_2 \oplus K$
				\item What can Eve learn from $C_1$ and $C_2$?
				\item $C_1 \oplus C_2 = (M_1 \oplus K) \oplus (M_2 \oplus K)$
				\item $C_1 \oplus C_2 = M_1 \oplus M_2 \oplus (K \oplus K)$
				\item $C_1 \oplus C_2 = M_1 \oplus M_2$
				\item \alert{The key cancels out completely!}
			\end{itemize}
		}
	\end{columns}
\end{frame}

\begin{frame}{Exploiting $M_1 \oplus M_2$}{Why is this dangerous?}
	\begin{itemize}[<+->]
		\item Knowing $M_1 \oplus M_2$ allows statistical attacks:
		\item \textbf{Language patterns}: Natural language has predictable structure
		      \begin{itemize}[<+->]
			      \item Common words: ``the'', ``and'', ``of'', ``to''
			      \item Letter frequencies: E is most common in English (12.7\%)
			      \item Spaces are very frequent (about 18\% of characters)
		      \end{itemize}
		\item \textbf{Crib dragging}: Try XORing common words at different positions
		\item \textbf{Example}: If we guess ``the'' at position $i$ in $M_1$:
		      \begin{itemize}[<+->]
			      \item Extract: $(M_1 \oplus M_2)[i:i+3] \oplus \text{``the''}$
			      \item If result looks like valid text, we may have found part of $M_2$!
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Malleability of one-time pads}{Another practical weakness}
	\begin{columns}[c]
		\column{1\textwidth}{
			\begin{itemize}[<+->]
				\item OTP provides confidentiality but not integrity
				\item \textbf{Malleability}: Attacker can modify ciphertext predictably
				\item Given $C = M \oplus K$
				\item Attacker creates $C' = C \oplus \Delta$
				\item Decryption: $C' \oplus K = (M \oplus K \oplus \Delta) \oplus K$
				\item Result: $M' = M \oplus \Delta$
				\item \alert{Attacker controls the change without knowing $M$ or $K$!}
			\end{itemize}
		}
	\end{columns}
\end{frame}

\begin{frame}{Practical attack}{Bit flipping}
	\begin{itemize}[<+->]
		\item \textbf{Scenario}: Bank transfer message
		\item Original: ``Transfer \$0100.00 to Account 12345''
		\item Attacker knows position of amount field
		\item Flips bit to change `1' (ASCII 49 = \texttt{00110001}) to `9' (ASCII 57 = \texttt{00111001})
		\item XOR difference: \texttt{00110001} $\oplus$ \texttt{00111001} = \texttt{00001000}
		\item Apply $\Delta$ = \texttt{00001000} at correct position in ciphertext
		\item Result: ``Transfer \$0900.00 to Account 12345''
		\item \alert{No need to break encryption or know the key!}
	\end{itemize}
\end{frame}

\begin{frame}{Key Distribution Problem}{The elephant in the room}
	\begin{columns}[c]
		\column{0.5\textwidth}{
			\begin{itemize}[<+->]
				\item OTP requires key as long as message
				\item How do Alice and Bob share this key?
				\item \textbf{The paradox}:
				      \begin{itemize}[<+->]
					      \item If you can securely send the key...
					      \item ...why not just send the message?
				      \end{itemize}
				\item \textbf{Historical solutions}:
				      \begin{itemize}[<+->]
					      \item Diplomatic pouches
					      \item Trusted couriers
					      \item Pre-shared codebooks
				      \end{itemize}
				\item \textbf{Modern issue}: Impractical for internet scale
			\end{itemize}
		}
		\column{0.5\textwidth}{
			\begin{center}
				\begin{tikzpicture}[scale=0.8]
					\node[circle, draw, minimum size=1cm] (alice) at (0, 0) {Alice};
					\node[circle, draw, minimum size=1cm] (bob) at (5, 0) {Bob};
					\node[circle, draw, minimum size=1cm, fill=red!20] (eve) at (2.5, -2) {Eve};

					\draw[<->, thick, dashed, red] (alice) -- node[above] {Key?} (bob);
					\draw[->, thick, red] (eve) -- (2.5, -0.5);

					\node[text width=4cm, align=center] at (2.5, 2) {\small \textbf{Problem}: How to share key securely?};

					\node[text width=5cm, align=center] at (2.5, -3.5) {\small If channel is secure for key, why not use it for message?};
				\end{tikzpicture}
			\end{center}
		}
	\end{columns}
\end{frame}

\begin{frame}{Lessons from OTP in practice}
	\begin{itemize}[<+->]
		\item \textbf{Perfect in theory $\neq$ Perfect in practice}
		      \begin{itemize}[<+->]
			      \item Mathematical security doesn't guarantee practical security
			      \item Implementation details matter enormously
		      \end{itemize}
		\item \textbf{Common failure modes}:
		      \begin{itemize}[<+->]
			      \item Key reuse (breaks confidentiality completely)
			      \item Predictable ``random'' numbers
			      \item Malleability attacks (no integrity protection)
			      \item Key distribution challenges
		      \end{itemize}
		\item \textbf{Modern best practices}:
		      \begin{itemize}[<+->]
			      \item Use authenticated encryption (AE/AEAD)
			      \item Proper random number generation
			      \item Key management systems
			      \item Defense in depth
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{From theory to practice}
	\begin{columns}[c]
		\column{0.5\textwidth}{
			\begin{itemize}[<+->]
				\item \textbf{Theory provides foundation}:
				      \begin{itemize}[<+->]
					      \item Precise security definitions
					      \item Mathematical guarantees
					      \item Clear assumptions
				      \end{itemize}
				\item \textbf{Practice reveals challenges}:
				      \begin{itemize}[<+->]
					      \item Implementation vulnerabilities
					      \item Usability constraints
					      \item Side-channel attacks
					      \item Human factors
				      \end{itemize}
			\end{itemize}
		}
		\column{0.5\textwidth}{
			\begin{center}
				\begin{tikzpicture}[scale=0.8]
					\draw[thick, fill=green!20] (-1,0) circle (1.5cm);
					\node at (-1,0) {Theory};
					\draw[thick, fill=blue!20] (1.8,0) circle (1.5cm);
					\node at (1.8,0) {Practice};
					\node[text width=3cm, align=center] at (0.5,-2.5) {\small \textbf{Sweet spot}: Provably secure \& practically usable};
					\draw[->, thick, red] (0.4,-1.5) -- (0.4,-0.3);
				\end{tikzpicture}
			\end{center}
		}
	\end{columns}
\end{frame}

\begin{frame}[plain]
	\titlepage
\end{frame}

\end{document}
